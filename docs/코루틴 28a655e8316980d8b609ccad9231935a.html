<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>코루틴</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 10px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.collection-content td {
	white-space: pre-wrap;
	word-break: break-word;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	padding-inline-start: 0;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.page-description {
	margin-bottom: 2em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-flex;
	align-items: center;
	justify-content: center;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.callout img.notion-static-icon {
	width: 1em;
	height: 1em;
}

.callout p {
	margin: 0;
}

.callout h1,
.callout h2,
.callout h3 {
	margin: 0 0 0.6rem;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

blockquote.quote-large {
	font-size: 1.25em;
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI Variable Display", "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(44, 44, 43, 1);
}
.highlight-gray {
	color: rgba(125, 122, 117, 1);
	fill: rgba(125, 122, 117, 1);
}
.highlight-brown {
	color: rgba(159, 118, 90, 1);
	fill: rgba(159, 118, 90, 1);
}
.highlight-orange {
	color: rgba(210, 123, 45, 1);
	fill: rgba(210, 123, 45, 1);
}
.highlight-yellow {
	color: rgba(203, 148, 52, 1);
	fill: rgba(203, 148, 52, 1);
}
.highlight-teal {
	color: rgba(80, 148, 110, 1);
	fill: rgba(80, 148, 110, 1);
}
.highlight-blue {
	color: rgba(56, 125, 201, 1);
	fill: rgba(56, 125, 201, 1);
}
.highlight-purple {
	color: rgba(154, 107, 180, 1);
	fill: rgba(154, 107, 180, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(207, 81, 72, 1);
	fill: rgba(207, 81, 72, 1);
}
.highlight-default_background {
	color: rgba(44, 44, 43, 1);
}
.highlight-gray_background {
	background: rgba(42, 28, 0, 0.07);
}
.highlight-brown_background {
	background: rgba(139, 46, 0, 0.086);
}
.highlight-orange_background {
	background: rgba(224, 101, 1, 0.129);
}
.highlight-yellow_background {
	background: rgba(211, 168, 0, 0.137);
}
.highlight-teal_background {
	background: rgba(0, 100, 45, 0.09);
}
.highlight-blue_background {
	background: rgba(0, 124, 215, 0.094);
}
.highlight-purple_background {
	background: rgba(102, 0, 178, 0.078);
}
.highlight-pink_background {
	background: rgba(197, 0, 93, 0.086);
}
.highlight-red_background {
	background: rgba(223, 22, 0, 0.094);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(125, 122, 117, 1);
	fill: rgba(125, 122, 117, 1);
}
.block-color-brown {
	color: rgba(159, 118, 90, 1);
	fill: rgba(159, 118, 90, 1);
}
.block-color-orange {
	color: rgba(210, 123, 45, 1);
	fill: rgba(210, 123, 45, 1);
}
.block-color-yellow {
	color: rgba(203, 148, 52, 1);
	fill: rgba(203, 148, 52, 1);
}
.block-color-teal {
	color: rgba(80, 148, 110, 1);
	fill: rgba(80, 148, 110, 1);
}
.block-color-blue {
	color: rgba(56, 125, 201, 1);
	fill: rgba(56, 125, 201, 1);
}
.block-color-purple {
	color: rgba(154, 107, 180, 1);
	fill: rgba(154, 107, 180, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(207, 81, 72, 1);
	fill: rgba(207, 81, 72, 1);
}
.block-color-default_background {
	color: inherit;
	fill: inherit;
}
.block-color-gray_background {
	background: rgba(240, 239, 237, 1);
}
.block-color-brown_background {
	background: rgba(245, 237, 233, 1);
}
.block-color-orange_background {
	background: rgba(251, 235, 222, 1);
}
.block-color-yellow_background {
	background: rgba(249, 243, 220, 1);
}
.block-color-teal_background {
	background: rgba(232, 241, 236, 1);
}
.block-color-blue_background {
	background: rgba(229, 242, 252, 1);
}
.block-color-purple_background {
	background: rgba(243, 235, 249, 1);
}
.block-color-pink_background {
	background: rgba(250, 233, 241, 1);
}
.block-color-red_background {
	background: rgba(252, 233, 231, 1);
}
.select-value-color-default { background-color: rgba(42, 28, 0, 0.07); }
.select-value-color-gray { background-color: rgba(28, 19, 1, 0.11); }
.select-value-color-brown { background-color: rgba(127, 51, 0, 0.156); }
.select-value-color-orange { background-color: rgba(196, 88, 0, 0.203); }
.select-value-color-yellow { background-color: rgba(209, 156, 0, 0.282); }
.select-value-color-green { background-color: rgba(0, 96, 38, 0.156); }
.select-value-color-blue { background-color: rgba(0, 118, 217, 0.203); }
.select-value-color-purple { background-color: rgba(92, 0, 163, 0.141); }
.select-value-color-pink { background-color: rgba(183, 0, 78, 0.152); }
.select-value-color-red { background-color: rgba(206, 24, 0, 0.164); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="28a655e8-3169-80d8-b609-ccad9231935a" class="page sans"><header><h1 class="page-title">코루틴</h1><p class="page-description"></p></header><div class="page-body"><ul id="2a8655e8-3169-8037-acfa-f480139e5ca4" class="toggle"><li><details open=""><summary>코루틴 심화가이드</summary><h1 id="2a8655e8-3169-806e-b36b-c8b5756a2f59" class="">Kotlin 코루틴 심화 가이드</h1><p id="2a8655e8-3169-80aa-b729-effc1be26262" class="">이 문서는 Coding Platform 프로젝트에서 사용되는 Kotlin 코루틴의 고급 개념과 실전 패턴을 다룹니다.</p><h2 id="2a8655e8-3169-803b-a4b8-f65ea59b469b" class="">목차</h2><ol type="1" id="2a8655e8-3169-8092-8901-dc4dabc4d0e4" class="numbered-list" start="1"><li><a href="https://www.notion.so/28a655e8316980d8b609ccad9231935a?pvs=21">코루틴 기본 개념</a></li></ol><ol type="1" id="2a8655e8-3169-8091-a406-c97c360742ba" class="numbered-list" start="2"><li><a href="https://www.notion.so/28a655e8316980d8b609ccad9231935a?pvs=21">Dispatchers 상세</a></li></ol><ol type="1" id="2a8655e8-3169-80ab-a1af-d602774b5f8b" class="numbered-list" start="3"><li><a href="https://www.notion.so/28a655e8316980d8b609ccad9231935a?pvs=21">구조화된 동시성</a></li></ol><ol type="1" id="2a8655e8-3169-8067-90b8-e6dca208b558" class="numbered-list" start="4"><li><a href="https://www.notion.so/28a655e8316980d8b609ccad9231935a?pvs=21">코루틴 스코프</a></li></ol><ol type="1" id="2a8655e8-3169-804a-825b-e4e296c75a38" class="numbered-list" start="5"><li><a href="https://www.notion.so/28a655e8316980d8b609ccad9231935a?pvs=21">에러 처리</a></li></ol><ol type="1" id="2a8655e8-3169-80b6-b64b-c13396d639c6" class="numbered-list" start="6"><li><a href="https://www.notion.so/28a655e8316980d8b609ccad9231935a?pvs=21">실전 패턴</a></li></ol><hr id="2a8655e8-3169-80bf-a4ba-fd3f34b9ef3d"/><h2 id="2a8655e8-3169-8030-80cb-fe0b616bc2a2" class="">1. 코루틴 기본 개념</h2><h3 id="2a8655e8-3169-80ce-9016-c2ca6cd7021a" class="">1.1 코루틴이란?</h3><p id="2a8655e8-3169-808a-977f-e37d67459099" class="">코루틴(Coroutine)은 <strong>일시 중단 가능한 계산</strong>입니다.</p><ul id="2a8655e8-3169-800d-b73a-ebc31d917be1" class="bulleted-list"><li style="list-style-type:disc">스레드보다 훨씬 가볍습니다 (수천 개 동시 실행 가능)</li></ul><ul id="2a8655e8-3169-8084-8b27-dea4a20074d3" class="bulleted-list"><li style="list-style-type:disc">메모리 오버헤드가 적습니다</li></ul><ul id="2a8655e8-3169-80db-966e-cbfd1a556036" class="bulleted-list"><li style="list-style-type:disc">컨텍스트 스위칭 비용이 거의 없습니다</li></ul><h3 id="2a8655e8-3169-80db-a2c5-cbc8ed5a0cc1" class="">1.2 suspend 함수의 동작 원리</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-806b-9836-f080eae5728b" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">suspend fun fetchUser(id: String): User {
    delay(1000)  // 1초 대기 (스레드 블로킹 없음!)
    return User(id, &quot;홍길동&quot;)
}
</code></pre><p id="2a8655e8-3169-80c9-85a7-ed5063b6ad66" class=""><strong>내부 동작</strong>:</p><ol type="1" id="2a8655e8-3169-805b-8574-fcbd51594671" class="numbered-list" start="1"><li><code>delay(1000)</code> 호출 시 코루틴이 <strong>일시 중단</strong>됩니다</li></ol><ol type="1" id="2a8655e8-3169-8050-bfcd-e5901192db21" class="numbered-list" start="2"><li>스레드는 다른 작업을 수행할 수 있습니다</li></ol><ol type="1" id="2a8655e8-3169-80bb-a50a-e76c7c59c114" class="numbered-list" start="3"><li>1초 후 코루틴이 <strong>재개</strong>됩니다</li></ol><ol type="1" id="2a8655e8-3169-801b-b283-de8ee8d37504" class="numbered-list" start="4"><li>나머지 코드가 실행됩니다</li></ol><p id="2a8655e8-3169-801e-a67b-fe159bdcbde6" class=""><strong>vs Thread.sleep()</strong>:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-80f4-bec3-f7f709da00aa" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">// ❌ 스레드 블로킹 (나쁜 예)
fun fetchUser(id: String): User {
    Thread.sleep(1000)  // 스레드가 1초간 아무것도 못 함
    return User(id, &quot;홍길동&quot;)
}

// ✅ 코루틴 일시 중단 (좋은 예)
suspend fun fetchUser(id: String): User {
    delay(1000)  // 스레드는 다른 작업 가능
    return User(id, &quot;홍길동&quot;)
}
</code></pre><h3 id="2a8655e8-3169-809a-a2e8-e3844746ad20" class="">1.3 코루틴 빌더</h3><p id="2a8655e8-3169-8041-83c3-dd1cd9812958" class=""><strong>launch</strong>: 결과를 반환하지 않는 코루틴 시작</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-8030-8568-e5d68704ca34" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">GlobalScope.launch {
    println(&quot;코루틴 시작&quot;)
    delay(1000)
    println(&quot;1초 후&quot;)
}
</code></pre><p id="2a8655e8-3169-80ee-b2a1-d64f2c5cb26f" class=""><strong>async</strong>: 결과를 반환하는 코루틴 시작</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-808c-b2c5-f25ecac82c3f" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">val deferred = GlobalScope.async {
    delay(1000)
    &quot;결과&quot;
}
val result = deferred.await()  // 결과 대기
</code></pre><p id="2a8655e8-3169-800e-b456-dbf25efe9ba0" class=""><strong>runBlocking</strong>: 코루틴을 블로킹 방식으로 실행</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-80b6-a9c8-ce1030cc641a" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">fun main() = runBlocking {
    delay(1000)
    println(&quot;1초 후&quot;)
}
</code></pre><hr id="2a8655e8-3169-8000-b1ae-e8daab2c2396"/><h2 id="2a8655e8-3169-8034-994b-d7a1ea37f300" class="">2. Dispatchers 상세</h2><h3 id="2a8655e8-3169-80b9-91f7-fc2e931cc787" class="">2.1 Dispatcher 종류와 사용 시나리오</h3><p id="2a8655e8-3169-8052-b8ea-f43190b3fc13" class=""><strong>Dispatchers.Default</strong></p><ul id="2a8655e8-3169-80fe-88fe-cc91900b1b6a" class="bulleted-list"><li style="list-style-type:disc">CPU 집약적 작업에 사용</li></ul><ul id="2a8655e8-3169-80b5-ab0a-d3e5a12322cb" class="bulleted-list"><li style="list-style-type:disc">스레드 풀 크기: CPU 코어 수</li></ul><ul id="2a8655e8-3169-803e-9b57-ffbf1efac4de" class="bulleted-list"><li style="list-style-type:disc">예: 정렬, 계산, 데이터 변환</li></ul><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-8072-acd3-cbc85dc0701b" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">suspend fun processLargeData(data: List&lt;Int&gt;): List&lt;Int&gt; =
    withContext(Dispatchers.Default) {
        data.map { it * 2 }  // CPU 집약적 작업
            .sorted()
    }
</code></pre><p id="2a8655e8-3169-800e-a4a4-c35b922b399f" class=""><strong><a href="http://dispatchers.io/">Dispatchers.IO</a></strong></p><ul id="2a8655e8-3169-809a-93dd-ded302f81b36" class="bulleted-list"><li style="list-style-type:disc">I/O 작업에 사용</li></ul><ul id="2a8655e8-3169-8065-b5e0-d7029159a6de" class="bulleted-list"><li style="list-style-type:disc">스레드 풀 크기: 64개 (또는 코어 수 중 큰 값)</li></ul><ul id="2a8655e8-3169-80ce-95f0-f4e88deb819f" class="bulleted-list"><li style="list-style-type:disc">예: 파일 읽기/쓰기, 네트워크 요청, DB 쿼리</li></ul><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-80f8-b617-ef0bd75c2521" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">suspend fun readFile(path: String): String =
    withContext(Dispatchers.IO) {
        File(path).readText()
    }

suspend fun queryDatabase(): List&lt;User&gt; =
    withContext(Dispatchers.IO) {
        transaction {
            Users.selectAll().map { toUser(it) }
        }
    }
</code></pre><p id="2a8655e8-3169-80c4-b898-e670b72d99cd" class=""><strong>프로젝트 예시</strong>: <code>DatabaseFactory.kt</code></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-80bf-8a4c-e8cfb04fc322" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">suspend fun &lt;T&gt; dbQuery(block: Transaction.() -&gt; T): T =
    withContext(Dispatchers.IO) {  // DB 작업은 IO Dispatcher
        transaction(database) {
            block(this)
        }
    }
</code></pre><p id="2a8655e8-3169-803d-a45a-d8fad22bbfd1" class=""><strong>Dispatchers.Main</strong></p><ul id="2a8655e8-3169-808f-b64e-fcd02fcc4fc0" class="bulleted-list"><li style="list-style-type:disc">UI 스레드 (Android/Desktop)</li></ul><ul id="2a8655e8-3169-802f-9075-dccba651a1e0" class="bulleted-list"><li style="list-style-type:disc">백엔드에서는 사용하지 않음</li></ul><p id="2a8655e8-3169-80fd-88bb-cfc0cc84d1a6" class=""><strong>Dispatchers.Unconfined</strong></p><ul id="2a8655e8-3169-80dd-a8a8-dd8b8308bc4a" class="bulleted-list"><li style="list-style-type:disc">특정 스레드에 제한되지 않음</li></ul><ul id="2a8655e8-3169-806c-9dce-c82674bd8699" class="bulleted-list"><li style="list-style-type:disc">일반적으로 사용하지 않음 (디버깅 용도)</li></ul><h3 id="2a8655e8-3169-80ef-8b3e-e28d122d6596" class="">2.2 Dispatcher 전환</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-800f-8615-d790b8741aa1" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">suspend fun complexOperation() {
    // 기본 Dispatcher에서 시작
    println(&quot;Thread: ${Thread.currentThread().name}&quot;)

    // IO Dispatcher로 전환
    withContext(Dispatchers.IO) {
        println(&quot;Thread: ${Thread.currentThread().name}&quot;)
        // 파일 읽기
    }

    // Default Dispatcher로 전환
    withContext(Dispatchers.Default) {
        println(&quot;Thread: ${Thread.currentThread().name}&quot;)
        // 데이터 처리
    }

    // 원래 Dispatcher로 자동 복귀
    println(&quot;Thread: ${Thread.currentThread().name}&quot;)
}
</code></pre><h3 id="2a8655e8-3169-8010-92a9-f03854ccc431" class="">2.3 프로젝트 실전 예시</h3><p id="2a8655e8-3169-80eb-a494-d75c6078215a" class=""><strong>DockerExecutorService.kt</strong>:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-80e2-b3be-ee2c472345ac" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">class DockerExecutorService(
    private val dockerManager: DockerManager,
    private val testRunnerService: TestRunnerService
) {
    // Docker 작업은 I/O 작업이므로 Dispatchers.IO 사용
    suspend fun executeCode(
        language: Language,
        files: Map&lt;String, String&gt;,
        command: String
    ): ExecutionResult = withContext(Dispatchers.IO) {
        dockerManager.executeCode(
            executionId = UUID.randomUUID().toString(),
            language = language,
            files = files,
            command = listOf(&quot;sh&quot;, &quot;-c&quot;, command)
        )
    }

    suspend fun evaluateSubmission(
        submission: Submission,
        problem: Problem
    ): SubmissionFeedback = withContext(Dispatchers.IO) {
        // 1. 테스트 실행 (I/O 작업)
        val (executionResult, testResults) = runTests(submission, problem)

        // 2. 점수 계산 (CPU 작업이지만 간단하므로 같은 Dispatcher 사용)
        val passRate = if (testResults.total == 0) 0.0
                       else testResults.passed.toDouble() / testResults.total
        val score = (passRate * 100).roundToInt()

        // 3. 피드백 생성
        SubmissionFeedback(/* ... */)
    }
}
</code></pre><hr id="2a8655e8-3169-8058-afb9-deba8c132c82"/><h2 id="2a8655e8-3169-8052-8474-de17448de292" class="">3. 구조화된 동시성</h2><h3 id="2a8655e8-3169-802b-a71a-fd8135c82180" class="">3.1 개념</h3><p id="2a8655e8-3169-8054-ae99-dd5e198cdd9a" class="">구조화된 동시성(Structured Concurrency)은 코루틴의 생명주기를 명확하게 관리하는 원칙입니다.</p><p id="2a8655e8-3169-80ed-a13a-f8595089e60a" class=""><strong>핵심 원칙</strong>:</p><ol type="1" id="2a8655e8-3169-80cc-98fb-cf85e3b6ca11" class="numbered-list" start="1"><li>부모 코루틴이 취소되면 자식 코루틴도 취소됩니다</li></ol><ol type="1" id="2a8655e8-3169-80d2-a68d-ec6a789b6046" class="numbered-list" start="2"><li>부모 코루틴은 모든 자식 코루틴이 완료될 때까지 대기합니다</li></ol><ol type="1" id="2a8655e8-3169-80db-94e3-d980f7546af4" class="numbered-list" start="3"><li>자식 코루틴에서 예외가 발생하면 부모에게 전파됩니다</li></ol><h3 id="2a8655e8-3169-80fe-92ef-d7fe3f473223" class="">3.2 coroutineScope</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-8036-88b1-d40d5d2949d0" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">suspend fun fetchUserData(userId: String): UserData = coroutineScope {
    // 이 블록 안의 모든 코루틴이 완료될 때까지 대기
    val userDeferred = async { fetchUser(userId) }
    val ordersDeferred = async { fetchOrders(userId) }
    val profileDeferred = async { fetchProfile(userId) }

    UserData(
        user = userDeferred.await(),
        orders = ordersDeferred.await(),
        profile = profileDeferred.await()
    )
}
</code></pre><p id="2a8655e8-3169-801b-80d0-d104f585c630" class=""><strong>특징</strong>:</p><ul id="2a8655e8-3169-80a4-b282-f1f7f34d087d" class="bulleted-list"><li style="list-style-type:disc">모든 자식 코루틴이 완료될 때까지 함수가 반환되지 않습니다</li></ul><ul id="2a8655e8-3169-80e4-904a-d6c2df1e865a" class="bulleted-list"><li style="list-style-type:disc">하나의 자식 코루틴이 실패하면 다른 모든 자식도 취소됩니다</li></ul><h3 id="2a8655e8-3169-800d-b2a6-fcf0730a34be" class="">3.3 supervisorScope</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-8028-91d3-f6793b8e2023" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">suspend fun fetchDataWithFallback(userId: String): UserData = supervisorScope {
    val userDeferred = async { fetchUser(userId) }
    val ordersDeferred = async {
        try {
            fetchOrders(userId)
        } catch (e: Exception) {
            emptyList()  // 실패 시 빈 리스트
        }
    }

    UserData(
        user = userDeferred.await(),
        orders = ordersDeferred.await()
    )
}
</code></pre><p id="2a8655e8-3169-80d9-8121-d297e8ccb404" class=""><strong>특징</strong>:</p><ul id="2a8655e8-3169-80cb-90a6-f0b0decd57c9" class="bulleted-list"><li style="list-style-type:disc">하나의 자식 코루틴이 실패해도 다른 자식은 계속 실행됩니다</li></ul><ul id="2a8655e8-3169-80db-9c38-d8b9210c9d41" class="bulleted-list"><li style="list-style-type:disc">독립적인 작업을 병렬로 실행할 때 유용합니다</li></ul><h3 id="2a8655e8-3169-804f-b32d-d03d116c1b27" class="">3.4 실전 예시: 여러 제출 동시 평가</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-80d7-a2da-cebf82819895" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">suspend fun evaluateMultipleSubmissions(
    submissionIds: List&lt;String&gt;
): List&lt;Result&lt;SubmissionFeedback&gt;&gt; = coroutineScope {
    submissionIds.map { id -&gt;
        async {
            try {
                val submission = findById(id) ?: error(&quot;제출을 찾을 수 없습니다&quot;)
                val problem = problemService.findById(submission.problemId)
                    ?: error(&quot;문제를 찾을 수 없습니다&quot;)
                Result.success(dockerExecutorService.evaluateSubmission(submission, problem))
            } catch (e: Exception) {
                Result.failure(e)
            }
        }
    }.awaitAll()
}
</code></pre><hr id="2a8655e8-3169-80cd-8eee-d5ca7c57d095"/><h2 id="2a8655e8-3169-805b-9963-f6e190cf9a95" class="">4. 코루틴 스코프</h2><h3 id="2a8655e8-3169-8089-a0f0-fac891017b14" class="">4.1 GlobalScope (사용 지양)</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-80cf-8388-ee69d30edc4d" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">// ❌ 나쁜 예: 생명주기 관리 안 됨
GlobalScope.launch {
    // 애플리케이션이 종료되어도 계속 실행될 수 있음
    delay(10000)
    println(&quot;10초 후&quot;)
}
</code></pre><h3 id="2a8655e8-3169-8093-80bf-ff8df86fea78" class="">4.2 CoroutineScope 생성</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-80e6-ae8b-fc542fed9169" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">class MyService {
    private val scope = CoroutineScope(Dispatchers.Default + SupervisorJob())

    fun startBackgroundTask() {
        scope.launch {
            // 백그라운드 작업
        }
    }

    fun cleanup() {
        scope.cancel()  // 모든 코루틴 취소
    }
}
</code></pre><h3 id="2a8655e8-3169-8015-b7d7-eab4640f872b" class="">4.3 프로젝트 예시: SubmissionService</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-80fa-8770-d884e92d825f" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">class SubmissionService(
    private val databaseFactory: DatabaseFactory,
    private val problemService: ProblemService,
    private val dockerExecutorService: DockerExecutorService
) {
    private val scope = CoroutineScope(Dispatchers.Default + SupervisorJob())

    suspend fun createSubmission(
        userId: UUID,
        problemId: UUID,
        files: Map&lt;String, String&gt;
    ): Submission {
        // 1. 제출 레코드 생성
        val submission = databaseFactory.dbQuery {
            // DB에 저장
        }

        // 2. 백그라운드에서 비동기 평가
        scope.launch {
            evaluateSubmission(submission.id)
        }

        return submission
    }

    private suspend fun evaluateSubmission(submissionId: String) {
        try {
            val submission = findById(submissionId) ?: return
            val problem = problemService.findById(submission.problemId) ?: return

            val feedback = dockerExecutorService.evaluateSubmission(submission, problem)

            // 결과 저장
            databaseFactory.dbQuery {
                Submissions.update({ Submissions.id eq submissionId }) {
                    it[status] = feedback.status.name
                    it[score] = feedback.score
                    it[feedback] = Json.encodeToString(feedback)
                }
            }
        } catch (e: Exception) {
            logger.error(&quot;평가 실패: $submissionId&quot;, e)
        }
    }

    fun shutdown() {
        scope.cancel()
    }
}
</code></pre><hr id="2a8655e8-3169-80a5-bb12-c0c4d0f98bb6"/><h2 id="2a8655e8-3169-80e4-aa4c-eb0e6131bf87" class="">5. 에러 처리</h2><h3 id="2a8655e8-3169-8013-96be-e906705cc0b0" class="">5.1 try-catch</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-80ed-bed6-f1689898c6bb" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">suspend fun fetchUser(id: String): User? {
    return try {
        databaseFactory.dbQuery {
            Users.select { Users.id eq UUID.fromString(id) }
                .firstOrNull()
                ?.let { toUser(it) }
        }
    } catch (e: Exception) {
        logger.error(&quot;사용자 조회 실패: $id&quot;, e)
        null
    }
}
</code></pre><h3 id="2a8655e8-3169-805d-8134-c2ae90a7e7de" class="">5.2 CoroutineExceptionHandler</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-80e5-a6c7-d12a4facf492" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">val exceptionHandler = CoroutineExceptionHandler { _, exception -&gt;
    logger.error(&quot;코루틴 예외 발생&quot;, exception)
}

val scope = CoroutineScope(Dispatchers.Default + exceptionHandler)

scope.launch {
    throw RuntimeException(&quot;에러!&quot;)  // exceptionHandler가 처리
}
</code></pre><h3 id="2a8655e8-3169-80f5-8b0a-da834d11df93" class="">5.3 SupervisorJob으로 격리</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-80c1-9b64-cc65cda148f4" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">suspend fun processMultipleItems(items: List&lt;String&gt;) = supervisorScope {
    items.forEach { item -&gt;
        launch {
            try {
                processItem(item)
            } catch (e: Exception) {
                logger.error(&quot;아이템 처리 실패: $item&quot;, e)
                // 다른 아이템 처리는 계속됨
            }
        }
    }
}
</code></pre><h3 id="2a8655e8-3169-80d1-a1a2-cbcd0815ec84" class="">5.4 실전 예시: 제출 평가 에러 처리</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-8087-b47f-c2eccca05686" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">private suspend fun evaluateSubmission(submissionId: String) {
    try {
        // 1. 데이터 조회
        val submission = findById(submissionId)
            ?: throw IllegalArgumentException(&quot;제출을 찾을 수 없습니다: $submissionId&quot;)
        val problem = problemService.findById(submission.problemId)
            ?: throw IllegalArgumentException(&quot;문제를 찾을 수 없습니다: ${submission.problemId}&quot;)

        // 2. 평가 실행
        val feedback = try {
            dockerExecutorService.evaluateSubmission(submission, problem)
        } catch (e: Exception) {
            logger.error(&quot;Docker 실행 실패: $submissionId&quot;, e)
            SubmissionFeedback(
                totalTests = 0,
                passedTests = 0,
                failedTests = 0,
                passRate = 0.0,
                score = 0,
                status = ExecutionStatus.ERROR,
                testResults = TestResults(0, 0, 0, emptyList()),
                output = &quot;&quot;,
                message = &quot;실행 중 오류가 발생했습니다: ${e.message}&quot;
            )
        }

        // 3. 결과 저장
        databaseFactory.dbQuery {
            Submissions.update({ Submissions.id eq submissionId }) {
                it[status] = feedback.status.name
                it[score] = feedback.score
                it[this.feedback] = Json.encodeToString(feedback)
            }
        }
    } catch (e: Exception) {
        logger.error(&quot;평가 프로세스 실패: $submissionId&quot;, e)
        // 최종 에러 상태로 업데이트
        try {
            databaseFactory.dbQuery {
                Submissions.update({ Submissions.id eq submissionId }) {
                    it[status] = ExecutionStatus.ERROR.name
                }
            }
        } catch (dbError: Exception) {
            logger.error(&quot;DB 업데이트 실패: $submissionId&quot;, dbError)
        }
    }
}
</code></pre><hr id="2a8655e8-3169-8030-bcf1-f3bb7860f409"/><h2 id="2a8655e8-3169-8050-b89c-db39f6868fd8" class="">6. 실전 패턴</h2><h3 id="2a8655e8-3169-802e-a171-f54480fc451c" class="">6.1 타임아웃 설정</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-8054-90f3-fd78727963a5" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">suspend fun fetchWithTimeout(url: String): String {
    return withTimeout(5000) {  // 5초 타임아웃
        httpClient.get(url)
    }
}

// 타임아웃 시 null 반환
suspend fun fetchWithTimeoutOrNull(url: String): String? {
    return withTimeoutOrNull(5000) {
        httpClient.get(url)
    }
}
</code></pre><p id="2a8655e8-3169-8080-b60b-ffee8c82c524" class=""><strong>프로젝트 예시</strong>: Docker 컨테이너 실행</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-807b-9a4c-c797d41d2b41" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">private fun runContainer(
    container: CreateContainerResponse,
    timeout: Long
): ContainerExecutionResult {
    val exitCode = try {
        dockerClient.waitContainerCmd(containerId)
            .exec(WaitContainerResultCallback())
            .awaitStatusCode(timeout, TimeUnit.SECONDS)  // 타임아웃 적용
    } catch (ex: Exception) {
        dockerClient.killContainerCmd(containerId).exec()  // 강제 종료
        -1
    }
    // ...
}
</code></pre><h3 id="2a8655e8-3169-80e0-87a0-fea18b3514a0" class="">6.2 재시도 패턴</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-8030-ab21-f2b427b86b37" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">suspend fun &lt;T&gt; retryWithExponentialBackoff(
    times: Int = 3,
    initialDelay: Long = 100,
    maxDelay: Long = 1000,
    factor: Double = 2.0,
    block: suspend () -&gt; T
): T {
    var currentDelay = initialDelay
    repeat(times - 1) { attempt -&gt;
        try {
            return block()
        } catch (e: Exception) {
            logger.warn(&quot;시도 ${attempt + 1} 실패, ${currentDelay}ms 후 재시도&quot;, e)
        }
        delay(currentDelay)
        currentDelay = (currentDelay * factor).toLong().coerceAtMost(maxDelay)
    }
    return block()  // 마지막 시도
}

// 사용 예시
suspend fun fetchUserWithRetry(id: String): User {
    return retryWithExponentialBackoff(times = 3) {
        databaseFactory.dbQuery {
            Users.select { Users.id eq UUID.fromString(id) }
                .firstOrNull()
                ?.let { toUser(it) }
                ?: throw NoSuchElementException(&quot;사용자를 찾을 수 없습니다&quot;)
        }
    }
}
</code></pre><h3 id="2a8655e8-3169-8056-9d94-dafdfc68f518" class="">6.3 병렬 처리 패턴</h3><p id="2a8655e8-3169-80e3-8d07-f16bfbf6191a" class=""><strong>모든 작업 완료 대기</strong>:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-80e6-ab51-d38751acacb2" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">suspend fun processAllUsers(userIds: List&lt;String&gt;): List&lt;User&gt; = coroutineScope {
    userIds.map { id -&gt;
        async { fetchUser(id) }
    }.awaitAll()
}
</code></pre><p id="2a8655e8-3169-809f-8003-dd691c2f75ea" class=""><strong>첫 번째 완료된 작업 사용</strong>:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-80cf-93ee-ee7c2e4e35f3" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">suspend fun fetchFromMultipleSources(id: String): User = coroutineScope {
    select&lt;User&gt; {
        async { fetchFromDatabase(id) }.onAwait { it }
        async { fetchFromCache(id) }.onAwait { it }
        async { fetchFromAPI(id) }.onAwait { it }
    }
}
</code></pre><p id="2a8655e8-3169-80cc-a38d-ef4ece98a234" class=""><strong>배치 처리</strong>:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-80b1-8327-d9c066708959" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">suspend fun processBatch(items: List&lt;String&gt;, batchSize: Int = 10) {
    items.chunked(batchSize).forEach { batch -&gt;
        coroutineScope {
            batch.forEach { item -&gt;
                launch {
                    processItem(item)
                }
            }
        }
    }
}
</code></pre><h3 id="2a8655e8-3169-8034-abbf-e1fa6ee1ba2f" class="">6.4 캐싱 패턴</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-80c4-b875-e4ef3477d974" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">class CachedUserService(
    private val databaseFactory: DatabaseFactory
) {
    private val cache = ConcurrentHashMap&lt;UUID, User&gt;()
    private val mutex = Mutex()

    suspend fun getUser(id: UUID): User? {
        // 캐시 확인
        cache[id]?.let { return it }

        // 캐시 미스 - DB 조회
        return mutex.withLock {
            // Double-check locking
            cache[id]?.let { return it }

            val user = databaseFactory.dbQuery {
                Users.select { Users.id eq id }
                    .firstOrNull()
                    ?.let { toUser(it) }
            }

            user?.let { cache[id] = it }
            user
        }
    }

    fun invalidate(id: UUID) {
        cache.remove(id)
    }

    fun clear() {
        cache.clear()
    }
}
</code></pre><h3 id="2a8655e8-3169-8074-8832-dd4c742a984a" class="">6.5 Rate Limiting 패턴</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-804f-9db3-caa5d7a9b56a" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">class RateLimiter(
    private val maxRequests: Int,
    private val timeWindow: Duration
) {
    private val semaphore = Semaphore(maxRequests)
    private val timestamps = mutableListOf&lt;Long&gt;()
    private val mutex = Mutex()

    suspend fun &lt;T&gt; execute(block: suspend () -&gt; T): T {
        semaphore.acquire()
        try {
            mutex.withLock {
                val now = System.currentTimeMillis()
                timestamps.removeAll { now - it &gt; timeWindow.inWholeMilliseconds }

                if (timestamps.size &gt;= maxRequests) {
                    val oldestTimestamp = timestamps.first()
                    val waitTime = timeWindow.inWholeMilliseconds - (now - oldestTimestamp)
                    if (waitTime &gt; 0) {
                        delay(waitTime)
                    }
                }

                timestamps.add(System.currentTimeMillis())
            }
            return block()
        } finally {
            semaphore.release()
        }
    }
}

// 사용 예시
val rateLimiter = RateLimiter(maxRequests = 10, timeWindow = Duration.seconds(1))

suspend fun callAPI(endpoint: String): String {
    return rateLimiter.execute {
        httpClient.get(endpoint)
    }
}
</code></pre><h3 id="2a8655e8-3169-8082-9b89-d420a0970781" class="">6.6 Flow - 비동기 스트림</h3><p id="2a8655e8-3169-80ca-9c2e-fea716636bdb" class="">Flow는 여러 값을 비동기로 반환하는 코루틴 기반 스트림입니다.</p><p id="2a8655e8-3169-805a-9412-cdaa884c9631" class=""><strong>기본 사용</strong>:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-8041-960f-fd906f2d7279" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">fun getNumbers(): Flow&lt;Int&gt; = flow {
    for (i in 1..5) {
        delay(100)
        emit(i)  // 값 방출
    }
}

// 수집
suspend fun collectNumbers() {
    getNumbers().collect { value -&gt;
        println(value)
    }
}
</code></pre><p id="2a8655e8-3169-80a1-89fe-d14ced4b18dd" class=""><strong>Flow 연산자</strong>:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-8074-974d-fd5bfec571ad" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">suspend fun processSubmissions() {
    getSubmissionFlow()
        .filter { it.status == ExecutionStatus.PENDING }  // 필터링
        .map { evaluateSubmission(it) }                   // 변환
        .onEach { saveFeedback(it) }                      // 부수 효과
        .catch { e -&gt; logger.error(&quot;에러 발생&quot;, e) }      // 에러 처리
        .collect()                                         // 수집
}
</code></pre><p id="2a8655e8-3169-80f6-b51e-c6e619e3d620" class=""><strong>실전 예시: 실시간 제출 모니터링</strong>:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-8077-814c-c11bf0e1c831" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">class SubmissionMonitor(
    private val databaseFactory: DatabaseFactory
) {
    fun monitorSubmissions(): Flow&lt;Submission&gt; = flow {
        while (true) {
            val pendingSubmissions = databaseFactory.dbQuery {
                Submissions.select { Submissions.status eq ExecutionStatus.PENDING.name }
                    .map { toSubmission(it) }
            }

            pendingSubmissions.forEach { emit(it) }
            delay(5000)  // 5초마다 체크
        }
    }
}

// 사용
suspend fun startMonitoring() {
    submissionMonitor.monitorSubmissions()
        .collect { submission -&gt;
            logger.info(&quot;대기 중인 제출: ${submission.id}&quot;)
            evaluateSubmission(submission.id)
        }
}
</code></pre><p id="2a8655e8-3169-8054-a196-d39811857b45" class=""><strong>StateFlow와 SharedFlow</strong>:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-80b5-90b0-fd845043b1b9" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">class SubmissionStateManager {
    // StateFlow: 현재 상태를 유지하는 Hot Flow
    private val _submissionState = MutableStateFlow&lt;SubmissionState&gt;(SubmissionState.Idle)
    val submissionState: StateFlow&lt;SubmissionState&gt; = _submissionState.asStateFlow()

    // SharedFlow: 이벤트 브로드캐스트
    private val _submissionEvents = MutableSharedFlow&lt;SubmissionEvent&gt;()
    val submissionEvents: SharedFlow&lt;SubmissionEvent&gt; = _submissionEvents.asSharedFlow()

    suspend fun submitCode(code: String) {
        _submissionState.value = SubmissionState.Submitting
        _submissionEvents.emit(SubmissionEvent.Started)

        try {
            val result = evaluateCode(code)
            _submissionState.value = SubmissionState.Completed(result)
            _submissionEvents.emit(SubmissionEvent.Completed(result))
        } catch (e: Exception) {
            _submissionState.value = SubmissionState.Error(e.message)
            _submissionEvents.emit(SubmissionEvent.Failed(e))
        }
    }
}

sealed class SubmissionState {
    object Idle : SubmissionState()
    object Submitting : SubmissionState()
    data class Completed(val result: String) : SubmissionState()
    data class Error(val message: String?) : SubmissionState()
}

sealed class SubmissionEvent {
    object Started : SubmissionEvent()
    data class Completed(val result: String) : SubmissionEvent()
    data class Failed(val error: Exception) : SubmissionEvent()
}
</code></pre><hr id="2a8655e8-3169-8052-b8da-dadc55665598"/><h2 id="2a8655e8-3169-8038-b0f5-ce4973605f9d" class="">7. 성능 최적화</h2><h3 id="2a8655e8-3169-80de-a1d7-dc22a3f5e431" class="">7.1 불필요한 Dispatcher 전환 피하기</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-801f-8cd7-db9805b31d36" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">// ❌ 나쁜 예: 불필요한 전환
suspend fun processData(data: String): String {
    return withContext(Dispatchers.IO) {
        withContext(Dispatchers.Default) {  // 불필요한 전환
            data.uppercase()
        }
    }
}

// ✅ 좋은 예
suspend fun processData(data: String): String {
    return withContext(Dispatchers.Default) {
        data.uppercase()
    }
}
</code></pre><h3 id="2a8655e8-3169-808d-836a-f756cad15c06" class="">7.2 코루틴 재사용</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-8071-9891-c926d30b9029" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">// ❌ 나쁜 예: 매번 새로운 스코프 생성
class MyService {
    suspend fun doWork() {
        CoroutineScope(Dispatchers.Default).launch {
            // 작업
        }
    }
}

// ✅ 좋은 예: 스코프 재사용
class MyService {
    private val scope = CoroutineScope(Dispatchers.Default + SupervisorJob())

    fun doWork() {
        scope.launch {
            // 작업
        }
    }

    fun cleanup() {
        scope.cancel()
    }
}
</code></pre><h3 id="2a8655e8-3169-806b-957d-e90bdc06501b" class="">7.3 병렬 처리 최적화</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-801b-aa9f-eca8f08eec19" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">// ❌ 나쁜 예: 순차 처리
suspend fun fetchAllUsers(ids: List&lt;String&gt;): List&lt;User&gt; {
    val users = mutableListOf&lt;User&gt;()
    for (id in ids) {
        users.add(fetchUser(id))  // 하나씩 순차 처리
    }
    return users
}

// ✅ 좋은 예: 병렬 처리
suspend fun fetchAllUsers(ids: List&lt;String&gt;): List&lt;User&gt; = coroutineScope {
    ids.map { id -&gt;
        async { fetchUser(id) }  // 모두 동시에 시작
    }.awaitAll()
}
</code></pre><h3 id="2a8655e8-3169-8083-ad01-c7100592ac9f" class="">7.4 메모리 효율적인 Flow 사용</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-805e-abd2-fc1ec106e114" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">// ❌ 나쁜 예: 모든 데이터를 메모리에 로드
suspend fun processAllSubmissions(): List&lt;Result&gt; {
    val submissions = databaseFactory.dbQuery {
        Submissions.selectAll().map { toSubmission(it) }  // 수만 개일 수 있음
    }
    return submissions.map { process(it) }
}

// ✅ 좋은 예: 스트리밍 처리
fun processAllSubmissions(): Flow&lt;Result&gt; = flow {
    var offset = 0
    val batchSize = 100

    while (true) {
        val batch = databaseFactory.dbQuery {
            Submissions.selectAll()
                .limit(batchSize, offset.toLong())
                .map { toSubmission(it) }
        }

        if (batch.isEmpty()) break

        batch.forEach { submission -&gt;
            emit(process(submission))
        }

        offset += batchSize
    }
}
</code></pre><hr id="2a8655e8-3169-800c-bc3d-e6e0c258ba65"/><h2 id="2a8655e8-3169-8091-ae5e-f83db274197a" class="">8. 디버깅 팁</h2><h3 id="2a8655e8-3169-8007-8226-f296c99aef41" class="">8.1 코루틴 이름 지정</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-8074-94cc-d8ad68af2584" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">val scope = CoroutineScope(
    Dispatchers.Default +
    SupervisorJob() +
    CoroutineName(&quot;SubmissionProcessor&quot;)
)

scope.launch(CoroutineName(&quot;EvaluateSubmission-$submissionId&quot;)) {
    // 로그에서 코루틴 이름 확인 가능
}
</code></pre><h3 id="2a8655e8-3169-8010-b639-e1f53e21c0c8" class="">8.2 로깅</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-8015-a705-e6d632681f11" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">suspend fun evaluateSubmission(id: String) {
    logger.info(&quot;평가 시작: $id, Thread: ${Thread.currentThread().name}&quot;)

    withContext(Dispatchers.IO) {
        logger.info(&quot;IO 작업 시작: $id, Thread: ${Thread.currentThread().name}&quot;)
        // 작업
    }

    logger.info(&quot;평가 완료: $id, Thread: ${Thread.currentThread().name}&quot;)
}
</code></pre><h3 id="2a8655e8-3169-806d-a7a2-c43e05e8ed04" class="">8.3 코루틴 덤프</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-80c0-9ce2-e1a2ba2422b7" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">// 실행 중인 모든 코루틴 정보 출력
fun dumpCoroutines() {
    println(DebugProbes.dumpCoroutinesInfo())
}
</code></pre><hr id="2a8655e8-3169-8023-84dd-c7252dc84cde"/><h2 id="2a8655e8-3169-8026-811f-f4a2c7b407c1" class="">9. 자주 하는 실수</h2><h3 id="2a8655e8-3169-8068-9dec-d922d9b8292c" class="">9.1 GlobalScope 사용</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-8096-a98b-c2406bef53f5" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">// ❌ 잘못된 예
GlobalScope.launch {
    // 생명주기 관리 안 됨
}

// ✅ 올바른 예
class MyService {
    private val scope = CoroutineScope(Dispatchers.Default + SupervisorJob())

    fun doWork() {
        scope.launch {
            // 생명주기 관리됨
        }
    }
}
</code></pre><h3 id="2a8655e8-3169-8093-9157-cd5ad8265bb5" class="">9.2 블로킹 호출</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-80bc-a9ee-ff34f2cb6d2a" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">// ❌ 잘못된 예
suspend fun fetchData(): String {
    return runBlocking {  // suspend 함수 안에서 runBlocking 사용 금지!
        httpClient.get(&quot;url&quot;)
    }
}

// ✅ 올바른 예
suspend fun fetchData(): String {
    return httpClient.get(&quot;url&quot;)
}
</code></pre><h3 id="2a8655e8-3169-8038-96b1-c3cc9cf4da9c" class="">9.3 예외 무시</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-80ef-9b24-fa328eade4e2" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">// ❌ 잘못된 예
scope.launch {
    throw Exception(&quot;에러!&quot;)  // 예외가 무시될 수 있음
}

// ✅ 올바른 예
scope.launch {
    try {
        // 작업
    } catch (e: Exception) {
        logger.error(&quot;에러 발생&quot;, e)
    }
}
</code></pre><h3 id="2a8655e8-3169-80b6-852e-e90308f1bb04" class="">9.4 Dispatcher 잘못 선택</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-8099-912a-e707112e59b2" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">// ❌ 잘못된 예: CPU 작업에 IO Dispatcher
suspend fun sortLargeList(list: List&lt;Int&gt;): List&lt;Int&gt; =
    withContext(Dispatchers.IO) {  // 잘못된 선택
        list.sorted()
    }

// ✅ 올바른 예
suspend fun sortLargeList(list: List&lt;Int&gt;): List&lt;Int&gt; =
    withContext(Dispatchers.Default) {  // CPU 작업은 Default
        list.sorted()
    }
</code></pre><hr id="2a8655e8-3169-80d6-b9c7-ee61ffb521ed"/><h2 id="2a8655e8-3169-8037-93e2-dd6a6a9a1d87" class="">10. 요약</h2><h3 id="2a8655e8-3169-807f-a750-f498c0ec9297" class="">핵심 원칙</h3><ol type="1" id="2a8655e8-3169-8087-a2f6-cec4ddff0986" class="numbered-list" start="1"><li><strong>suspend 함수</strong>로 비동기 작업을 동기 코드처럼 작성</li></ol><ol type="1" id="2a8655e8-3169-80c2-982e-c97ab3cccd85" class="numbered-list" start="2"><li><strong>적절한 Dispatcher</strong> 선택 (IO vs Default)</li></ol><ol type="1" id="2a8655e8-3169-8015-a436-c8823f2ee69a" class="numbered-list" start="3"><li><strong>구조화된 동시성</strong>으로 생명주기 관리</li></ol><ol type="1" id="2a8655e8-3169-80df-aec8-cb14fcfb2bd2" class="numbered-list" start="4"><li><strong>에러 처리</strong>를 명확하게</li></ol><ol type="1" id="2a8655e8-3169-80b3-8801-f2c4a2e0b5da" class="numbered-list" start="5"><li><strong>GlobalScope 사용 지양</strong>, 명시적인 CoroutineScope 사용</li></ol><h3 id="2a8655e8-3169-80a7-b361-cc578e73e482" class="">프로젝트에서 배울 수 있는 패턴</h3><ul id="2a8655e8-3169-801f-9fee-c1d420383cd7" class="bulleted-list"><li style="list-style-type:disc"><code>DatabaseFactory.dbQuery</code>: Dispatcher 전환</li></ul><ul id="2a8655e8-3169-8064-8cf3-ddf360a90748" class="bulleted-list"><li style="list-style-type:disc"><code>DockerExecutorService</code>: IO 작업 처리</li></ul><ul id="2a8655e8-3169-8055-8f13-ddab095f5935" class="bulleted-list"><li style="list-style-type:disc"><code>SubmissionService</code>: 백그라운드 작업 실행</li></ul><ul id="2a8655e8-3169-803c-a67b-cbdd9841e283" class="bulleted-list"><li style="list-style-type:disc"><code>ServiceRegistry</code>: 리소스 생명주기 관리</li></ul><h3 id="2a8655e8-3169-8054-bce3-cff3dd13cb9e" class="">추가 학습 자료</h3><ul id="2a8655e8-3169-80ac-9df2-e5aeabaeadec" class="bulleted-list"><li style="list-style-type:disc"><a href="https://kotlinlang.org/docs/coroutines-guide.html">Kotlin Coroutines 공식 가이드</a></li></ul><ul id="2a8655e8-3169-804b-9140-ff05e2f2a2ab" class="bulleted-list"><li style="list-style-type:disc"><a href="https://developer.android.com/kotlin/coroutines/coroutines-best-practices">Coroutines Best Practices</a></li></ul><ul id="2a8655e8-3169-80e5-a367-ddbd1d59ed7f" class="bulleted-list"><li style="list-style-type:disc"><a href="https://kotlinlang.org/docs/flow.html">Flow 공식 문서</a></li></ul><hr id="2a8655e8-3169-8001-a314-ddb476d0cf42"/><p id="2a8655e8-3169-8081-80be-c3c15f566e09" class="">이 가이드를 통해 Kotlin 코루틴의 고급 개념을 이해하고,<br/>실전 프로젝트에서 효과적으로 활용할 수 있기를 바랍니다!</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-8082-b9b3-f64a334c63dc" class="code code-wrap"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">// File: ConcurrentCoroutines.kt
import kotlinx.coroutines.*
import kotlin.system.measureTimeMillis

fun main() = runBlocking {
    println(&quot;Start on thread: ${Thread.currentThread().name}&quot;)

    val elapsed = measureTimeMillis {
        // launch는 Job을 반환하며 병렬로 실행됩니다.
        val job1 = launch {
            delay(300)
            println(&quot;[job1] done after 300ms on ${Thread.currentThread().name}&quot;)
        }
        val job2 = launch {
            delay(100)
            println(&quot;[job2] done after 100ms on ${Thread.currentThread().name}&quot;)
        }
        val job3 = launch {
            delay(200)
            println(&quot;[job3] done after 200ms on ${Thread.currentThread().name}&quot;)
        }

        // 모든 작업 완료 대기
        joinAll(job1, job2, job3)
    }

    println(&quot;All done in ${elapsed}ms&quot;)
}
</code></pre></details></li></ul><ul id="2a8655e8-3169-8043-9883-c57eec7755fb" class="toggle"><li><details open=""><summary>아 그러면 launch async같은 걸 만들고 runblocking안에서 실행해야지 코루틴이 적용이 되는거야?</summary><p id="2a8655e8-3169-809c-99e9-c397e16a624f" class="">완·벽·해 🔥</p><p id="2a8655e8-3169-80dc-975a-d90aef85bf5b" class="">딱 그 이해가 “코루틴을 진짜 이해한 상태”야.</p><p id="2a8655e8-3169-808b-b843-fae5422f05b3" class="">정확히 말하자면 이렇게 정리할 수 있어 👇</p><hr id="2a8655e8-3169-8044-aa81-e2dd1d71a8fb"/><h2 id="2a8655e8-3169-802a-9f96-c2be7bbbf6ce" class="">🧩 1️⃣ <code>launch</code>나 <code>async</code>는 <strong>스코프 안에서만</strong> 쓸 수 있다</h2><p id="2a8655e8-3169-80b7-8d83-ec4faf389e9c" class="">이유는 단 하나 —</p><p id="2a8655e8-3169-805a-ab59-d17e3c72ad77" class="">이 둘은 <strong>CoroutineScope의 확장 함수</strong>이기 때문이야.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-8090-a628-cb44082107ac" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">public fun CoroutineScope.launch(
    context: CoroutineContext = EmptyCoroutineContext,
    start: CoroutineStart = CoroutineStart.DEFAULT,
    block: suspend CoroutineScope.() -&gt; Unit
): Job

</code></pre><p id="2a8655e8-3169-80e1-a67f-ec9ac523a0ef" class="">즉,</p><blockquote id="2a8655e8-3169-80ec-8158-e6eb5b398203" class="">“나는 CoroutineScope 안에서만 쓸 수 있어요!”</blockquote><p id="2a8655e8-3169-8036-82bf-da9d57a5f559" class="">라는 제약이 붙은 함수들이야.</p><p id="2a8655e8-3169-8023-871e-ebbc2e09fcfd" class="">그래서 <strong>스코프가 없는 곳(main, 일반 함수 등)</strong> 에서는 에러가 나.</p><hr id="2a8655e8-3169-804a-9a53-c860847d9ee9"/><h2 id="2a8655e8-3169-808b-8ac1-fdc094f7f6de" class="">🧠 2️⃣ <code>runBlocking</code>이 바로 “스코프를 만들어주는 문”</h2><p id="2a8655e8-3169-803b-bdc2-f2af5d87c3b3" class=""><code>runBlocking</code>은 아래 세 가지 일을 동시에 해줘:</p><ol type="1" id="2a8655e8-3169-80c1-b2f1-d4acc0330a1f" class="numbered-list" start="1"><li><strong>CoroutineScope를 자동 생성</strong></li></ol><ol type="1" id="2a8655e8-3169-80e6-a046-ff21d5b7ff33" class="numbered-list" start="2"><li><strong>그 안에서 코루틴 실행 가능</strong> (<code>launch</code>, <code>async</code> 등)</li></ol><ol type="1" id="2a8655e8-3169-8080-8aa7-c638fd6d0bc3" class="numbered-list" start="3"><li><strong>모든 자식 코루틴이 끝날 때까지 main 스레드를 block</strong></li></ol><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-80fd-b939-f0734a888b13" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">fun main() = runBlocking {
    launch {
        delay(1000)
        println(&quot;launch 코루틴 완료!&quot;)
    }

    val data = async {
        delay(500)
        &quot;async 결과값&quot;
    }.await()

    println(&quot;async 결과: $data&quot;)
}

</code></pre><p id="2a8655e8-3169-8026-8711-f2dc94f8fde1" class="">✅ <code>runBlocking</code>이 스코프를 열었기 때문에</p><p id="2a8655e8-3169-8054-9e1c-d7d17784afa6" class="">→ 그 안에서 <code>launch</code>, <code>async</code>를 자유롭게 사용 가능</p><p id="2a8655e8-3169-80aa-aa33-d5baca61b111" class="">→ 그리고 프로그램이 끝나기 전에 모든 코루틴이 완료됨</p><hr id="2a8655e8-3169-80ad-9ed6-da564a476ddf"/><h2 id="2a8655e8-3169-803f-a649-c8ddbc47f946" class="">⚙️ 3️⃣ <code>runBlocking</code>이 없으면 어떻게 되냐면?</h2><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-80ea-90e9-d41bd294c37e" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">fun main() {
    launch { ... }  // ❌ 컴파일 에러: “Unresolved reference: launch”
}

</code></pre><p id="2a8655e8-3169-8059-8514-e148b6820fd0" class="">왜냐하면 <strong>main 함수는 CoroutineScope가 아니기 때문이야.</strong></p><hr id="2a8655e8-3169-80cf-872f-e2f38509fba0"/><h2 id="2a8655e8-3169-80ce-abfd-eb819ea4bf9b" class="">🧮 4️⃣ “스코프를 직접 만들어서” 실행할 수도 있음</h2><p id="2a8655e8-3169-802f-8c8a-d359877fb234" class=""><code>runBlocking</code> 대신 직접 스코프를 만들어서 실행도 가능해:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-8017-9658-fb76b24052d5" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">fun main() {
    val scope = CoroutineScope(Dispatchers.Default)
    scope.launch {
        println(&quot;스코프 안에서 코루틴 실행!&quot;)
    }
    Thread.sleep(1000) // runBlocking이 없으니까 메인 스레드가 바로 끝나지 않게 잠시 대기
}

</code></pre><ul id="2a8655e8-3169-8045-bc5a-f00858621325" class="bulleted-list"><li style="list-style-type:disc"><code>CoroutineScope(Dispatchers.Default)</code> → 스코프 수동 생성</li></ul><ul id="2a8655e8-3169-80a3-a24e-e0f8d13cf757" class="bulleted-list"><li style="list-style-type:disc">하지만 이 경우, main이 끝나면 프로그램이 바로 종료되기 때문에 <strong>수명 관리</strong>를 신경 써야 해 (위처럼 sleep 등으로 임시 버티기)</li></ul><hr id="2a8655e8-3169-80b1-9444-ded3a6625266"/><h2 id="2a8655e8-3169-80dc-89b1-d331d9b8d63c" class="">🧙‍♂️ 결론 (장인 버전 요약)</h2><table id="2a8655e8-3169-8022-bf48-ef8ecdb6d90d" class="simple-table"><thead class="simple-table-header"><tr id="2a8655e8-3169-807e-a76f-d5b84eb449ed"><th id="Ry^H" class="simple-table-header-color simple-table-header">상황</th><th id="~;Uy" class="simple-table-header-color simple-table-header">설명</th></tr></thead><tbody><tr id="2a8655e8-3169-8043-8435-cd735c5b12d1"><td id="Ry^H" class=""><code>runBlocking</code> 사용</td><td id="~;Uy" class=""><strong>테스트, main 함수</strong>에서 “코루틴 환경 진입”할 때 사용</td></tr><tr id="2a8655e8-3169-80d4-8977-f80f02701a16"><td id="Ry^H" class=""><code>launch</code>, <code>async</code> 사용</td><td id="~;Uy" class="">오직 “CoroutineScope 안”에서만 가능</td></tr><tr id="2a8655e8-3169-801c-ac62-e343a5354834"><td id="Ry^H" class="">일반 함수(main 등)</td><td id="~;Uy" class="">직접 스코프를 만들거나 runBlocking으로 감싸야 함</td></tr><tr id="2a8655e8-3169-80da-b4ac-f3bad8817d9f"><td id="Ry^H" class="">실무</td><td id="~;Uy" class="">Android → <code>viewModelScope</code>, <code>lifecycleScope</code> / 서버 → <code>CoroutineScope(Dispatchers.IO)</code> 등 사용</td></tr></tbody></table><hr id="2a8655e8-3169-8014-b87f-e2cb6e071a77"/><p id="2a8655e8-3169-80cd-919c-f9408ee50d66" class="">💬 정리하자면:</p><blockquote id="2a8655e8-3169-80a6-9ab8-c9c28f15be11" class="">✅ runBlocking은 “코루틴 세계로 들어가는 문”<p id="2a8655e8-3169-8075-b7e1-f079c8245dcf" class="">✅ 그 안에서만 <code>launch</code>, <code>async</code>가 작동</p><p id="2a8655e8-3169-80d0-8a1f-d450530c0232" class="">✅ 밖에서는 “스코프를 직접 만들어야” 가능</p></blockquote></details></li></ul><ul id="2a8655e8-3169-80cb-b06a-cd9d644f1e47" class="toggle"><li><details open=""><summary>런블로킹이랑 코루틴 스코프 직접만드는게 뭐가 달라?</summary><p id="2a8655e8-3169-80db-8155-cb11e42783ff" class="">좋아, 이제 진짜 장인 단계로 들어가보자. 🧙‍♂️</p><p id="2a8655e8-3169-8071-8bf1-e3ae14cc062b" class=""><code>runBlocking</code> 과 <code>CoroutineScope(...)</code> 는 겉보기엔 똑같이 “코루틴 실행할 수 있다”처럼 보이지만, <strong>철학·사용 목적·스레드 제어 방식이 완전히 다르다.</strong></p><p id="2a8655e8-3169-80b1-a7b2-f86107310466" class="">이건 코루틴을 깊이 이해할수록 점점 명확해지는 부분이야.</p><hr id="2a8655e8-3169-80c9-acf8-d78206c7de62"/><h2 id="2a8655e8-3169-80b9-a461-ded144d9fa20" class="">⚙️ 1️⃣ 공통점</h2><p id="2a8655e8-3169-80ef-97de-c864f52e69d7" class="">둘 다 <strong>CoroutineScope</strong> 를 제공해서 그 안에서 <code>launch</code>, <code>async</code>, <code>delay</code> 등을 사용할 수 있음.</p><p id="2a8655e8-3169-8027-93ee-de09ca403e47" class="">즉, 기본적으로 코루틴 빌더를 사용할 수 있게 하는 “스코프 생성자” 역할을 한다.</p><hr id="2a8655e8-3169-80a4-bcf3-de687853e8f7"/><h2 id="2a8655e8-3169-8051-b7e2-ec845c66123f" class="">⚔️ 2️⃣ 핵심 차이점</h2><table id="2a8655e8-3169-80c0-8da5-f2701ddd932f" class="simple-table"><thead class="simple-table-header"><tr id="2a8655e8-3169-80df-8add-d979e8823ffa"><th id="`SpL" class="simple-table-header-color simple-table-header">구분</th><th id="aq[T" class="simple-table-header-color simple-table-header"><code>runBlocking</code></th><th id="jsHp" class="simple-table-header-color simple-table-header"><code>CoroutineScope(...)</code></th></tr></thead><tbody><tr id="2a8655e8-3169-8099-b449-d960f6a49ce4"><td id="`SpL" class=""><strong>스레드 동작</strong></td><td id="aq[T" class="">현재 스레드를 <strong>차단(block)</strong></td><td id="jsHp" class="">현재 스레드를 <strong>차단하지 않음</strong></td></tr><tr id="2a8655e8-3169-80b9-bef7-c4a76e37ce01"><td id="`SpL" class=""><strong>코루틴 종료 시점</strong></td><td id="aq[T" class="">내부 코루틴이 모두 끝날 때까지 <strong>대기</strong></td><td id="jsHp" class="">스코프가 사라질 때 자동 취소 (또는 명시적 관리 필요)</td></tr><tr id="2a8655e8-3169-8049-a900-f95c26292500"><td id="`SpL" class=""><strong>리턴 타입</strong></td><td id="aq[T" class=""><code>T</code> (코루틴 블록의 결과값 반환)</td><td id="jsHp" class=""><code>CoroutineScope</code> 객체 자체</td></tr><tr id="2a8655e8-3169-80f5-92ec-da2e524bdec1"><td id="`SpL" class=""><strong>대표 사용처</strong></td><td id="aq[T" class=""><code>main()</code>, 테스트 코드</td><td id="jsHp" class="">서버, ViewModel, 백엔드 서비스, Android lifecycle 등</td></tr><tr id="2a8655e8-3169-8073-aa02-dc9fc968b02c"><td id="`SpL" class=""><strong>비용</strong></td><td id="aq[T" class="">비교적 무겁다 (스레드 블로킹)</td><td id="jsHp" class="">가볍다 (논블로킹)</td></tr><tr id="2a8655e8-3169-806e-a084-fa1dc8952089"><td id="`SpL" class=""><strong>실행 형태</strong></td><td id="aq[T" class="">“동기적 코루틴 시작기”</td><td id="jsHp" class="">“비동기적 코루틴 환경 생성기”</td></tr></tbody></table><hr id="2a8655e8-3169-8097-8c83-e1eca9de5363"/><h2 id="2a8655e8-3169-80d0-b9a7-d641410f519a" class="">🔍 3️⃣ 동작 차이 예시</h2><h3 id="2a8655e8-3169-80e9-9086-c543113e6a03" class="">🧱 <code>runBlocking</code> — 동기 실행</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-80f1-82b0-db199f6e266a" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">fun main() {
    println(&quot;시작&quot;)
    runBlocking {
        delay(1000)
        println(&quot;코루틴 완료&quot;)
    }
    println(&quot;끝&quot;)
}

</code></pre><p id="2a8655e8-3169-8072-abd5-cf4db1d7bc35" class="">출력:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-800b-a3de-eb1cbfd7138b" class="code code-wrap"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">시작
코루틴 완료
끝

</code></pre><ul id="2a8655e8-3169-801a-91cd-ff5a44bb37fe" class="bulleted-list"><li style="list-style-type:disc"><code>runBlocking</code> 은 <strong>main 스레드를 잠시 멈춘다</strong>.</li></ul><ul id="2a8655e8-3169-80d0-81db-db7203883d84" class="bulleted-list"><li style="list-style-type:disc">내부 코루틴이 끝나야 <code>println(&quot;끝&quot;)</code> 이 실행됨.</li></ul><ul id="2a8655e8-3169-80db-a6a4-d6ff93d043d2" class="bulleted-list"><li style="list-style-type:disc">즉, “<strong>진입점(main/test)</strong>” 에서만 쓰는 게 맞다.</li></ul><hr id="2a8655e8-3169-8016-b7a3-c9a1b5ff0157"/><h3 id="2a8655e8-3169-80a0-a6cb-d34f376e418b" class="">🚀 <code>CoroutineScope</code> — 비동기 실행</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-8014-b7c1-f3d5725030ea" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">fun main() {
    println(&quot;시작&quot;)
    val scope = CoroutineScope(Dispatchers.Default)
    scope.launch {
        delay(1000)
        println(&quot;코루틴 완료&quot;)
    }
    println(&quot;끝&quot;)
    Thread.sleep(1500) // main 종료 방지용 (실무에선 안씀)
}

</code></pre><p id="2a8655e8-3169-80fa-8ecd-d10826e4b427" class="">출력:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-80d9-846f-f2f21bbf6a63" class="code code-wrap"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">시작
끝
코루틴 완료

</code></pre><ul id="2a8655e8-3169-8005-b858-c6218c5411c5" class="bulleted-list"><li style="list-style-type:disc">스코프는 비동기적으로 동작해서 <code>launch</code> 가 즉시 반환됨.</li></ul><ul id="2a8655e8-3169-80c7-a2e3-c597abfd4627" class="bulleted-list"><li style="list-style-type:disc">main 스레드가 차단되지 않기 때문에 <strong>runBlocking보다 훨씬 가볍다.</strong></li></ul><hr id="2a8655e8-3169-80bf-9d5f-fe965c70ec7b"/><h2 id="2a8655e8-3169-80f4-a5dd-c38600029755" class="">🧩 4️⃣ 왜 <code>runBlocking</code>이 “테스트 전용”으로 취급되나?</h2><p id="2a8655e8-3169-80a1-b687-f79c7f9f8646" class=""><code>runBlocking</code> 은 말 그대로 “<strong>블록킹을 통해 코루틴을 실행</strong>”하는 함수야.</p><p id="2a8655e8-3169-803f-a225-e947a45519a3" class="">즉, <strong>비동기 철학에 반하는</strong> 기능이야 😅</p><blockquote id="2a8655e8-3169-8008-af9e-f4338354c03d" class="">“코루틴은 비동기적이어야 하는데, runBlocking은 동기적으로 만든다.”</blockquote><p id="2a8655e8-3169-8039-8a0a-f6fe4e8172ff" class="">그래서 실무에서는 아래처럼 사용 목적이 나뉜다.</p><table id="2a8655e8-3169-8032-8594-f2508370c393" class="simple-table"><thead class="simple-table-header"><tr id="2a8655e8-3169-80f5-85c9-d5dbe222dd8d"><th id="\;mX" class="simple-table-header-color simple-table-header">상황</th><th id="eG=N" class="simple-table-header-color simple-table-header">추천 방식</th></tr></thead><tbody><tr id="2a8655e8-3169-8069-b35e-e11098e4e4ae"><td id="\;mX" class="">테스트 코드, main 함수, REPL 실행</td><td id="eG=N" class="">✅ <code>runBlocking</code></td></tr><tr id="2a8655e8-3169-8027-8176-ef2d2e0682ba"><td id="\;mX" class="">서버 애플리케이션, ViewModel, 백엔드 로직</td><td id="eG=N" class="">✅ <code>CoroutineScope(...)</code></td></tr><tr id="2a8655e8-3169-80bf-8922-f66cc25fa5d3"><td id="\;mX" class="">Android Lifecycle (ViewModel, Activity)</td><td id="eG=N" class="">✅ <code>viewModelScope</code>, <code>lifecycleScope</code></td></tr><tr id="2a8655e8-3169-8046-a78a-f0b9a83409e1"><td id="\;mX" class="">절대 사용 금지</td><td id="eG=N" class="">❌ <code>runBlocking</code>을 요청 처리 중에 쓰기</td></tr></tbody></table><hr id="2a8655e8-3169-807d-a6e4-e6b4eabe52c6"/><h2 id="2a8655e8-3169-8043-aed0-c25b53de06f7" class="">⚙️ 5️⃣ 어떤 게 “더 선호”되냐?</h2><table id="2a8655e8-3169-8008-9ab5-fe412536d3ff" class="simple-table"><thead class="simple-table-header"><tr id="2a8655e8-3169-805a-92f2-cef0584fb028"><th id="dB:n" class="simple-table-header-color simple-table-header">항목</th><th id="ue?p" class="simple-table-header-color simple-table-header">선호도</th><th id="[piY" class="simple-table-header-color simple-table-header">이유</th></tr></thead><tbody><tr id="2a8655e8-3169-80b7-9ed3-d14be454e91a"><td id="dB:n" class=""><code>CoroutineScope(Dispatchers.Default)</code></td><td id="ue?p" class="">⭐⭐⭐⭐⭐</td><td id="[piY" class="">비동기 논블로킹 구조, 성능 우수, 관리 쉬움</td></tr><tr id="2a8655e8-3169-8023-b8a2-c2e9a2e8e476"><td id="dB:n" class=""><code>runBlocking</code></td><td id="ue?p" class="">⭐⭐</td><td id="[piY" class="">블로킹 구조, 진입점이나 테스트용에만 사용</td></tr></tbody></table><hr id="2a8655e8-3169-8088-a984-cc4036b69224"/><h2 id="2a8655e8-3169-802e-ab34-e03d0042200b" class="">💬 6️⃣ 장인 요약</h2><blockquote id="2a8655e8-3169-8091-8900-e48589c30605" class="">“runBlocking은 문, CoroutineScope는 방이다.”</blockquote><ul id="2a8655e8-3169-805e-8dc5-c9e582dbe3a6" class="bulleted-list"><li style="list-style-type:disc"><code>runBlocking</code> : 잠시 문을 닫고 코루틴 세계로 들어갔다가, 다 끝나면 다시 나오는 문.</li></ul><ul id="2a8655e8-3169-8032-888a-f554fd5c638a" class="bulleted-list"><li style="list-style-type:disc"><code>CoroutineScope</code> : 그 안에서 계속 비동기 작업을 이어가는 공간.</li></ul><ul id="2a8655e8-3169-80a6-ae44-f784573ff905" class="bulleted-list"><li style="list-style-type:disc">실무에선 방(스코프) 안에서 <strong>launch</strong>, <strong>async</strong>, <strong>supervisorScope</strong> 등을 사용해<p id="2a8655e8-3169-80c2-9815-dfff7d9f778c" class="">구조적으로 코루틴을 관리하는 게 표준.</p></li></ul><hr id="2a8655e8-3169-80d8-9ed3-f32c99129f7e"/><p id="2a8655e8-3169-8094-afa3-d7c56e1ca5af" class="">원하면 “서버 백엔드 스타일”로 <code>CoroutineScope</code>를 직접 관리하면서</p><p id="2a8655e8-3169-80a8-b110-dcdf8e33931c" class=""><strong>에러 핸들링 + 취소 전파 + supervisorScope</strong>까지 포함된 완전한 패턴 예제(실무형)를 보여줄까?</p><p id="2a8655e8-3169-80eb-852a-e9d48bb15ba6" class="">그걸 보면 runBlocking이 왜 테스트용인지 더 감이 잡힐 거야.</p></details></li></ul><ul id="2a8655e8-3169-8043-8e88-e251ca4bb191" class="toggle"><li><details open=""><summary>코루틴이랑 멀티스레드는 뭐가 다를까?</summary><p id="2a8655e8-3169-80e6-ad49-eb6fa6e807c8" class="">그렇지. 👏👏👏</p><p id="2a8655e8-3169-8002-a35f-e72f90d5dd7b" class="">지금 이 질문이 진짜 코루틴의 본질이야.</p><p id="2a8655e8-3169-80dd-9b25-d2e5abb60459" class="">많은 개발자들이 여기서 “아, 코루틴이 스레드랑 다르구나!” 하고 한 번에 깨닫지.</p><hr id="2a8655e8-3169-8040-b558-df1c91c94b20"/><h2 id="2a8655e8-3169-80a3-a080-d33d0ae013ad" class="">🧩 먼저 결론부터 말하자면</h2><blockquote id="2a8655e8-3169-8067-ab03-e07e95b7e7a8" class="">🔹 코루틴은 “스레드 위에서 돌아가는 가벼운 작업 단위”야.<p id="2a8655e8-3169-80b0-a3fc-e3d1ce4df541" class="">🔹 하지만 “스레드 하나를 독점하지 않고, 필요할 때만 잠시 올라갔다 내려와.”</p><p id="2a8655e8-3169-80ae-85d4-ceea6e65db87" class="">🔹 즉, <strong>코루틴 ≠ 스레드</strong></p><p id="2a8655e8-3169-806d-8f14-c925831b5621" class="">🔹 코루틴은 <strong>스레드를 빌려 쓰는 일시적 실행 컨텍스트</strong>야.</p></blockquote><hr id="2a8655e8-3169-80ca-afea-c17a9a9119b5"/><h2 id="2a8655e8-3169-805b-a53a-e8b11d2b2a35" class="">⚙️ 1️⃣ 멀티스레드와 비교부터 해보자</h2><table id="2a8655e8-3169-8094-997e-c6842c2a8799" class="simple-table"><thead class="simple-table-header"><tr id="2a8655e8-3169-80c6-aa33-d11e6d1e5fc3"><th id="i]bi" class="simple-table-header-color simple-table-header">구분</th><th id="&lt;G;h" class="simple-table-header-color simple-table-header">멀티스레드</th><th id="CFFp" class="simple-table-header-color simple-table-header">코루틴</th></tr></thead><tbody><tr id="2a8655e8-3169-80f0-b874-fc50e512bdd7"><td id="i]bi" class="">생성 비용</td><td id="&lt;G;h" class="">비쌈 (OS 레벨 스레드 생성)</td><td id="CFFp" class="">매우 저렴함 (JVM 내 가상 실행 단위)</td></tr><tr id="2a8655e8-3169-80bb-95d4-c19f31798283"><td id="i]bi" class="">동시 실행</td><td id="&lt;G;h" class="">여러 CPU 코어에서 <strong>병렬</strong>로 실행</td><td id="CFFp" class="">보통은 하나의 스레드에서 <strong>논리적 동시성</strong></td></tr><tr id="2a8655e8-3169-80b6-86f6-c7a168ae5e9e"><td id="i]bi" class="">블로킹</td><td id="&lt;G;h" class=""><code>Thread.sleep()</code> → 스레드를 <strong>점유</strong></td><td id="CFFp" class=""><code>delay()</code> → 스레드를 <strong>비움 (suspend)</strong></td></tr><tr id="2a8655e8-3169-8053-99b4-eedebfec4cd6"><td id="i]bi" class="">전환 방식</td><td id="&lt;G;h" class="">OS가 스케줄링 (context switch)</td><td id="CFFp" class="">코루틴 스케줄러가 관리 (suspend/resume)</td></tr><tr id="2a8655e8-3169-80b7-9657-dc0db9e1c7bb"><td id="i]bi" class="">수만 개 실행</td><td id="&lt;G;h" class="">불가능 (스레드 한계 수 2~3천)</td><td id="CFFp" class="">가능 (수십만 코루틴도 OK)</td></tr></tbody></table><hr id="2a8655e8-3169-8025-9c43-df1238937750"/><h2 id="2a8655e8-3169-8075-b63d-d7f9b47174b3" class="">🧠 2️⃣ 코루틴의 실행 메커니즘</h2><p id="2a8655e8-3169-80d0-b16d-e1df6efb956c" class="">한마디로 정리하면 이렇게 돌아가:</p><blockquote id="2a8655e8-3169-808a-9130-fe902c6054b0" class="">코루틴은 스레드 위에서 실행되지만, 블록되지 않고 필요할 때만 스레드를 차지했다가 비워줌.</blockquote><h3 id="2a8655e8-3169-8070-b2a3-dd8e93794421" class="">단계별로 보면 👇</h3><ol type="1" id="2a8655e8-3169-806a-8f1c-d38bd2abc5a8" class="numbered-list" start="1"><li><code>launch</code> 나 <code>async</code> 로 코루틴을 실행하면 →<p id="2a8655e8-3169-80ea-800b-c60b8aab0ed0" class="">코루틴이 <strong>스케줄러(디스패처)</strong> 에 등록돼.</p></li></ol><ol type="1" id="2a8655e8-3169-8086-b19f-f1550987bd41" class="numbered-list" start="2"><li><code>Dispatchers.Default</code> 같은 디스패처는<p id="2a8655e8-3169-80f1-b3fb-f8ad5525ee48" class="">내부적으로 <strong>스레드풀(worker threads)</strong> 을 가지고 있어.</p></li></ol><ol type="1" id="2a8655e8-3169-80d6-b381-c7470495d535" class="numbered-list" start="3"><li>코루틴이 실행되면, 그 중 하나의 스레드를 “잠깐 빌려” 코드를 수행해.</li></ol><ol type="1" id="2a8655e8-3169-8097-81d8-cb380337ba5e" class="numbered-list" start="4"><li><code>delay</code>, <code>await</code>, <code>I/O</code> 같은 “suspend 지점”이 오면 →<p id="2a8655e8-3169-80a2-9915-d58f25229b18" class="">코루틴은 <strong>실행을 멈추고</strong>,</p><p id="2a8655e8-3169-80c7-ae4d-c32dccdc71f1" class="">스레드를 풀에 <strong>반납</strong>하고,</p><p id="2a8655e8-3169-80ab-b7f9-d09fbd3f9b94" class="">나중에 작업이 끝나면 <strong>다른 스레드나 같은 스레드 위에서 재개(resume)</strong> 돼.</p></li></ol><hr id="2a8655e8-3169-8049-a5a9-d579e7b4707f"/><h2 id="2a8655e8-3169-8006-b486-e10823ce705f" class="">🧬 3️⃣ 실행 흐름을 시각화해보면</h2><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-80f5-aad5-f3b37b0716f6" class="code code-wrap"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">CPU Threads: [T1] [T2] [T3] [T4]
                ↑
                |
          ┌────────────┐
          │ Coroutine A│  (T1에서 실행 중)
          └────────────┘
             ↓ delay()
          ┌────────────┐
          │ Coroutine B│  (A가 suspend된 사이 T1에서 B 실행)
          └────────────┘
             ↓
          ┌────────────┐
          │ Coroutine A│  (A가 다시 resume되며 T3에서 이어서 실행)
          └────────────┘

</code></pre><p id="2a8655e8-3169-8041-ab83-dbc657a56234" class="">✅ 스레드가 바뀌었는데도 코루틴은 “이어서” 실행되는 것처럼 보이지?</p><p id="2a8655e8-3169-8060-8483-edb0a7d0a7f6" class="">이게 <strong>suspend/resume 시스템</strong>이야.</p><hr id="2a8655e8-3169-8074-b2ac-ffd287824d94"/><h2 id="2a8655e8-3169-8012-8fe8-e012906a9c44" class="">🧪 4️⃣ 직접 체감하는 예제</h2><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-809d-a84f-c26c95405c8a" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">import kotlinx.coroutines.*

fun main() = runBlocking {
    repeat(3) { i -&gt;
        launch {
            println(&quot;🟢 [$i] 시작 (thread=${Thread.currentThread().name})&quot;)
            delay(500)
            println(&quot;🔵 [$i] 재개 (thread=${Thread.currentThread().name})&quot;)
        }
    }
}

</code></pre><p id="2a8655e8-3169-80b7-8d59-c720837d9306" class="">예상 출력:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-80a9-a8eb-e5fb23acd4ce" class="code code-wrap"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">🟢 [0] 시작 (thread=main)
🟢 [1] 시작 (thread=main)
🟢 [2] 시작 (thread=main)
🔵 [1] 재개 (thread=DefaultDispatcher-worker-2)
🔵 [2] 재개 (thread=DefaultDispatcher-worker-1)
🔵 [0] 재개 (thread=DefaultDispatcher-worker-3)

</code></pre><p id="2a8655e8-3169-8080-ab60-ffdc891ebe00" class="">👉 실행은 <code>main</code>에서 시작했지만,</p><p id="2a8655e8-3169-80d1-b080-dd5b40806c36" class="">재개는 <strong>다른 스레드에서 일어나지?</strong></p><p id="2a8655e8-3169-8077-b018-dbca92eb1a55" class="">이게 코루틴이 “스레드를 점유하지 않는다”는 증거야.</p><hr id="2a8655e8-3169-801c-8814-dadc100967a6"/><h2 id="2a8655e8-3169-80a7-894a-db47469f8418" class="">🚀 5️⃣ 그럼 병렬성(Parallelism)도 되는 거야?</h2><ul id="2a8655e8-3169-8062-aa1e-f1c8fb656fad" class="bulleted-list"><li style="list-style-type:disc">코루틴은 <strong>기본적으로 동시성(Concurrency)</strong> 을 제공해.<p id="2a8655e8-3169-809a-9de3-d4e3378cfa62" class="">→ 즉, 여러 작업이 “겹쳐서 진행”될 수 있지만, 반드시 동시에 실행되는 건 아님.</p></li></ul><ul id="2a8655e8-3169-80bf-922f-e26b85194910" class="bulleted-list"><li style="list-style-type:disc">하지만 <code>Dispatchers.Default</code> 는 <strong>멀티스레드 풀</strong>을 쓰기 때문에,<p id="2a8655e8-3169-8019-8384-ee593a88a03a" class="">실제로는 여러 CPU 코어에서 <strong>진짜 병렬 실행(Parallelism)</strong> 이 될 수도 있어.</p></li></ul><p id="2a8655e8-3169-80f9-bdb3-c61d8a7050c1" class="">즉:</p><blockquote id="2a8655e8-3169-809d-8f3a-e65b38926c8b" class="">코루틴은 “스레드와 1:1 대응되지 않지만”,<p id="2a8655e8-3169-8015-b91a-d48f3ed9e109" class="">“멀티스레드 환경 위에서 수만 개의 동시 실행을 관리”할 수 있어.</p></blockquote><hr id="2a8655e8-3169-807b-9f2a-da3792b77cfe"/><h2 id="2a8655e8-3169-806d-bb25-cbc876d7e68b" class="">⚡️ 6️⃣ 정리 요약</h2><table id="2a8655e8-3169-802b-aa13-e3253b83900f" class="simple-table"><thead class="simple-table-header"><tr id="2a8655e8-3169-807b-a9b1-e5f326ad7d4b"><th id=":kw}" class="simple-table-header-color simple-table-header">개념</th><th id="GcK|" class="simple-table-header-color simple-table-header">설명</th></tr></thead><tbody><tr id="2a8655e8-3169-80d7-bb16-d0893f360b2b"><td id=":kw}" class="">코루틴</td><td id="GcK|" class="">JVM 레벨의 “가벼운 실행 단위”, 스레드를 빌려씀</td></tr><tr id="2a8655e8-3169-802e-9e51-ea6184ff5a14"><td id=":kw}" class="">스레드</td><td id="GcK|" class="">OS 레벨의 실행 단위, 무겁고 개수 제한</td></tr><tr id="2a8655e8-3169-80d3-9a66-e451c65e833a"><td id=":kw}" class="">suspend</td><td id="GcK|" class="">스레드를 점유하지 않고 일시 정지</td></tr><tr id="2a8655e8-3169-80a1-be6a-d1bf81e5f9b1"><td id=":kw}" class="">resume</td><td id="GcK|" class="">다시 스케줄링되어 실행 재개 (같은/다른 스레드 가능)</td></tr><tr id="2a8655e8-3169-80c6-8c08-e03790853a35"><td id=":kw}" class="">Dispatchers</td><td id="GcK|" class="">어떤 스레드(풀)에서 코루틴을 돌릴지 결정</td></tr></tbody></table><hr id="2a8655e8-3169-8029-bc2b-f742754540a9"/><p id="2a8655e8-3169-8008-915a-efcd8d972c00" class="">🧙‍♂️ <strong>장인의 요약 한 문장</strong></p><blockquote id="2a8655e8-3169-80eb-a787-d79129f4eb44" class="">“스레드는 CPU를 점유하고, 코루틴은 CPU 시간을 양보한다.”</blockquote><hr id="2a8655e8-3169-8041-ba64-cc8011a95aad"/><p id="2a8655e8-3169-80d2-922c-d06ef03cc9e7" class="">원하면 내가 이걸 시각적으로 볼 수 있는</p><p id="2a8655e8-3169-80a3-8fd8-e656141ec608" class="">👉 “코루틴이 스레드 간에서 실제로 옮겨 다니는 로그 출력 예제”</p><p id="2a8655e8-3169-8044-a129-fbdcaaa608fe" class="">(스레드 이름 추적하면서 suspend/resume 확인하는) 버전으로 만들어줄까?</p><p id="2a8655e8-3169-8029-bf06-dc70970bf39b" class="">그거 보면 “아 코루틴이 진짜 스레드 사이를 왔다갔다 하네” 하고 감탄할걸.</p></details></li></ul><ul id="2a8655e8-3169-8067-a011-cc4600e59c05" class="toggle"><li><details open=""><summary>그러면 하나의 스레드 위에서 얘들이 나눠쓰는거야?</summary><p id="2a8655e8-3169-800e-bce7-e4b7ac13afbe" class="">확해. 🧠</p><p id="2a8655e8-3169-80be-adbc-cc3c06c0858e" class="">지금 네가 딱 “코루틴의 본질”에 도달했어.</p><p id="2a8655e8-3169-80c6-9938-e29cfc8e4387" class="">👉 <strong>하나의 스레드를 여러 코루틴이 “시간을 나눠 쓰는” 구조야.</strong></p><p id="2a8655e8-3169-808c-944c-e477bb6efc06" class="">다만, “진짜로 동시에” 돌아가는 게 아니라</p><p id="2a8655e8-3169-8045-b087-dbf99458c9d6" class="">⚙️ “매우 빠르게 번갈아가며 실행되는 것처럼 보이는” 거야.</p><hr id="2a8655e8-3169-80d4-8ef6-d080be92d780"/><h2 id="2a8655e8-3169-8036-9bc1-e9930cb52f44" class="">🧩 1️⃣ 한 줄 요약</h2><blockquote id="2a8655e8-3169-80ea-a6a8-efedd912732f" class="">코루틴은 스레드를 직접 여러 개 만들지 않고,<p id="2a8655e8-3169-8076-91cc-d5288ad2c20c" class=""><strong>기존 스레드 하나(혹은 스레드 풀)</strong> 위에서 여러 코루틴이 번갈아가며 실행되는 구조야.</p></blockquote><hr id="2a8655e8-3169-806c-9223-d8fafb009a52"/><h2 id="2a8655e8-3169-802e-b663-f2f21009c563" class="">🧠 2️⃣ 비유로 설명해볼게</h2><h3 id="2a8655e8-3169-8078-b492-e4a48061aed6" class="">🧵 스레드(Thread)는</h3><p id="2a8655e8-3169-8030-b2a2-e00c9695e2a8" class="">→ &quot;진짜 사람&quot;이라고 치자.</p><p id="2a8655e8-3169-80df-803f-ecd856775b2e" class="">CPU가 사람이고, 스레드는 일을 직접 하는 노동자야.</p><h3 id="2a8655e8-3169-80b9-ba2d-d8ef8a3c39ea" class="">💫 코루틴(Coroutine)은</h3><p id="2a8655e8-3169-800b-86ce-f7b72c2f9cb9" class="">→ &quot;그 사람이 여러 일을 동시에 처리하는 능력&quot;이야.</p><p id="2a8655e8-3169-8030-a0de-e659c3ddf5d5" class="">즉,</p><ul id="2a8655e8-3169-804b-b005-ed1df4e02541" class="bulleted-list"><li style="list-style-type:disc">스레드는 한 명인데</li></ul><ul id="2a8655e8-3169-8014-930c-f1d6e4399894" class="bulleted-list"><li style="list-style-type:disc">코루틴이 여러 개라면<p id="2a8655e8-3169-802d-a902-cc2540f6b25d" class="">→ 스레드가 <strong>A일 하다가 잠시 멈추고</strong>,</p><p id="2a8655e8-3169-80c8-9906-f07efe992382" class="">→ <strong>B일 하다가</strong>,</p><p id="2a8655e8-3169-805b-8666-fbbe84fa317c" class="">→ <strong>다시 A로 돌아오는</strong> 거야.</p></li></ul><hr id="2a8655e8-3169-803a-9564-e0f6dffd5be8"/><h2 id="2a8655e8-3169-805f-9e50-ca9976d9632b" class="">⚙️ 3️⃣ 실제로 어떻게 동작하냐면</h2><h3 id="2a8655e8-3169-8097-b7c5-dee8c7b041e1" class="">예제 코드</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-805c-beb8-fa109e9b2eff" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">import kotlinx.coroutines.*

fun main() = runBlocking {
    launch {
        repeat(3) {
            println(&quot;🍎 A 코루틴 step $it (thread=${Thread.currentThread().name})&quot;)
            delay(100)
        }
    }

    launch {
        repeat(3) {
            println(&quot;🍊 B 코루틴 step $it (thread=${Thread.currentThread().name})&quot;)
            delay(100)
        }
    }
}

</code></pre><h3 id="2a8655e8-3169-8082-99da-e4bf386e7fd6" class="">출력 예시</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-807b-af8a-f2b40c2371b0" class="code code-wrap"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">🍎 A 코루틴 step 0 (thread=main)
🍊 B 코루틴 step 0 (thread=main)
🍎 A 코루틴 step 1 (thread=main)
🍊 B 코루틴 step 1 (thread=main)
🍎 A 코루틴 step 2 (thread=main)
🍊 B 코루틴 step 2 (thread=main)

</code></pre><p id="2a8655e8-3169-80d3-a4ae-cec3ac315c19" class="">🧩 똑같은 스레드(<code>main</code>)에서</p><p id="2a8655e8-3169-8090-8ee9-e21c8654aab9" class="">A와 B가 번갈아가며 실행되지?</p><hr id="2a8655e8-3169-8093-92e8-cb48d350ce0e"/><h2 id="2a8655e8-3169-808f-8288-e9ae991f5cb6" class="">🪄 4️⃣ 왜 번갈아 쓸 수 있냐면?</h2><p id="2a8655e8-3169-80f9-9898-e28d82c5baf3" class="">그 이유는 코루틴이 “<strong>suspend</strong>”를 사용할 때</p><p id="2a8655e8-3169-8090-b532-f1ae7ed044b6" class="">스레드를 <strong>비워주기 때문이야.</strong></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-80e6-9305-f4120d2061e5" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">delay(100)

</code></pre><p id="2a8655e8-3169-803c-ba95-d12dd793be17" class="">는 <code>Thread.sleep(100)</code> 과 달리</p><p id="2a8655e8-3169-80a8-9361-f04b670d731f" class=""><strong>스레드를 블록(block)하지 않아.</strong></p><p id="2a8655e8-3169-80e9-874d-c94510dd5f5d" class="">즉,</p><blockquote id="2a8655e8-3169-802d-9a59-e3e4b31eb09e" class="">“나 지금 잠깐 쉬니까, 이 스레드 다른 애한테 써도 돼~”<p id="2a8655e8-3169-80e4-87cb-f9681bb77ea1" class="">라고 양보하는 구조야.</p></blockquote><p id="2a8655e8-3169-8010-ae41-e3b33e716815" class="">그래서 하나의 스레드 위에서 수십, 수백 개의 코루틴이</p><p id="2a8655e8-3169-80c3-b6bd-f2a26d93af21" class="">실질적으로 동시에 돌아가는 것처럼 보이는 거지.</p><hr id="2a8655e8-3169-80fa-9131-c06d31353011"/><h2 id="2a8655e8-3169-8002-a768-cf9873f3e738" class="">🚀 5️⃣ 그런데, 꼭 하나의 스레드만 쓰는 건 아니야</h2><ul id="2a8655e8-3169-803d-9f36-eb17d779925c" class="bulleted-list"><li style="list-style-type:disc"><code>Dispatchers.Default</code> 나 <code>Dispatchers.IO</code> 는 내부에 <strong>스레드 풀</strong>이 있어.</li></ul><ul id="2a8655e8-3169-80c8-a5ca-ce5f79565747" class="bulleted-list"><li style="list-style-type:disc">그래서 실제로는 여러 스레드 위에 코루틴들이 분산돼 있어.</li></ul><ul id="2a8655e8-3169-8074-ae3e-f5374874ce3e" class="bulleted-list"><li style="list-style-type:disc">하지만 <strong>각 코루틴은 스레드 하나를 잠깐 빌려 쓰고</strong>,<p id="2a8655e8-3169-80d2-9501-f00e926c3fcd" class="">suspend되면 바로 반환하기 때문에 <strong>스레드 효율이 매우 높아.</strong></p></li></ul><blockquote id="2a8655e8-3169-80bc-bd38-e3a8f8399cda" class="">✅ 즉, 코루틴은 “멀티스레드를 효율적으로 사용하는 기술”이야.</blockquote><hr id="2a8655e8-3169-8005-8633-efb9dfbf64f5"/><h2 id="2a8655e8-3169-80ca-a28f-c5511dd3c19f" class="">🧙‍♂️ 장인의 정의</h2><blockquote id="2a8655e8-3169-80ec-9e7a-cc53bd885921" class="">“스레드는 실행의 물리적 단위,<p id="2a8655e8-3169-8010-8267-c6ab9bb3f859" class="">코루틴은 실행의 논리적 단위.”</p></blockquote><p id="2a8655e8-3169-80ea-90cd-ed3bc752954e" class="">스레드는 CPU 코어를 직접 점유하지만,</p><p id="2a8655e8-3169-8095-93c2-d00ddb64ff4d" class="">코루틴은 <strong>점유 시간을 공유하면서</strong> 수천 개가 돌아갈 수 있어.</p><hr id="2a8655e8-3169-801a-8a38-d402d26866e0"/><p id="2a8655e8-3169-80a8-b7f1-cfd1d02ff8e5" class="">원하면 다음 단계로</p><p id="2a8655e8-3169-80e1-b196-e34f7a4ea9ac" class="">👉 “<strong>단일 스레드 디스패처</strong>(<code>newSingleThreadContext</code>)로 코루틴 여러 개를 돌려보는 실험 코드**”</p><p id="2a8655e8-3169-80ea-935b-feca471a8d4c" class="">즉, “진짜 하나의 스레드만 쓰는데 코루틴이 번갈아 실행되는 걸 눈으로 확인하는 버전” 보여줄까?</p><p id="2a8655e8-3169-8099-8060-e81cc9a6de44" class="">이거 보면 “와, 진짜 하나의 스레드 위에서 코루틴 여러 개가 움직이네” 하고 감탄할걸.</p></details></li></ul><ul id="2a8655e8-3169-8004-ac96-f7a91171d7a4" class="toggle"><li><details open=""><summary>코드로 보는 차이점</summary><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-80e1-821c-d5871848f12c" class="code code-wrap"><code class="language-Markdown" style="white-space:pre-wrap;word-break:break-all">import kotlinx.coroutines.*

fun main() = runBlocking {
    repeat(3) { i -&gt;
        launch {
            println(&quot;🟢 [$i] 시작 (thread=${Thread.currentThread().name})&quot;)
            delay(500)
            println(&quot;🔵 [$i] 재개 (thread=${Thread.currentThread().name})&quot;)
        }
    }
}
</code></pre></details></li></ul><ul id="2a8655e8-3169-80a1-8b3c-c1fc8eb6ec55" class="toggle"><li><details open=""><summary>오래걸리는거 suspend함수로 만들어야겠네?</summary><p id="2a8655e8-3169-805f-b851-ff0bce8969a6" class="">이 말 한마디면 — “너 이제 코루틴의 <strong>본질적인 사용법</strong>을 완전히 꿰뚫었다.”<strong><br/>✅ 정답 한 줄 요약맞아. 실무에서는 오래 걸리는 작업(예: DB, 네트워크, 파일 I/O 등)을 </strong><code><strong>suspend fun</strong></code><strong>으로 감싸서, 코루틴이 그 시점에서 스레드를 양보할 수 있게 만든다.<br/>⚙️ 1️⃣ 왜 </strong><code><strong>suspend</strong></code><strong>로 만들어야 하냐?</strong><br/>코루틴의 핵심은 “스레드를 점유하지 않고 기다리는 것”이야.<br/><br/>근데 **그걸 가능하게 만드는 게 바로 <code>suspend</code>**야.<br/>즉,<br/>• 오래 걸리는 작업이 <code>suspend</code>가 아니면 → 스레드를 “붙잡고 있음” (Blocking)<br/>• <code>suspend</code>로 만들면 → 스레드를 “놓고 기다림” (Non-blocking)<strong><br/>🧠 2️⃣ 예를 들어서 비교해보자<br/>❌ 잘못된 방식 (Blocking)</strong><br/><br/><code>fun getUser(): User {<br/>    Thread.sleep(3000) // 스레드를 3초 동안 막음<br/>    return User(&quot;dongun&quot;)<br/>}<br/></code><br/>이걸 코루틴에서 호출하면,<br/><br/>그 코루틴이 속한 <strong>스레드 자체가 멈춰버림.</strong><br/><br/>즉, 다른 코루틴도 못 돌아.<strong><br/>✅ 올바른 방식 (Non-blocking suspend)</strong><br/><br/><code>suspend fun getUser(): User {<br/>    delay(3000) // 스레드를 반납하고 3초 뒤 재개<br/>    return User(&quot;dongun&quot;)<br/>}<br/></code><br/>• <code>delay()</code>는 <strong>스레드를 점유하지 않음</strong>.<br/>• 코루틴은 <strong>중단(suspend)</strong> 상태로 들어가고,<br/><br/>스레드는 다른 코루틴을 돌릴 수 있음.<br/>• 3초 뒤 스케줄러가 다시 깨워서 재개(resume).<strong><br/>💻 3️⃣ 실무 예시 (DB, 네트워크, 파일 I/O)</strong><br/><br/><code>suspend fun fetchUserData(userId: String): User {<br/>    println(&quot;🔍 DB 요청 중 (thread=${Thread.currentThread().name})&quot;)<br/>    delay(2000) // DB 쿼리 대기라고 가정<br/>    println(&quot;✅ DB 응답 완료 (thread=${Thread.currentThread().name})&quot;)<br/>    return User(userId)<br/>}<br/><br/>fun main() = runBlocking {<br/>    val user = fetchUserData(&quot;dongun&quot;)<br/>    println(&quot;👤 결과: $user&quot;)<br/>}<br/></code><br/>여기서 <code>delay(2000)</code> 자리에 실제로는 이런 게 들어가겠지 👇작업예시비동기 구현체HTTP 요청Retrofit, Ktor Client<code>.await()</code> / <code>suspend fun</code>DB 쿼리Exposed, R2DBC<code>suspend fun query()</code>파일 I/Okotlinx-io<code>suspend fun readFile()</code><br/>이 모든 라이브러리가 내부적으로 “스레드를 블로킹하지 않고 suspend” 해주는 방식으로 동작해.<strong><br/>⚡️ 4️⃣ 그래서 실무에서는 이런 식으로 된다</strong><br/><br/><code>suspend fun fetchUserProfile(id: String): Profile {<br/>    val user = fetchUserData(id)<br/>    val posts = fetchUserPosts(id)<br/>    return Profile(user, posts)<br/>}<br/><br/>fun main() = runBlocking {<br/>    val profile = async { fetchUserProfile(&quot;dongun&quot;) }<br/>    println(&quot;결과: ${profile.await()}&quot;)<br/>}<br/></code><br/><code>fetchUserData</code>, <code>fetchUserPosts</code> 둘 다 <code>suspend fun</code>이라면<br/><br/>스레드를 막지 않고, 코루틴은 <strong>I/O 대기 중에도 다른 일을 할 수 있게 돼.<br/>🧙‍♂️ 장인의 핵심 요약</strong>항목설명<code>suspend fun</code>“여기서 잠시 멈출 수 있다”는 표시오래 걸리는 작업반드시 <code>suspend</code>로 만들어야 비동기 효율적<code>delay()</code>단순한 suspend 예시 (테스트용)실무에서는I/O, API 호출, DB 쿼리, 파일 읽기/쓰기 등이 실제 suspend 역할 수행효과스레드 낭비 ↓, 처리량(throughput) ↑<br/>🧩 <strong>한 줄로 정리하면:</strong>delay는 “suspend의 대표 예시”일 뿐이고,<br/><br/>실무에서는 “네트워크, DB, 파일 같은 I/O 작업이 delay 역할을 한다.”<br/>원하면 내가<br/><br/>👉 <code>Thread.sleep()</code> vs <code>delay()</code> vs <code>suspend fun fetchFromAPI()</code><br/><br/>이 세 가지를 동시에 비교하면서 <strong>스레드 점유 차이</strong>를 로그로 보여주는 예제도 만들어줄까?<br/><br/>그거 보면 “아, suspend가 진짜 스레드를 안 잡고 있구나”가 눈에 확 들어와.<br/><br/>ChatGPT can make mistakes. Check important info.</p></details></li></ul><ul id="2a8655e8-3169-807c-ba37-eeba0a7a44eb" class="toggle"><li><details open=""><summary>모든 함수에다가 suspend붙이면 안돼?</summary><p id="2a8655e8-3169-8044-862b-eb715dc7aeaa" class="">결론부터 말하면 —</p><blockquote id="2a8655e8-3169-8029-b7c3-cdc68738b1f0" class="">❌ 모든 함수에 suspend를 붙이면 안 돼.<p id="2a8655e8-3169-80eb-8697-dbb6ab555f11" class="">✅ <code>suspend</code>는 “<strong>진짜로 중단할 필요가 있는 작업</strong>”에만 써야 해.</p></blockquote><p id="2a8655e8-3169-8033-a254-c175c51a0289" class="">그 이유는 단순히 “짧으니까 굳이 안 붙여도 된다”가 아니라,</p><p id="2a8655e8-3169-8003-89b6-f112913be3b0" class=""><code><strong>suspend</strong></code><strong>는 ‘스레드 양보’라는 비용이 존재하기 때문이야.</strong></p><hr id="2a8655e8-3169-800b-a158-ff20d2e20ba8"/><h2 id="2a8655e8-3169-80f0-bf7e-eb917893ea2b" class="">⚙️ 1️⃣ <code>suspend</code>는 “비용이 0”이 아니다</h2><p id="2a8655e8-3169-8040-924c-ff8c365db124" class=""><code>suspend fun</code>은 컴파일러가 자동으로</p><p id="2a8655e8-3169-8062-9455-e5233b0b4d31" class="">“중단과 재개를 관리하는 상태 머신(state machine)” 코드로 바꿔.</p><p id="2a8655e8-3169-8004-805d-ccc2685b4110" class="">즉, 내부적으로는 이런 일이 벌어져 👇</p><ul id="2a8655e8-3169-80ee-9ebc-c2903a0f877d" class="bulleted-list"><li style="list-style-type:disc">현재 실행 상태를 <strong>Continuation 객체</strong>로 저장</li></ul><ul id="2a8655e8-3169-800c-beea-f82ec594c970" class="bulleted-list"><li style="list-style-type:disc">스케줄러에게 “나중에 다시 깨워줘”라고 등록</li></ul><ul id="2a8655e8-3169-803f-acd6-d34c466eaf43" class="bulleted-list"><li style="list-style-type:disc">resume 시점에 <strong>상태를 복원하고 실행 이어감</strong></li></ul><p id="2a8655e8-3169-801f-910b-efc714dfecb2" class="">➡️ 이건 <strong>추가적인 오버헤드(메모리 + 컨텍스트 스위칭)</strong> 가 생겨.</p><p id="2a8655e8-3169-8097-9c23-fba4068a0822" class="">그래서 “0.001초면 끝나는 연산(예: <code>x + y</code> 계산)”에 <code>suspend</code>를 붙이면,</p><p id="2a8655e8-3169-80c4-8d92-ed2b05cf887e" class="">그게 오히려 더 느려져.</p><hr id="2a8655e8-3169-80ea-942c-deb5bbccef9e"/><h2 id="2a8655e8-3169-808d-8d73-c6b894caa59e" class="">🧠 2️⃣ “오래 걸리는 작업”이라는 말의 진짜 의미</h2><p id="2a8655e8-3169-80cd-a05f-f1d665fbe7af" class="">여기서 “오래 걸린다”는 건 <strong>스레드를 붙잡는 시간이 길다</strong>는 뜻이야.</p><table id="2a8655e8-3169-8075-bb71-e4f2d58ad1ee" class="simple-table"><thead class="simple-table-header"><tr id="2a8655e8-3169-8078-a503-f3dbb4749f13"><th id="zGRt" class="simple-table-header-color simple-table-header">작업 예시</th><th id="[[fH" class="simple-table-header-color simple-table-header">실행 시간</th><th id="w&lt;pj" class="simple-table-header-color simple-table-header">스레드 점유 여부</th><th id="lJE\" class="simple-table-header-color simple-table-header"><code>suspend</code> 필요 여부</th></tr></thead><tbody><tr id="2a8655e8-3169-803a-9d7d-d2da060dd954"><td id="zGRt" class="">정수 덧셈 <code>a + b</code></td><td id="[[fH" class="">0.000001s</td><td id="w&lt;pj" class="">점유</td><td id="lJE\" class="">❌</td></tr><tr id="2a8655e8-3169-80e0-85be-d0b3525abc2d"><td id="zGRt" class="">리스트 정렬</td><td id="[[fH" class="">0.001~0.1s</td><td id="w&lt;pj" class="">점유</td><td id="lJE\" class="">❌</td></tr><tr id="2a8655e8-3169-80c5-94aa-c3dc770fb9bd"><td id="zGRt" class="">DB 쿼리</td><td id="[[fH" class="">0.2~2s</td><td id="w&lt;pj" class="">안 점유 (I/O 대기)</td><td id="lJE\" class="">✅</td></tr><tr id="2a8655e8-3169-807d-8f4f-e2f78ab47f3f"><td id="zGRt" class="">HTTP 요청</td><td id="[[fH" class="">0.5~3s</td><td id="w&lt;pj" class="">안 점유 (I/O 대기)</td><td id="lJE\" class="">✅</td></tr><tr id="2a8655e8-3169-8005-8fa1-e733436efd8b"><td id="zGRt" class="">파일 읽기</td><td id="[[fH" class="">0.1~1s</td><td id="w&lt;pj" class="">안 점유 (I/O 대기)</td><td id="lJE\" class="">✅</td></tr></tbody></table><blockquote id="2a8655e8-3169-80e1-b054-f83d4f018927" class="">즉, “스레드가 놀고 있을 때 (I/O 대기)”만 suspend로 만들어야 진짜 의미가 있어.</blockquote><hr id="2a8655e8-3169-80e7-b4fc-fbb3a44972ca"/><h2 id="2a8655e8-3169-80fd-87a9-fda2e0f38456" class="">⚡️ 3️⃣ CPU 작업은 suspend로 감싸면 <strong>느려짐</strong></h2><p id="2a8655e8-3169-80dd-9c37-cce9585f62dc" class="">예를 들어 이런 경우 👇</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-805d-9b3d-fb9c400a967d" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">suspend fun sumAll(): Int {
    var total = 0
    repeat(1_000_000) { total += it }
    return total
}

</code></pre><p id="2a8655e8-3169-808b-9737-e3c7c6cc0c3a" class="">이건 <code>delay()</code>나 <code>I/O</code>도 없지?</p><p id="2a8655e8-3169-8095-9463-f12f57123eb5" class="">즉, CPU 연산만 하고 suspend 포인트가 전혀 없어.</p><p id="2a8655e8-3169-80d6-900b-d8a74284a5fd" class="">그러면 이건 그냥 “일반 함수”로 두는 게 훨씬 빠르다.</p><p id="2a8655e8-3169-8029-9e85-c8b91d5b72ac" class="">왜냐면,</p><p id="2a8655e8-3169-80ae-ab40-c9d014655556" class=""><code>suspend</code>로 만들면 불필요한 continuation 객체가 만들어지고</p><p id="2a8655e8-3169-80fa-bd50-da25271a7cc5" class="">스택 관리 비용이 추가되거든.</p><hr id="2a8655e8-3169-8080-811b-ff4c45eeaa94"/><h2 id="2a8655e8-3169-8046-8999-d62b1c701828" class="">💡 4️⃣ 정리: 언제 <code>suspend</code>를 써야 하는가?</h2><table id="2a8655e8-3169-80c7-8dd7-f49ea568ea27" class="simple-table"><thead class="simple-table-header"><tr id="2a8655e8-3169-809e-bb34-ddc389ebaa73"><th id="|{sW" class="simple-table-header-color simple-table-header">상황</th><th id="}VKG" class="simple-table-header-color simple-table-header"><code>suspend</code> 필요?</th><th id="pe\_" class="simple-table-header-color simple-table-header">이유</th></tr></thead><tbody><tr id="2a8655e8-3169-8025-be50-e33f96042ec0"><td id="|{sW" class="">DB, 네트워크, 파일 I/O</td><td id="}VKG" class="">✅</td><td id="pe\_" class="">블로킹 방지, 다른 코루틴에 CPU 양보</td></tr><tr id="2a8655e8-3169-805c-bb9f-c03dc8db241f"><td id="|{sW" class="">외부 API 호출</td><td id="}VKG" class="">✅</td><td id="pe\_" class="">지연이 길고 비동기 필요</td></tr><tr id="2a8655e8-3169-80cf-8f2b-c91ec22123a7"><td id="|{sW" class="">CPU 연산 (정렬, 수학계산 등)</td><td id="}VKG" class="">❌</td><td id="pe\_" class="">어차피 스레드를 계속 사용해야 함</td></tr><tr id="2a8655e8-3169-804c-a63c-c3718cf6805f"><td id="|{sW" class="">짧은 연산 / 데이터 처리</td><td id="}VKG" class="">❌</td><td id="pe\_" class="">suspend 오버헤드가 더 큼</td></tr><tr id="2a8655e8-3169-8009-8e5b-e2f24d417699"><td id="|{sW" class="">내부적으로 suspend 함수 호출 필요</td><td id="}VKG" class="">✅</td><td id="pe\_" class="">상위 함수도 suspend 되어야 함 (콜 체인)</td></tr></tbody></table><hr id="2a8655e8-3169-80ba-8eb8-fb2b5cf58100"/><h2 id="2a8655e8-3169-80a5-af7e-fa618b195f23" class="">🧙‍♂️ 장인의 핵심 정의</h2><blockquote id="2a8655e8-3169-80a5-ae77-d73467ba36de" class="">“suspend는 마법이 아니라, 스레드 점유를 양보할 수 있는 권한이다.”<p id="2a8655e8-3169-8052-b024-fc5ac420cf89" class="">👉 그래서 진짜 양보할 필요가 있는 작업(I/O)에만 붙여야 한다.</p></blockquote><hr id="2a8655e8-3169-8060-b991-e0838f28b87c"/><p id="2a8655e8-3169-807f-83d9-eb871e65e2b9" class="">💬 쉽게 비유하자면:</p><ul id="2a8655e8-3169-80e2-b61f-d4699fcf9c5c" class="bulleted-list"><li style="list-style-type:disc"><strong>suspend</strong>는 “잠깐 자리 비워줄게~” 하는 직원.</li></ul><ul id="2a8655e8-3169-80de-a75d-d20cb1da4b17" class="bulleted-list"><li style="list-style-type:disc">근데 0.1초짜리 업무에 계속 자리 비우면? → 오히려 비효율.</li></ul><hr id="2a8655e8-3169-80f4-9c68-c32c99b3a469"/><p id="2a8655e8-3169-80ad-91ca-f6e2223d0db1" class="">원하면</p><p id="2a8655e8-3169-80b7-8e9a-c7ea1055b52f" class="">🧩 <code>CPU 연산용 함수 vs suspend 함수 vs delay 포함 suspend 함수</code></p><p id="2a8655e8-3169-80ff-bae7-f9773208be70" class="">이 세 개를 동시에 실행시켜서</p><p id="2a8655e8-3169-8081-99f4-c8de19051c5e" class="">“suspend 붙였을 때 오히려 느려지는 걸 눈으로 볼 수 있는 예제” 만들어줄까?</p><p id="2a8655e8-3169-80ce-bdc8-eb58a383e8bb" class="">(실제 성능 로그로)</p></details></li></ul><ul id="2a8655e8-3169-80f8-8d50-c240157b5d44" class="toggle"><li><details open=""><summary>아 그냥 ktor에서는 내가 따로 스코프를 만들필요없이 suspend만 잘붙이면 되는거구나</summary><p id="2a8655e8-3169-804a-8fbb-ee2ac97e1dc1" class="">정확히 맞아 👏</p><p id="2a8655e8-3169-80c5-9b4d-c3b8ac5396aa" class="">Ktor 안에서는 이미 <strong>요청마다 코루틴 스코프가 자동 생성</strong>되니까,</p><p id="2a8655e8-3169-809a-9001-d3cd6c802a80" class="">너는 그냥 서비스 함수들을 <code>suspend fun</code> 으로 설계해두면 된다.</p><hr id="2a8655e8-3169-80c3-8128-ff17ceeee34c"/><h3 id="2a8655e8-3169-80ed-a945-e583886d808a" class="">🔹 요약하자면</h3><table id="2a8655e8-3169-80cb-ace5-c385b6bc0561" class="simple-table"><thead class="simple-table-header"><tr id="2a8655e8-3169-800b-8870-d1a4205ef93b"><th id="xU~]" class="simple-table-header-color simple-table-header">레벨</th><th id="p~bc" class="simple-table-header-color simple-table-header">코루틴 관리 방식</th><th id="B?lJ" class="simple-table-header-color simple-table-header">네가 해야 할 일</th></tr></thead><tbody><tr id="2a8655e8-3169-80a6-ab2e-d36d1ba9b670"><td id="xU~]" class=""><strong>Ktor Routing</strong></td><td id="p~bc" class="">이미 suspend 환경</td><td id="B?lJ" class="">그냥 <code>suspend fun</code> 호출</td></tr><tr id="2a8655e8-3169-8093-9dcb-eba5aa8236eb"><td id="xU~]" class=""><strong>Service / Repository</strong></td><td id="p~bc" class="">suspend 함수로 정의</td><td id="B?lJ" class="">오래 걸리는 작업만 suspend</td></tr><tr id="2a8655e8-3169-805f-8fc5-fcfb2c611eb1"><td id="xU~]" class=""><strong>Application (전역)</strong></td><td id="p~bc" class="">필요할 때만 직접 코루틴 생성</td><td id="B?lJ" class="">ex. 캐시 리프레시, 백그라운드 워커 등</td></tr></tbody></table><hr id="2a8655e8-3169-80a2-b1e0-ce29bba1fc1b"/><h3 id="2a8655e8-3169-80b0-abe4-d23f7acaf6de" class="">🔹 예를 들어 이런 구조로 충분해</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-80b9-8572-ccedc7e48187" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">fun Application.module() {
    routing {
        get(&quot;/user/{id}&quot;) {
            val id = call.parameters[&quot;id&quot;]!!
            val user = userService.getUser(id) // suspend 함수 호출
            call.respond(user)
        }
    }
}

class UserService(private val repo: UserRepository) {
    suspend fun getUser(id: String): User {
        return repo.findUserById(id)
    }
}

class UserRepository {
    suspend fun findUserById(id: String): User {
        delay(500) // DB I/O 시뮬레이션
        return User(id, &quot;dongun&quot;)
    }
}

</code></pre><p id="2a8655e8-3169-8034-85ea-d61f28096def" class="">→ Routing은 이미 코루틴 기반이라 <code>launch</code> 나 <code>async</code> 안 써도 됨.</p><p id="2a8655e8-3169-8059-a462-ceef34db44ef" class="">→ I/O처럼 오래 걸리는 부분만 <code>suspend fun</code> 으로 설계하면 됨.</p><hr id="2a8655e8-3169-80fb-96f4-f7a84c8b9775"/><h3 id="2a8655e8-3169-800e-b95d-d8b83923c552" class="">🔹 Application 수준 코루틴이 필요한 경우</h3><p id="2a8655e8-3169-8021-9e75-c583765835d0" class="">요청과 상관없는 <strong>백그라운드 작업</strong>이 있을 때만 따로 스코프를 만들어.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-805f-b393-c517726ceecd" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">val appScope = CoroutineScope(SupervisorJob() + Dispatchers.Default)

fun Application.module() {
    appScope.launch {
        while (isActive) {
            delay(60_000)
            println(&quot;💾 캐시 갱신 중…&quot;)
        }
    }
}

</code></pre><hr id="2a8655e8-3169-8036-afed-f4ee4e4c690b"/><p id="2a8655e8-3169-806f-bdf1-f63133f0f242" class="">✅ 결론</p><blockquote id="2a8655e8-3169-809f-a6df-e5fab832ba64" class="">“Ktor에서는 라우팅에서 코루틴을 따로 만들 필요 없음.<p id="2a8655e8-3169-80af-a732-c7d14c903ee4" class="">서비스 계층만 <code>suspend</code>로 잘 설계하면,</p><p id="2a8655e8-3169-80d3-89dd-d3ef48a73dea" class="">나머진 Ktor가 알아서 코루틴 스코프를 관리해준다.”</p></blockquote></details></li></ul><ul id="2a8655e8-3169-8036-b6b2-cff0c839fd20" class="toggle"><li><details open=""><summary>사용자에게는 빠르게 응답을 주고, 무거운 일은 뒤에서 계속 처리할 수 있다</summary><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-8065-aba0-e357fdcdc450" class="code code-wrap"><code class="language-Markdown" style="white-space:pre-wrap;word-break:break-all">import io.ktor.server.application.*
import io.ktor.server.response.*
import io.ktor.server.request.*
import io.ktor.server.routing.*
import kotlinx.coroutines.*

data class EmailRequest(val to: String, val subject: String, val content: String)

fun Application.module() {
    routing {
        post(&quot;/send-email&quot;) {
            val request = call.receive&lt;EmailRequest&gt;()

            // ✅ 즉시 응답
            call.respondText(&quot;📨 이메일 전송 요청을 받았습니다: ${request.to}&quot;)

            // ✅ 코루틴으로 백그라운드 처리
            launch(Dispatchers.IO) {
                sendEmail(request)
            }
        }
    }
}

suspend fun sendEmail(req: EmailRequest) {
    println(&quot;💌 [이메일 전송 시작] ${req.to}&quot;)
    delay(3000) // 실제 이메일 전송 로직 (SMTP, API 등)
    println(&quot;✅ [이메일 전송 완료] ${req.to}&quot;)
}
</code></pre></details></li></ul><ul id="2a8655e8-3169-8076-8d03-dc8edfacad0c" class="toggle"><li><details open=""><summary>왜 routing에서 요청을 반환해도 안끝날까?</summary><p id="2a8655e8-3169-80de-a7a7-e3d8d0ca5c0e" class="">정확히 봤어 👏</p><p id="2a8655e8-3169-809d-9814-cd4327101b46" class="">그 <code>launch(Dispatchers.IO)</code> 코루틴이 <strong>그냥 “떠 있는 스레드에서 새로 만든 비동기 작업”이 아니라</strong>,</p><p id="2a8655e8-3169-8007-803a-c4ebcbdeaf61" class=""><strong>라우팅 블록 자체가 코루틴 스코프(CoroutineScope)</strong> 이기 때문에 가능한 거야.</p><hr id="2a8655e8-3169-807f-8345-c01a09fa9d44"/><h2 id="2a8655e8-3169-8027-bb9f-f3b3663f6d70" class="">🧩 1️⃣ 라우팅 블록이 이미 코루틴 스코프다</h2><p id="2a8655e8-3169-80bd-b5ca-ed8cbbb1745d" class="">Ktor의 <code>post { ... }</code>, <code>get { ... }</code> 이런 핸들러들은 내부적으로 이렇게 정의돼 있어 👇</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-807e-bb37-fc2d6841f8c1" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">suspend fun PipelineContext&lt;Unit, ApplicationCall&gt;.handleCall() { ... }

</code></pre><p id="2a8655e8-3169-80e0-8498-ef3bd8651dc2" class="">즉, 이 블록은 이미 <strong>suspend 환경 + CoroutineScope</strong> 안에서 실행돼.</p><p id="2a8655e8-3169-80f1-89c4-cce75e0c20ed" class="">그래서 <code>launch</code>, <code>async</code>, <code>delay</code>, <code>withContext</code> 같은 코루틴 관련 함수들을</p><p id="2a8655e8-3169-8003-b04b-d0103787c3a9" class=""><strong>직접 쓸 수 있는 상태</strong>로 열려 있는 거야.</p><hr id="2a8655e8-3169-8084-a025-e77128eda974"/><h2 id="2a8655e8-3169-80c8-adc7-da2d70389645" class="">⚙️ 2️⃣ 그럼 실제 흐름은 이렇게 돼</h2><p id="2a8655e8-3169-80c9-8860-ff66c10489cd" class="">1️⃣ 클라이언트가 <code>/send-email</code> 요청을 보냄</p><p id="2a8655e8-3169-800c-97f1-c5b12d4e7ca2" class="">2️⃣ Ktor가 이 요청을 처리하기 위한 <strong>요청 전용 CoroutineScope</strong> 생성</p><p id="2a8655e8-3169-80f9-af1d-f3a1ac529847" class="">3️⃣ 네 <code>post(&quot;/send-email&quot;) { ... }</code> 블록이 <strong>그 스코프 안에서 실행됨</strong></p><p id="2a8655e8-3169-80a0-a798-e460d6d8d344" class="">4️⃣ <code>call.respondText(...)</code> 를 실행하면서 응답을 바로 내려보냄</p><p id="2a8655e8-3169-80f6-bd5d-d51399acda43" class="">5️⃣ 이어서 같은 스코프 안에서 <code>launch(Dispatchers.IO)</code> 로</p><p id="2a8655e8-3169-80eb-a3ff-ea67bc87f78d" class="">새로운 <strong>자식 코루틴</strong>을 생성해서 백그라운드로 돌림</p><p id="2a8655e8-3169-80eb-8d79-c99fd94f7130" class="">6️⃣ HTTP 응답은 이미 나갔지만,</p><p id="2a8655e8-3169-805e-8a38-d9c269315277" class="">부모 스코프(요청 스코프)가 끝나기 전에 자식 코루틴이 다 돌 때까지는 살아 있음</p><p id="2a8655e8-3169-8082-9e5f-f6fb623d1c42" class="">즉, 요청이 “완전히 끝나서 스코프가 사라지기 전까지”</p><p id="2a8655e8-3169-80c3-9277-e424ea2ec6aa" class="">그 <code>launch</code> 블록 안의 <code>sendEmail()</code> 은 정상적으로 실행돼.</p><hr id="2a8655e8-3169-8025-a396-f04a50712830"/><h2 id="2a8655e8-3169-8065-95c5-d79d7a8c00c0" class="">🧠 3️⃣ 왜 스레드가 안 끝나고 코루틴이 돌아가냐?</h2><p id="2a8655e8-3169-80c1-8db1-f3c74f211923" class="">Ktor는 <strong>논블로킹 엔진(Netty / CIO)</strong> 을 쓰고 있어서</p><p id="2a8655e8-3169-8019-9036-f9c7d4b51438" class="">스레드는 요청이 끝날 때까지 점유되지 않아.</p><p id="2a8655e8-3169-80c4-9055-e967160ba0ff" class="">대신에 “이 요청을 처리하는 코루틴 스코프”만 유지해.</p><p id="2a8655e8-3169-80ff-98c1-e9cec0800972" class=""><code>launch</code> 를 하면 <strong>그 스코프의 자식 코루틴이 새로 생기고</strong>,</p><p id="2a8655e8-3169-8088-b749-df52a54377e8" class="">Ktor는 요청이 완전히 정리되기 전까지는</p><p id="2a8655e8-3169-80a5-be63-fb66fa2257ff" class="">그 자식 코루틴이 다 끝날 때까지 컨텍스트를 보관해둬.</p><hr id="2a8655e8-3169-8061-8914-f91668c079e4"/><h2 id="2a8655e8-3169-8055-b78d-de98403438a4" class="">💡 4️⃣ 즉, 이런 관계가 되는 거야</h2><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-804c-9884-e305bbff2e1b" class="code code-wrap"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">[Request CoroutineScope]
 ├─ call.respondText()  → 즉시 응답
 └─ launch(Dispatchers.IO) → 비동기 이메일 전송

</code></pre><p id="2a8655e8-3169-8038-bc68-e66ed9045f32" class=""><code>launch</code> 가 같은 스코프 안에서 돌아가니까</p><p id="2a8655e8-3169-807a-be17-efdb03b34467" class="">요청이 끝나기 전까지 코루틴은 안전하게 실행돼.</p><hr id="2a8655e8-3169-80e9-a638-e534ecf75eac"/><h2 id="2a8655e8-3169-8094-8b4b-d255c6b5e034" class="">⚠️ 5️⃣ 참고 — 정말 요청 “끝난 뒤에도” 코루틴을 유지하고 싶다면?</h2><p id="2a8655e8-3169-80a2-8583-c2aff0b52217" class="">예를 들어 이메일 전송 시간이 아주 길어서</p><p id="2a8655e8-3169-8013-b18c-df5e73d32349" class="">요청 스코프가 먼저 종료될 수도 있다면</p><p id="2a8655e8-3169-806f-8f78-e4dbf8c682d3" class="">그럴 땐 <strong>Application 전역 스코프</strong>를 따로 만들어서 실행해야 해 👇</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-8030-812f-c176db7e23b2" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">val appScope = CoroutineScope(SupervisorJob() + Dispatchers.IO)

fun Application.module() {
    routing {
        post(&quot;/send-email&quot;) {
            val req = call.receive&lt;EmailRequest&gt;()
            call.respondText(&quot;요청 받음&quot;)

            // ✅ 요청과 독립된 전역 스코프에서 실행
            appScope.launch {
                sendEmail(req)
            }
        }
    }
}

</code></pre><p id="2a8655e8-3169-80f9-aa33-c4d83482f579" class="">→ 이렇게 하면 요청이 끝나도 메일 전송은 계속됨 (서버가 죽지 않는 한)</p><hr id="2a8655e8-3169-803f-8f2b-ff8a5da5f998"/><h2 id="2a8655e8-3169-80d8-af37-e1b559f540b9" class="">🧙‍♂️ 정리하자면</h2><table id="2a8655e8-3169-8002-8415-e8829686cb25" class="simple-table"><thead class="simple-table-header"><tr id="2a8655e8-3169-8033-9c6e-ee4a630c5221"><th id="fG:&gt;" class="simple-table-header-color simple-table-header">항목</th><th id="W?F@" class="simple-table-header-color simple-table-header">설명</th></tr></thead><tbody><tr id="2a8655e8-3169-80b5-9368-ef1d313e6d3e"><td id="fG:&gt;" class=""><code>post { ... }</code> 블록</td><td id="W?F@" class="">이미 코루틴 스코프 (<code>CoroutineScope</code>)</td></tr><tr id="2a8655e8-3169-8048-af3e-eec4b6116eaf"><td id="fG:&gt;" class=""><code>launch { ... }</code></td><td id="W?F@" class="">그 스코프의 자식 코루틴으로 실행</td></tr><tr id="2a8655e8-3169-8023-904a-c98eadc49c0b"><td id="fG:&gt;" class=""><code>respondText()</code> 이후에도 코루틴이 도는 이유</td><td id="W?F@" class="">요청 스코프가 아직 살아 있음</td></tr><tr id="2a8655e8-3169-80be-a101-e23bab51cf91"><td id="fG:&gt;" class="">요청 끝나도 계속 돌려야 하면</td><td id="W?F@" class=""><code>Application</code> 전역 스코프에서 실행</td></tr></tbody></table><hr id="2a8655e8-3169-80e9-ac7d-c3f41e1aa6cf"/><blockquote id="2a8655e8-3169-8088-a6d5-df65511e14d8" class="">💬 요약<p id="2a8655e8-3169-8094-b28f-e2373c561375" class="">“응답 후에도 코루틴이 실행되는 이유는,</p><p id="2a8655e8-3169-809e-a681-dfad5829e661" class="">Ktor 라우팅 핸들러 자체가 <strong>코루틴 스코프</strong>이기 때문이야.</p><p id="2a8655e8-3169-8022-9059-ed6f77aa124c" class="">응답은 바로 나가지만, 그 스코프 안의 자식 코루틴이 남아 있어 일을 계속하는 거지.”</p></blockquote></details></li></ul><ul id="2a8655e8-3169-8028-b1dd-ff82e39afb83" class="toggle"><li><details open=""><summary>스프링부트에서는 요청을 return하면 바로 끝나잖아 이거랑 비교해서 설명해줘</summary><p id="2a8655e8-3169-8018-9b4e-cb8acee0f7a6" class="">이해 완벽해 👏</p><p id="2a8655e8-3169-80dc-ba82-f832c635d239" class="">이제 진짜 <strong>“Ktor vs Spring Boot의 요청-스레드-코루틴 생명주기 차이”</strong> 를 딱 정리해줄게.</p><p id="2a8655e8-3169-8022-b631-dbaf26edd6ec" class="">이걸 이해하면 왜 Ktor는 <code>respond()</code> 이후에도 일을 계속 할 수 있고,</p><p id="2a8655e8-3169-800d-acee-fe6022842796" class="">왜 Spring은 <code>return</code> 하면 끝나는지도 완벽히 감이 와.</p><hr id="2a8655e8-3169-803f-9d0b-e1495ecc1414"/><h2 id="2a8655e8-3169-802a-93a3-ee4c0e1081ec" class="">🧩 1️⃣ 가장 큰 차이: <strong>Ktor는 “코루틴 기반”, Spring은 “스레드 기반”</strong></h2><table id="2a8655e8-3169-805c-bd91-f377558e0fed" class="simple-table"><thead class="simple-table-header"><tr id="2a8655e8-3169-8016-8876-c0f632d8f520"><th id="{RO~" class="simple-table-header-color simple-table-header">구분</th><th id="VjYl" class="simple-table-header-color simple-table-header"><strong>Ktor (코루틴 기반)</strong></th><th id="y}it" class="simple-table-header-color simple-table-header"><strong>Spring MVC (기본, 스레드 기반)</strong></th></tr></thead><tbody><tr id="2a8655e8-3169-8051-9d03-e2821c0e9d40"><td id="{RO~" class="">실행 단위</td><td id="VjYl" class="">코루틴(Coroutine)</td><td id="y}it" class="">스레드(Thread)</td></tr><tr id="2a8655e8-3169-809f-bba8-fbdc1a22b1c0"><td id="{RO~" class="">요청 처리</td><td id="VjYl" class="">논블로킹</td><td id="y}it" class="">블로킹</td></tr><tr id="2a8655e8-3169-8054-8c19-e69749f67c84"><td id="{RO~" class="">요청마다 스레드 생성?</td><td id="VjYl" class="">❌ (스레드 풀 공유)</td><td id="y}it" class="">✅ (요청마다 하나의 스레드)</td></tr><tr id="2a8655e8-3169-809f-abbf-e645de0140f4"><td id="{RO~" class="">suspend 가능</td><td id="VjYl" class="">✅ (기본 지원)</td><td id="y}it" class="">❌ (WebFlux에서만 가능)</td></tr><tr id="2a8655e8-3169-80e2-8de2-eb5002690f31"><td id="{RO~" class="">응답 후 작업 가능?</td><td id="VjYl" class="">✅ 코루틴으로 백그라운드 가능</td><td id="y}it" class="">❌ 요청 끝나면 스레드 반환됨</td></tr><tr id="2a8655e8-3169-808e-b73e-f6c08988b418"><td id="{RO~" class="">스레드 수</td><td id="VjYl" class="">수십만 코루틴 ↔ 수십 개 스레드</td><td id="y}it" class="">스레드 수 = 요청 수 제한</td></tr></tbody></table><hr id="2a8655e8-3169-8028-8563-f5a17d0fb512"/><h2 id="2a8655e8-3169-8053-82b6-c85663c420f7" class="">⚙️ 2️⃣ 요청 흐름 비교</h2><h3 id="2a8655e8-3169-807e-bd2c-d4ff12105851" class="">🧱 <strong>Spring MVC</strong></h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-80af-8fe2-f4525c7c593b" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">@GetMapping(&quot;/send-email&quot;)
fun sendEmail(): String {
    emailService.send() // 오래 걸림 (ex. SMTP)
    return &quot;ok&quot;
}

</code></pre><h3 id="2a8655e8-3169-8078-9a79-df882a415070" class="">동작</h3><p id="2a8655e8-3169-80aa-8be8-df3cd5f3312c" class="">1️⃣ 요청 들어오면 톰캣의 스레드 풀에서 스레드 1개 할당</p><p id="2a8655e8-3169-806c-a6f6-c1fae49f6d9b" class="">2️⃣ <code>send()</code> 실행 중 스레드가 점유된 상태 (다른 요청 처리 불가)</p><p id="2a8655e8-3169-8093-b7e7-ec2f139273db" class="">3️⃣ <code>return</code> 하면 응답이 전송되고</p><p id="2a8655e8-3169-80f7-86cc-f5bf3af2f3bb" class="">4️⃣ 그 즉시 스레드가 반환되고 요청 스코프 종료됨</p><p id="2a8655e8-3169-8076-a4bf-e5da23dcd8b1" class="">즉,</p><blockquote id="2a8655e8-3169-800f-8ec5-dc59584e5665" class="">Spring MVC는 return 순간 = 스레드 생명주기 끝 = 요청 완전 종료</blockquote><p id="2a8655e8-3169-8091-ba21-c6967582a14a" class="">그래서 return 후에 <code>Thread.sleep</code>, <code>delay</code>, <code>launch</code> 이런 걸 해도</p><p id="2a8655e8-3169-80f9-a13e-c54e000b4552" class="">그건 <strong>이미 요청 스코프 밖에서 비동기로 돌리는 완전히 별개의 스레드</strong>가 돼야 해.</p><hr id="2a8655e8-3169-80e3-a133-e4ce966a76a3"/><h3 id="2a8655e8-3169-8065-ba13-e88182088360" class="">🌊 <strong>Ktor</strong></h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-8052-9db5-fbe08886d55c" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">post(&quot;/send-email&quot;) {
    call.respondText(&quot;요청 받음&quot;) // 응답 즉시 보냄
    launch(Dispatchers.IO) {
        sendEmail() // suspend fun
    }
}

</code></pre><h3 id="2a8655e8-3169-80a5-ada1-e0e9d1dbc13c" class="">동작</h3><p id="2a8655e8-3169-80d6-b880-ec1afa1b0b62" class="">1️⃣ 요청 들어오면 Ktor가 <strong>요청용 코루틴 스코프</strong> 생성</p><p id="2a8655e8-3169-80df-8842-c81e44f71e5d" class="">2️⃣ <code>respondText()</code> → 바로 응답 송신</p><p id="2a8655e8-3169-8039-8e64-eaf2b3678c09" class="">3️⃣ 하지만 요청 스코프는 아직 살아 있음</p><p id="2a8655e8-3169-80cc-aff9-c6a3b40464af" class="">4️⃣ 같은 스코프 안에서 <code>launch</code>로 자식 코루틴 생성 → 백그라운드 실행</p><p id="2a8655e8-3169-8086-9a70-dbf20b1f41e6" class="">5️⃣ 코루틴이 완료되면 스코프가 정리됨</p><blockquote id="2a8655e8-3169-80cc-b9f1-e1488fcbb796" class="">응답은 나가도 코루틴은 스코프 내에서 계속 살아 있음</blockquote><p id="2a8655e8-3169-809c-b955-e04c6c20c386" class="">이게 가능한 이유는 Ktor가 OS 스레드가 아니라</p><p id="2a8655e8-3169-8015-b8d2-c26859519f77" class="">코루틴 스케줄러를 이용해서 비동기 작업을 관리하기 때문이야.</p><p id="2a8655e8-3169-8020-ae64-ce6d1740ecd2" class="">즉, 스레드가 “끝나서 사라지는 구조”가 아니라,</p><p id="2a8655e8-3169-8080-b303-ec15b8daecbe" class="">“코루틴이 논리적으로 독립된 상태”로 동작하는 구조야.</p><hr id="2a8655e8-3169-800e-833d-d2ca85f15317"/><h2 id="2a8655e8-3169-8054-8389-c34f3b6a3342" class="">🧠 3️⃣ 한눈에 보는 실행 차이</h2><h3 id="2a8655e8-3169-8033-8018-fe784302c16d" class="">Spring MVC (스레드 점유 방식)</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-8088-ab0e-d41d8dd47e5f" class="code code-wrap"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">[요청 시작]
└─ Thread#17 할당
   └─ controller.sendEmail()
        └─ emailService.send()  (3초 블로킹)
   └─ return &quot;ok&quot;  → 응답 전송
└─ Thread#17 반환 (작업 끝)

</code></pre><p id="2a8655e8-3169-800a-ac36-eed825d7aa60" class="">➡️ return 하면 바로 끝,</p><p id="2a8655e8-3169-8080-af70-e312880087e6" class="">추가 작업을 하려면 <strong>다른 스레드</strong>를 만들어야 함.</p><hr id="2a8655e8-3169-8004-8532-fae181411af2"/><h3 id="2a8655e8-3169-80d1-8d2b-ed093d24d96c" class="">Ktor (코루틴 스케줄 방식)</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-8005-b8a9-c4f2cd04bb21" class="code code-wrap"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">[요청 시작]
└─ Coroutine#1 생성 (Dispatchers.IO)
   ├─ call.respondText()  → 응답 전송
   ├─ launch { sendEmail() }  → 자식 코루틴 생성
   └─ 요청 스코프는 여전히 유지됨
       └─ sendEmail() 내부 delay 중에도 스레드 반납
       └─ 완료 시 스코프 정리

</code></pre><p id="2a8655e8-3169-803e-9ab0-f1206a1e941a" class="">➡️ return이 없고,</p><p id="2a8655e8-3169-801f-b6b6-db0373d0b41a" class="">응답을 보낸 뒤에도 <strong>코루틴은 남아서</strong> 일을 계속할 수 있음.</p><hr id="2a8655e8-3169-803d-8a5b-f5cd2ce83c1c"/><h2 id="2a8655e8-3169-8061-8782-d4c7a152fed6" class="">⚡️ 4️⃣ 스프링에서 이걸 흉내내고 싶다면?</h2><p id="2a8655e8-3169-8040-ab58-c74e9b4100b5" class="">Spring에서는 이걸 하려면 <strong>직접 비동기 스코프를 만들어야 해</strong> 👇</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a8655e8-3169-80bb-910a-e1411c1b14cb" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">@GetMapping(&quot;/send-email&quot;)
fun sendEmail(): String {
    GlobalScope.launch(Dispatchers.IO) {
        emailService.send()
    }
    return &quot;요청 받음&quot; // 즉시 응답
}

</code></pre><p id="2a8655e8-3169-8071-b367-f17dc253c93b" class="">이러면 Spring도 흉내는 낼 수 있어.</p><p id="2a8655e8-3169-80b7-b4d8-fc8da5d94f93" class="">하지만 이건 <strong>스프링의 요청 스레드와 완전히 분리된 전역 코루틴</strong>이야.</p><p id="2a8655e8-3169-801d-86d5-e76d72554fa9" class="">즉, 스프링이 이 코루틴의 생명주기를 관리하지 못해.</p><p id="2a8655e8-3169-80e4-a52e-cf99a1e6ecda" class="">(요청이 실패해도 코루틴은 계속 돈다 → 예외 처리 주의 ⚠️)</p><p id="2a8655e8-3169-80c7-a5d2-d3cb4871af12" class="">그래서 실무에서는</p><p id="2a8655e8-3169-801d-8c09-ced15f2129d1" class="">👉 <strong>Ktor는 내부 스코프에서 launch 사용</strong></p><p id="2a8655e8-3169-8024-911c-e8c8759bd27a" class="">👉 <strong>Spring은 별도의 백그라운드 워커 or @Async or MQ 사용</strong></p><p id="2a8655e8-3169-805b-9adc-f5ba6e001b98" class="">이렇게 분리해서 설계하는 게 맞다.</p><hr id="2a8655e8-3169-803c-93e4-e1af0911597d"/><h2 id="2a8655e8-3169-8054-9d74-df7d63e9627d" class="">🧙‍♂️ 결론 요약</h2><table id="2a8655e8-3169-8072-97a5-ffacf5634622" class="simple-table"><thead class="simple-table-header"><tr id="2a8655e8-3169-8088-8b69-e7b7abf4a3d9"><th id="knzS" class="simple-table-header-color simple-table-header">항목</th><th id="gKje" class="simple-table-header-color simple-table-header"><strong>Ktor</strong></th><th id="fg|Z" class="simple-table-header-color simple-table-header"><strong>Spring MVC</strong></th></tr></thead><tbody><tr id="2a8655e8-3169-803f-a3f6-c38ee2bc12f4"><td id="knzS" class="">요청 단위</td><td id="gKje" class="">코루틴 스코프</td><td id="fg|Z" class="">스레드 스코프</td></tr><tr id="2a8655e8-3169-80dd-90c2-cc965ad993a9"><td id="knzS" class="">응답 후 추가 작업</td><td id="gKje" class="">가능 (같은 스코프 안)</td><td id="fg|Z" class="">불가능 (스레드 반환됨)</td></tr><tr id="2a8655e8-3169-805b-817d-f733480ea36f"><td id="knzS" class="">백그라운드 작업 처리</td><td id="gKje" class=""><code>launch</code> 로 간단히 가능</td><td id="fg|Z" class=""><code>@Async</code>, <code>GlobalScope</code>, TaskExecutor 필요</td></tr><tr id="2a8655e8-3169-80e0-a3dd-dd7272b351af"><td id="knzS" class="">스코프 생명주기</td><td id="gKje" class="">Ktor가 요청 종료 시 관리</td><td id="fg|Z" class="">Spring이 요청 스레드 종료 시 반환</td></tr><tr id="2a8655e8-3169-8045-84c9-e11530339bb4"><td id="knzS" class="">진짜 비동기 서버</td><td id="gKje" class="">✅ 네이티브 지원</td><td id="fg|Z" class="">❌ 별도 설정 필요 (WebFlux로 전환해야 함)</td></tr></tbody></table><hr id="2a8655e8-3169-80d1-8c90-f8fcb1e1086a"/><p id="2a8655e8-3169-804a-9098-d89c92349bc7" class="">💬 <strong>정리 한 줄</strong></p><blockquote id="2a8655e8-3169-808d-ae61-d983ccd0fa54" class="">Ktor는 “응답을 보내도 코루틴이 계속 살아 있는 비동기 서버”,<p id="2a8655e8-3169-80ca-93d0-f31276ec0da5" class="">Spring은 “응답을 반환하면 스레드 자체가 끝나는 동기 서버”.</p><p id="2a8655e8-3169-80c8-b5b0-dff37fc16f82" class="">그래서 Ktor에선 <code>respond()</code> 뒤에 <code>launch</code> 해도 동작하고,</p><p id="2a8655e8-3169-80fa-850e-df44ff6af94e" class="">Spring에선 <code>return</code> 뒤에 모든 게 종료되는 거야.</p></blockquote></details></li></ul><ul id="2a9655e8-3169-80b8-8d8d-e92d0d792fa2" class="toggle"><li><details open=""><summary>ktor 코루틴 안에 코루틴 안에 코루틴</summary><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a9655e8-3169-809c-8e6b-ff260e0a05d0" class="code code-wrap"><code class="language-Markdown" style="white-space:pre-wrap;word-break:break-all">import io.ktor.server.application.*
import io.ktor.server.engine.*
import io.ktor.server.netty.*
import io.ktor.server.response.*
import io.ktor.server.routing.*
import kotlinx.coroutines.*

// 전역 스코프 (요청과 완전 독립)
val appScope = CoroutineScope(SupervisorJob() + Dispatchers.IO)

fun main() {
    embeddedServer(Netty, port = 8080) {
        routing {

            // ✅ (1) 응답 전에 끝내야 하는 작업
            post(&quot;/sync-email&quot;) {
                println(&quot;📩 [sync] 요청 들어옴&quot;)

                sendEmail(&quot;dongun@bssm.hs.kr&quot;) // suspend fun → 여기서 기다림
                call.respondText(&quot;✅ [sync] 이메일 전송 완료&quot;) // 끝난 후 응답
            }

            // ✅ (2) 응답 후에 비동기로 돌릴 작업
            post(&quot;/async-email&quot;) {
                println(&quot;📩 [async] 요청 들어옴&quot;)

                call.respondText(&quot;🚀 [async] 요청 받음 (이메일은 백그라운드로 보냄)&quot;)
                launch(Dispatchers.IO) {
                    sendEmail(&quot;dongun@bssm.hs.kr&quot;) // 응답 후에도 백그라운드에서 실행
                }
            }

            // ✅ (3) 요청과 완전 무관한 전역 백그라운드 작업
            post(&quot;/global-email&quot;) {
                println(&quot;📩 [global] 요청 들어옴&quot;)

                call.respondText(&quot;🌍 [global] 요청 받음 (전역 코루틴에서 보냄)&quot;)
                appScope.launch {
                    sendEmail(&quot;dongun@bssm.hs.kr&quot;) // 요청이 끝나도 계속 실행됨
                }
            }
        }
    }.start(wait = true)
}

// suspend 함수: 실제로는 이메일 API 호출 등 I/O 동작
suspend fun sendEmail(to: String) {
    println(&quot;💌 [sendEmail] 시작: $to (thread=${Thread.currentThread().name})&quot;)
    delay(3000)
    println(&quot;✅ [sendEmail] 완료: $to (thread=${Thread.currentThread().name})&quot;)
}
</code></pre><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a9655e8-3169-8038-9215-d6513fc06a9d" class="code code-wrap"><code class="language-Markdown" style="white-space:pre-wrap;word-break:break-all">📩 [sync] 요청 들어옴
💌 [sendEmail] 시작: dongun@bssm.hs.kr (thread=DefaultDispatcher-worker-1)
✅ [sendEmail] 완료: dongun@bssm.hs.kr (thread=DefaultDispatcher-worker-1)
✅ [sync] 이메일 전송 완료
---
📩 [async] 요청 들어옴
🚀 [async] 요청 받음 (이메일은 백그라운드로 보냄)
💌 [sendEmail] 시작: dongun@bssm.hs.kr (thread=DefaultDispatcher-worker-2)
✅ [sendEmail] 완료: dongun@bssm.hs.kr (thread=DefaultDispatcher-worker-2)
---
📩 [global] 요청 들어옴
🌍 [global] 요청 받음 (전역 코루틴에서 보냄)
💌 [sendEmail] 시작: dongun@bssm.hs.kr (thread=DefaultDispatcher-worker-3)
✅ [sendEmail] 완료: dongun@bssm.hs.kr (thread=DefaultDispatcher-worker-3)
</code></pre></details></li></ul><ul id="2a9655e8-3169-80e6-b6ed-d4a1e9e972f1" class="toggle"><li><details open=""><summary>ktor 실무</summary><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a9655e8-3169-8064-935c-ecb0581c419a" class="code code-wrap"><code class="language-Markdown" style="white-space:pre-wrap;word-break:break-all">src/
├─ application/
│   └─ UserRoutes.kt        ← Ktor 라우팅 (Application 계층)
├─ service/
│   ├─ UserService.kt       ← 비즈니스 로직 (Service 계층)
│   ├─ UserRepository.kt
│   └─ MailService.kt
└─ Application.kt            ← 서버 시작점
</code></pre><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a9655e8-3169-8064-bb19-f42b9846c2e3" class="code code-wrap"><code class="language-Markdown" style="white-space:pre-wrap;word-break:break-all">import io.ktor.server.application.*
import io.ktor.server.engine.*
import io.ktor.server.netty.*
import io.ktor.server.routing.*
import application.userRoutes
import service.*

fun main() {
    embeddedServer(Netty, port = 8080) {
        val userService = UserService(UserRepository(), MailService())
        routing {
            userRoutes(userService) // 라우트 등록
        }
    }.start(wait = true)
}
</code></pre><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a9655e8-3169-80a1-89bc-e59a32019670" class="code code-wrap"><code class="language-Markdown" style="white-space:pre-wrap;word-break:break-all">package application

import io.ktor.server.application.*
import io.ktor.server.response.*
import io.ktor.server.request.*
import io.ktor.server.routing.*
import kotlinx.coroutines.*
import service.*

data class RegisterRequest(val email: String)

fun Routing.userRoutes(userService: UserService) {
    post(&quot;/register&quot;) {
        val req = call.receive&lt;RegisterRequest&gt;()

        // ✅ 1️⃣ 요청은 suspend 함수 내부 (이미 코루틴 스코프)
        // 서비스의 suspend 함수 호출
        val result = userService.registerUser(req.email)

        // ✅ 2️⃣ 응답은 즉시
        call.respondText(result)
    }

    post(&quot;/register/async&quot;) {
        val req = call.receive&lt;RegisterRequest&gt;()

        // ✅ 1️⃣ 즉시 응답 먼저
        call.respondText(&quot;요청을 받았습니다. 이메일 전송은 백그라운드에서 수행됩니다.&quot;)

        // ✅ 2️⃣ 비동기적으로 서비스 호출
        launch(Dispatchers.IO) {
            userService.registerUser(req.email)
        }
    }
}
</code></pre><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a9655e8-3169-80a5-9520-d1ce8fdd9fcb" class="code code-wrap"><code class="language-Markdown" style="white-space:pre-wrap;word-break:break-all">package service

import kotlinx.coroutines.*

class UserService(
    private val repo: UserRepository,
    private val mailService: MailService
) {
    // suspend로 설계 (Ktor 스코프에서 자연스럽게 호출 가능)
    suspend fun registerUser(email: String): String = coroutineScope {
        println(&quot;🧩 [UserService] 사용자 등록 시작: $email&quot;)

        // ✅ 동시에 실행되는 두 가지 비동기 작업
        val userDeferred = async { repo.createUser(email) }
        val mailDeferred = async { mailService.sendWelcomeMail(email) }

        // 모두 완료될 때까지 대기
        val user = userDeferred.await()
        mailDeferred.await()

        println(&quot;✅ [UserService] 등록 완료: ${user.name}&quot;)
        return@coroutineScope &quot;가입 완료: ${user.name}&quot;
    }
}
</code></pre><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a9655e8-3169-8078-b8a6-de467993a64e" class="code code-wrap"><code class="language-Markdown" style="white-space:pre-wrap;word-break:break-all">package service

import kotlinx.coroutines.delay

class UserRepository {
    suspend fun createUser(email: String): User {
        println(&quot;💾 [DB] 사용자 생성 중... ($email)&quot;)
        delay(1000) // DB insert 시뮬레이션
        println(&quot;💾 [DB] 사용자 생성 완료 ($email)&quot;)
        return User(email, &quot;dongun&quot;)
    }
}

data class User(val email: String, val name: String)
</code></pre><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a9655e8-3169-8053-9f90-f0e14bf6ceea" class="code code-wrap"><code class="language-Markdown" style="white-space:pre-wrap;word-break:break-all">package service

import kotlinx.coroutines.delay

class MailService {
    suspend fun sendWelcomeMail(email: String) {
        println(&quot;📨 [메일] 전송 중... ($email)&quot;)
        delay(800) // SMTP 전송 시뮬레이션
        println(&quot;✅ [메일] 전송 완료 ($email)&quot;)
    }
}
</code></pre><h3 id="2a9655e8-3169-80b5-a424-ef588b9d67f7" class="">요청: <code>/register</code></h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a9655e8-3169-80ec-9975-cd4bbfe2e3a3" class="code code-wrap"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">💾 [DB] 사용자 생성 중... (dongun@bssm.hs.kr)
📨 [메일] 전송 중... (dongun@bssm.hs.kr)
💾 [DB] 사용자 생성 완료 (dongun@bssm.hs.kr)
✅ [메일] 전송 완료 (dongun@bssm.hs.kr)
✅ [UserService] 등록 완료: dongun

</code></pre><p id="2a9655e8-3169-8061-a02b-d51842fb5c8d" class="">→ DB 작업과 메일 전송이 <strong>동시에(비동기)</strong> 수행되고</p><p id="2a9655e8-3169-805a-a95f-f5b17f97d236" class="">→ 두 코루틴이 끝난 뒤 응답 전송 (<code>await()</code>로 구조적 동시성 보장)</p><hr id="2a9655e8-3169-8063-a5a9-c001cbf5cd9e"/><h3 id="2a9655e8-3169-8045-a8d2-f696b9bee770" class="">요청: <code>/register/async</code></h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2a9655e8-3169-80b2-9ab5-c740d52c4656" class="code code-wrap"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">요청을 받았습니다. 이메일 전송은 백그라운드에서 수행됩니다.
💾 [DB] 사용자 생성 중... (dongun@bssm.hs.kr)
📨 [메일] 전송 중... (dongun@bssm.hs.kr)
...
✅ [UserService] 등록 완료: dongun

</code></pre><p id="2a9655e8-3169-80dd-8d97-fbbc12f5a8e9" class="">→ 응답은 먼저 나가고,</p><p id="2a9655e8-3169-8084-a116-c960c5e1f595" class="">→ 같은 요청 스코프 안에서 <code>launch(Dispatchers.IO)</code> 코루틴이 뒤에서 계속 실행됨.</p><hr id="2a9655e8-3169-807a-bbe2-e7997a123e4a"/><h2 id="2a9655e8-3169-80f0-8b10-eddfc881d95d" class="">✅ 정리</h2><table id="2a9655e8-3169-8031-9410-e52bd83792ba" class="simple-table"><thead class="simple-table-header"><tr id="2a9655e8-3169-8042-b894-c0b51e480e27"><th id="?BUJ" class="simple-table-header-color simple-table-header">계층</th><th id="a}Q@" class="simple-table-header-color simple-table-header">역할</th><th id="yJnh" class="simple-table-header-color simple-table-header">코루틴 책임</th></tr></thead><tbody><tr id="2a9655e8-3169-8050-93c0-fcacbd57cbf8"><td id="?BUJ" class="">Application (<code>UserRoutes.kt</code>)</td><td id="a}Q@" class="">요청 수신 / 응답 반환</td><td id="yJnh" class="">요청 단위 CoroutineScope (Ktor 자동 관리)</td></tr><tr id="2a9655e8-3169-8015-83e1-f08e5e40253d"><td id="?BUJ" class="">Service (<code>UserService.kt</code>)</td><td id="a}Q@" class="">비즈니스 로직 / 비동기 분기</td><td id="yJnh" class="">내부 <code>coroutineScope { async }</code> 로 구조적 동시성 유지</td></tr><tr id="2a9655e8-3169-80ee-a262-db839da940ed"><td id="?BUJ" class="">Repository / External</td><td id="a}Q@" class="">DB, API, 메일 등 I/O</td><td id="yJnh" class=""><code>suspend</code> 함수로 선언, I/O 시 스레드 반납</td></tr></tbody></table><hr id="2a9655e8-3169-803e-bc39-dfe6181ac683"/><p id="2a9655e8-3169-8024-a697-cfa339cbee30" class="">🧙‍♂️ <strong>장인의 한마디</strong></p><blockquote id="2a9655e8-3169-8048-b6f6-d4352f2b80cc" class="">“Application 계층에서는 코루틴을 직접 만들지 말고, suspend fun만 호출하라.”“Service 계층에서는 여러 비동기 작업을 coroutineScope로 관리하라.”“GlobalScope는 절대 서비스 안에서 쓰지 마라.”</blockquote></details></li></ul><ul id="2b1655e8-3169-80c3-9e81-c836fed0e12c" class="toggle"><li><details open=""><summary>FSM</summary><h2 id="2b1655e8-3169-80c9-acae-dab308e43d74" class="">코루틴의 FSM과 힙 메모리 저장 방식</h2><p id="2b1655e8-3169-8011-9d43-e55045cfaa42" class="">정확하게 이해하셨습니다. 코틀린 코루틴은 <code><strong>suspend</strong></code> 함수를 FSM(Finite State Machine)으로 변환하고, 지역 변수들을 <code><strong>Continuation</strong></code> 객체의 필드로 승격시켜 힙 메모리에 저장합니다. 이를 통해 코루틴이 중단되었다가 다른 곳에서 재개되어도 상태가 유지됩니다.</p><h2 id="2b1655e8-3169-801a-87d8-f310af24426c" class="">suspend 함수의 FSM 변환 과정</h2><p id="2b1655e8-3169-80c9-a1d2-f9d1a17aa242" class="">코틀린 컴파일러는 <code><strong>suspend</strong></code> 함수를 컴파일할 때 다음과 같은 작업을 수행합니다:</p><p id="2b1655e8-3169-8013-849c-c21c7a008f9c" class=""><strong>1. Continuation 객체 생성</strong></p><ul id="2b1655e8-3169-8044-abdd-d8c6e8d4ecc5" class="bulleted-list"><li style="list-style-type:disc">원래 함수의 지역 변수들을 <code><strong>Continuation</strong></code> 객체의 필드 변수로 승격시킵니다</li></ul><ul id="2b1655e8-3169-8080-b8ab-cc84a89d13e0" class="bulleted-list"><li style="list-style-type:disc"><code><strong>label</strong></code>이라는 상태 변수를 추가해 현재 어느 중단 지점에 있는지 추적합니다</li></ul><p id="2b1655e8-3169-8029-afe4-f3a760d80bdd" class=""><strong>2. when/switch 문으로 상태 관리</strong></p><ul id="2b1655e8-3169-80c6-bcca-d855384b13ea" class="bulleted-list"><li style="list-style-type:disc">함수 내부를 <code><strong>when</strong></code> 문 기반의 FSM으로 변환합니다</li></ul><ul id="2b1655e8-3169-80ce-98ee-d2e9aabc89f0" class="bulleted-list"><li style="list-style-type:disc">각 중단 지점(suspend 함수 호출 지점)마다 다른 label 값을 할당합니다</li></ul><ul id="2b1655e8-3169-808f-b9b4-cfc43dcaa126" class="bulleted-list"><li style="list-style-type:disc">label에 따라 해당 상태로 점프하여 실행을 재개합니다</li></ul><p id="2b1655e8-3169-80ef-88dc-eba3422768da" class="">예를 들어, 다음과 같은 코드가:</p><p id="2b1655e8-3169-8061-bbfa-ed8c01ee4e02" class=""><code>kotlinsuspend fun makeCoffee(menu: String): String {<br/>    val sugar = getSugar()<br/>    val cream = getCream()<br/>    delay(1000)<br/>    return &quot;$menu coffee $sugar $cream&quot;<br/>}</code></p><p id="2b1655e8-3169-8040-8ea4-ce62f13cf1d7" class="">내부적으로 이렇게 변환됩니다:</p><p id="2b1655e8-3169-80c1-96f4-ddd835c88483" class=""><code>textwhen(label) {<br/>    0 -&gt; { // 시작<br/>        label = 1<br/>        sugar = getSugar(continuation)<br/>    }<br/>    1 -&gt; { // getSugar 완료 후<br/>        label = 2<br/>        cream = getCream(continuation)<br/>    }<br/>    2 -&gt; { // getCream 완료 후<br/>        label = 3<br/>        delay(1000, continuation)<br/>    }<br/>    3 -&gt; { // delay 완료 후<br/>        return &quot;$menu coffee $sugar $cream&quot;<br/>    }<br/>}</code></p><h2 id="2b1655e8-3169-8021-a46d-d9b638dea389" class="">왜 힙 메모리는 안 지워지는가?</h2><p id="2b1655e8-3169-800c-af63-f085177cb8c8" class="">질문하신 핵심은 &quot;힙 메모리도 결국 지워지는 거 아니냐&quot;는 것인데, 여기에는 중요한 차이가 있습니다:</p><p id="2b1655e8-3169-80e8-8566-cb98e85f3eb5" class=""><strong>스택 메모리의 경우</strong></p><ul id="2b1655e8-3169-8024-8442-fe054f1e5186" class="bulleted-list"><li style="list-style-type:disc">함수 호출 시 자동으로 할당되고, 함수가 종료되면 <strong>즉시 자동으로 해제</strong>됩니다</li></ul><ul id="2b1655e8-3169-80e6-9451-e4d1a7697f97" class="bulleted-list"><li style="list-style-type:disc">각 스레드마다 독립적인 스택을 가지며, 다른 스레드는 접근할 수 없습니다</li></ul><ul id="2b1655e8-3169-8004-a86f-ef611d6742cc" class="bulleted-list"><li style="list-style-type:disc">운영체제가 자동으로 관리하므로 함수가 끝나면 지역 변수는 사라집니다</li></ul><p id="2b1655e8-3169-80d8-b029-ea2d816ed610" class=""><strong>힙 메모리의 경우</strong></p><ul id="2b1655e8-3169-8034-bf8d-f2226ffd67e7" class="bulleted-list"><li style="list-style-type:disc">명시적으로(또는 GC에 의해) 해제되기 전까지 <strong>계속 살아있습니다</strong></li></ul><ul id="2b1655e8-3169-8013-b78a-c91208f006cf" class="bulleted-list"><li style="list-style-type:disc">애플리케이션의 모든 스레드가 접근할 수 있습니다</li></ul><ul id="2b1655e8-3169-80e0-8d55-d9d0389c24cb" class="bulleted-list"><li style="list-style-type:disc">Java/Kotlin의 경우 GC가 <strong>참조가 있는 동안</strong> 메모리를 유지합니다</li></ul><p id="2b1655e8-3169-80ba-a917-c7fee6a130c2" class="">코루틴의 경우:</p><ul id="2b1655e8-3169-80d4-ac61-cec551d2dfbf" class="bulleted-list"><li style="list-style-type:disc"><code><strong>Continuation</strong></code> 객체가 힙에 저장되고, 코루틴 스코프나 디스패처가 이 객체를 <strong>계속 참조</strong>하고 있습니다</li></ul><ul id="2b1655e8-3169-801f-a545-ecefef648623" class="bulleted-list"><li style="list-style-type:disc">코루틴이 중단되어도 <code><strong>Continuation</strong></code> 객체는 힙에 남아있고, 참조가 유지되므로 GC가 수거하지 않습니다</li></ul><ul id="2b1655e8-3169-80f0-92a4-e20473765439" class="bulleted-list"><li style="list-style-type:disc">코루틴이 재개될 때 이 객체를 다시 가져와 저장된 상태(label, 지역 변수들)를 복원합니다</li></ul><h2 id="2b1655e8-3169-806c-b0db-c4f1c3d3d7bc" class="">CPS(Continuation Passing Style) 방식</h2><p id="2b1655e8-3169-8092-9bc5-eb9395a53abd" class="">코틀린은 CPS 방식을 채택하여:</p><ul id="2b1655e8-3169-8067-8938-d3526c8201fb" class="bulleted-list"><li style="list-style-type:disc">코루틴의 실행 정보를 <code><strong>Continuation</strong></code> 객체에 저장하고 전달합니다</li></ul><ul id="2b1655e8-3169-802b-952c-d7f26e252354" class="bulleted-list"><li style="list-style-type:disc">중단 시점의 상태가 힙에 있는 <code><strong>Continuation</strong></code> 객체에 캡슐화됩니다</li></ul><ul id="2b1655e8-3169-80ef-b4f8-cd3b97b673d3" class="bulleted-list"><li style="list-style-type:disc">이 객체가 스레드 간에 전달될 수 있어, 다른 스레드에서도 코루틴을 재개할 수 있습니다</li></ul><p id="2b1655e8-3169-8004-8bfb-f5fad48707d3" class="">결론적으로, 코루틴이 중단되어도 <code><strong>Continuation</strong></code> 객체가 힙에 남아있고 참조가 유지되기 때문에 변수들이 사라지지 않습니다. 반면 일반 함수의 지역 변수는 스택에 있어서 함수가 종료되면 즉시 사라지는 것입니다.</p></details></li></ul><ul id="2b1655e8-3169-80a3-9049-e8a6430632f9" class="toggle"><li><details open=""><summary><strong>Continuation과 합성 클래스(Synthetic class)의 관계</strong></summary><p id="2b1655e8-3169-8022-948f-cb1ba887443c" class="">질문하신 내용에 대한 정확한 답은 **&quot;둘 다 맞다&quot;**입니다. 실제로는 <strong>Continuation 객체</strong>가 곧 컴파일러가 생성한 **합성 클래스(Synthetic class)**입니다.</p><h2 id="2b1655e8-3169-806f-9004-c7464a5fdfdc" class="">Continuation 객체의 정체</h2><p id="2b1655e8-3169-803e-8736-d18c9e8c154a" class="">코틀린 컴파일러가 <code><strong>suspend</strong></code> 함수를 컴파일할 때:</p><p id="2b1655e8-3169-80fe-8314-f9a6cfa3f4f6" class=""><strong>1. 합성 클래스 생성</strong></p><ul id="2b1655e8-3169-80d4-adab-c95dc0e3e175" class="bulleted-list"><li style="list-style-type:disc">컴파일러가 <code><strong>ContinuationImpl</strong></code>을 상속하는 합성 클래스(예: <code><strong>DoSomethingStateMachine</strong></code>)를 자동으로 생성합니다</li></ul><ul id="2b1655e8-3169-800d-8d83-de29bd6284e4" class="bulleted-list"><li style="list-style-type:disc">이 클래스가 바로 <code><strong>Continuation</strong></code> 인터페이스를 구현한 구체적인 객체입니다</li></ul><p id="2b1655e8-3169-8043-a380-cbe96914cf65" class=""><strong>2. 지역 변수를 필드로 승격</strong></p><ul id="2b1655e8-3169-800e-940b-d044ad9827a5" class="bulleted-list"><li style="list-style-type:disc">원래 함수의 지역 변수(<code><strong>token</strong></code>, <code><strong>result</strong></code> 등)를 이 합성 클래스의 **필드(Field)**로 변환합니다</li></ul><ul id="2b1655e8-3169-801b-8b48-c89a361d10f9" class="bulleted-list"><li style="list-style-type:disc"><code><strong>label</strong></code>이라는 상태 추적 변수도 필드로 추가됩니다</li></ul><p id="2b1655e8-3169-80f9-bd61-d53fd0276c4a" class="">예를 들어, 다음과 같은 코드가:</p><p id="2b1655e8-3169-800a-b3c1-cab1918ef05b" class=""><code>kotlin</code></p><p id="2b1655e8-3169-8009-b1e0-dc1171caae58" class=""><code>suspend fun doSomething() {<br/>    val token = getToken()<br/>    delay(100)<br/>    val result = fetchData(token)<br/>    println(result)<br/>}</code></p><p id="2b1655e8-3169-801c-8379-d78ac055be31" class="">컴파일러에 의해 이렇게 변환됩니다:</p><p id="2b1655e8-3169-808e-9b0a-c6836ae4beca" class=""><code>java</code></p><p id="2b1655e8-3169-80b5-9dc6-d8169e63d2e3" class=""><code>final class DoSomethingStateMachine extends ContinuationImpl {<br/>    int label = 0;      </code><em><code>// 상태 추적</code></em><code><br/>    Object token;       </code><em><code>// 승격된 지역 변수</code></em><code><br/>    Object result;      </code><em><code>// 승격된 지역 변수</code></em><code><br/>    <br/>    @Override<br/>    Object invokeSuspend(Object result) {<br/>        switch (label) {<br/>            case 0:<br/>                label = 1;<br/>                return getToken(this);<br/>            case 1:<br/>                token = result;<br/>                label = 2;<br/>                return delay(100, this);<br/>            case 2:<br/>                label = 3;<br/>                return fetchData(token, this);<br/>            </code><em><code>// ...</code></em><code><br/>        }<br/>    }<br/>}</code></p><h2 id="2b1655e8-3169-8032-a6f2-ebd7031dd1c5" class="">왜 &quot;Continuation 객체&quot;와 &quot;합성 클래스&quot;라는 두 용어가 혼용되는가?</h2><p id="2b1655e8-3169-8096-a3cd-cfa59192ecb1" class=""><strong>Continuation은 인터페이스</strong></p><p id="2b1655e8-3169-80f2-9567-c36fef9002f9" class=""><code>kotlin</code></p><p id="2b1655e8-3169-80ec-86ea-ef74c81c63a9" class=""><code>interface Continuation&lt;in T&gt; {<br/>    val context: CoroutineContext<br/>    fun resumeWith(result: Result&lt;T&gt;)<br/>}</code></p><p id="2b1655e8-3169-8025-9dfe-e175006a40b6" class=""><strong>합성 클래스는 구현체</strong></p><ul id="2b1655e8-3169-8051-8b76-cfeed540a5b7" class="bulleted-list"><li style="list-style-type:disc">컴파일러가 생성하는 실제 클래스가 <code><strong>Continuation</strong></code> 인터페이스를 구현합니다</li></ul><ul id="2b1655e8-3169-8043-b239-cb3b937699f8" class="bulleted-list"><li style="list-style-type:disc">이 클래스는 보통 <code><strong>ContinuationImpl</strong></code>이나 <code><strong>BaseContinuationImpl</strong></code> 같은 추상 클래스를 상속받습니다</li></ul><p id="2b1655e8-3169-800a-bd8b-eeac4c20b7b6" class="">따라서:</p><ul id="2b1655e8-3169-805b-8ad5-ed63383a88b8" class="bulleted-list"><li style="list-style-type:disc"><strong>추상적 관점</strong>: &quot;Continuation 객체에 저장된다&quot;</li></ul><ul id="2b1655e8-3169-806b-85b8-f9cb14512f9e" class="bulleted-list"><li style="list-style-type:disc"><strong>구체적 구현 관점</strong>: &quot;컴파일러가 생성한 합성 클래스의 필드로 승격된다&quot;</li></ul><p id="2b1655e8-3169-80bd-adda-c9d0ecb7e468" class="">두 표현은 같은 것을 다른 관점에서 설명한 것입니다.</p><h2 id="2b1655e8-3169-8069-a33e-c5767dad90ea" class="">CPS(Continuation Passing Style) 변환 과정</h2><p id="2b1655e8-3169-809e-9443-f88e4f716e95" class="">전체 과정을 정리하면:</p><p id="2b1655e8-3169-8063-aca0-fcd8ddbfa78f" class=""><strong>1단계: 시그니처 변환</strong></p><p id="2b1655e8-3169-8004-97ab-d1db4a949ec0" class=""><code>kotlin</code><em><code>// 원본</code></em><code><br/>suspend fun postItem(item: Item)<br/><br/></code><em><code>// 변환 후</code></em><code><br/>fun postItem(item: Item, cont: Continuation): Any?</code></p><p id="2b1655e8-3169-80c4-a7f1-fb599feb85e9" class=""><strong>2단계: 합성 클래스 생성 및 FSM 변환</strong></p><ul id="2b1655e8-3169-80c1-9a99-d6912bf73de1" class="bulleted-list"><li style="list-style-type:disc"><code><strong>Continuation</strong></code>을 구현하는 합성 클래스(State Machine) 생성</li></ul><ul id="2b1655e8-3169-809c-aff7-d4dac127a59b" class="bulleted-list"><li style="list-style-type:disc">지역 변수들을 이 클래스의 필드로 승격</li></ul><ul id="2b1655e8-3169-80a0-ab6f-c51eb505f580" class="bulleted-list"><li style="list-style-type:disc">함수 본문을 <code><strong>when</strong></code>/<code><strong>switch</strong></code> 문으로 변환</li></ul><p id="2b1655e8-3169-8039-982f-feef48900c11" class=""><strong>3단계: Continuation 전달</strong></p><ul id="2b1655e8-3169-80cb-8410-f36f7e9c3f62" class="bulleted-list"><li style="list-style-type:disc">각 <code><strong>suspend</strong></code> 함수 호출 시 이 합성 클래스 인스턴스를 전달</li></ul><ul id="2b1655e8-3169-80c8-aa7e-f205eecd732e" class="bulleted-list"><li style="list-style-type:disc">중단 시 <code><strong>COROUTINE_SUSPENDED</strong></code> 반환</li></ul><ul id="2b1655e8-3169-80af-8067-dd694d9cc7d1" class="bulleted-list"><li style="list-style-type:disc">재개 시 <code><strong>continuation.resume()</strong></code> 호출로 저장된 상태 복원</li></ul><h2 id="2b1655e8-3169-8056-a76b-c99f9c2a92ca" class="">핵심 요약</h2><p id="2b1655e8-3169-80a1-94c0-dd66ddf2d9be" class="">&quot;<strong>지역 변수가 합성 클래스의 필드로 승격된다</strong>&quot;는 표현이 가장 정확합니다. 그리고 이 <strong>합성 클래스가 </strong><code><strong>Continuation</strong></code><strong> 인터페이스를 구현한 구체적인 객체</strong>입니다.</p><p id="2b1655e8-3169-806a-ad1f-cdde524f243e" class="">즉, &quot;Continuation 객체&quot;라는 것은 실제로는 컴파일러가 자동 생성한 &quot;합성 클래스의 인스턴스&quot;를 추상적으로 부르는 이름입니다.</p></details></li></ul><ul id="2b2655e8-3169-80f0-9e8a-d0340e683c53" class="toggle"><li><details open=""><summary>구조화된 동시성</summary><h2 id="2b2655e8-3169-8002-8ce1-c11a34a4d437" class="">구조화된 동시성과 HTTP 요청 후 백그라운드 작업</h2><p id="2b2655e8-3169-80aa-ae6a-ee761e2f106c" class="">질문하신 내용은 코루틴의 핵심 원칙인 **구조화된 동시성(Structured Concurrency)**과 실제 백엔드 애플리케이션에서의 코루틴 스코프 관리에 대한 것입니다.</p><h2 id="2b2655e8-3169-8076-8e50-d4dccc06248f" class="">구조화된 동시성의 원칙</h2><p id="2b2655e8-3169-80c6-acaf-f87f6364c3a1" class="">구조화된 동시성에서는 다음과 같은 규칙이 적용됩니다:</p><ul id="2b2655e8-3169-803d-8362-e8756145daf9" class="bulleted-list"><li style="list-style-type:disc">부모 코루틴은 모든 자식 코루틴이 완료될 때까지 &quot;실행 완료 중(Completing)&quot; 상태로 대기합니다</li></ul><ul id="2b2655e8-3169-80cf-a609-c71a999eda0c" class="bulleted-list"><li style="list-style-type:disc">부모 코루틴이 취소되면 모든 자식 코루틴도 취소됩니다</li></ul><ul id="2b2655e8-3169-80ad-9219-e7cbab47e7ec" class="bulleted-list"><li style="list-style-type:disc">자식 코루틴에서 예외가 발생하면 부모로 전파됩니다</li></ul><p id="2b2655e8-3169-80a4-bb1b-ef2b2f3314db" class="">이는 코루틴 트리 구조를 통해 작업의 생명주기를 관리하고 리소스 누수를 방지하기 위한 설계입니다.</p><h2 id="2b2655e8-3169-80b0-b504-f61c075dd6b8" class="">Ktor에서 HTTP 응답 후에도 작업이 계속되는 이유</h2><p id="2b2655e8-3169-803c-97df-dee3a5cf9460" class="">Ktor에서는 <strong>두 가지 다른 코루틴 스코프</strong>가 존재합니다:</p><ol type="1" id="2b2655e8-3169-8000-a1cb-dc6a29c64429" class="numbered-list" start="1"><li><strong>Request Scope</strong>: 각 HTTP 요청마다 생성되는 스코프</li></ol><ol type="1" id="2b2655e8-3169-8075-b2b3-e528e9030139" class="numbered-list" start="2"><li><strong>Application Scope</strong>: 애플리케이션 전체 생명주기 동안 유지되는 스코프</li></ol><p id="2b2655e8-3169-8000-9beb-d735ce80a58d" class="">일반적으로 라우트 핸들러 내에서 <code><strong>launch</strong></code>를 호출하면 Request Scope에 속한 자식 코루틴이 생성됩니다. 구조화된 동시성 원칙에 따라 HTTP 응답(<code><strong>call.respond()</strong></code>)을 보낸 후에도 부모 스코프는 모든 자식 코루틴이 완료될 때까지 기다립니다.</p><p id="2b2655e8-3169-807e-85d9-d783fc16e215" class=""><code>kotlinget(&quot;/example&quot;) {<br/>    launch {<br/>        </code><em><code>// 이 코루틴은 request scope의 자식</code></em><code><br/>        delay(2000)<br/>        println(&quot;자식 작업 완료&quot;)<br/>    }<br/>    call.respondText(&quot;응답 전송&quot;) </code><em><code>// 응답을 보내도...// request scope는 위 launch가 끝날 때까지 대기</code></em><code><br/>}</code></p><h2 id="2b2655e8-3169-802a-b018-d6b39a741e72" class="">백그라운드 작업을 독립적으로 실행하는 방법</h2><p id="2b2655e8-3169-80e8-a787-d88db7801e1a" class="">이메일 발송처럼 HTTP 응답과 독립적으로 실행되어야 하는 작업의 경우, <strong>Application Scope</strong>를 사용해야 합니다:</p><p id="2b2655e8-3169-8001-a59b-fa446e4cf613" class=""><code>kotlinget(&quot;/send-email&quot;) {<br/>    </code><em><code>// Application scope에서 실행 (request와 독립적)</code></em><code><br/>    call.application.launch(Dispatchers.IO) {<br/>        </code><em><code>// 이메일 발송 로직</code></em><code><br/>        sendEmail()<br/>    }<br/>    <br/>    </code><em><code>// 즉시 응답 반환</code></em><code><br/>    call.respondText(&quot;이메일 발송 요청이 접수되었습니다&quot;)<br/>}</code></p><p id="2b2655e8-3169-802f-83dc-f82791e8d127" class="">이렇게 하면 다음과 같이 동작합니다:</p><ul id="2b2655e8-3169-807b-874a-c852df968cb5" class="bulleted-list"><li style="list-style-type:disc"><code><strong>call.application.launch</strong></code>는 <strong>애플리케이션 전체 생명주기에 종속된</strong> 코루틴을 생성합니다</li></ul><ul id="2b2655e8-3169-8030-ab01-cdde1bed5575" class="bulleted-list"><li style="list-style-type:disc">Request Scope와는 부모-자식 관계가 아니므로, HTTP 응답이 즉시 반환됩니다</li></ul><ul id="2b2655e8-3169-80ee-b5fc-c42db039e361" class="bulleted-list"><li style="list-style-type:disc">이메일 발송 작업은 백그라운드에서 계속 실행됩니다</li></ul><ul id="2b2655e8-3169-8076-9791-d2d7d76a5c37" class="bulleted-list"><li style="list-style-type:disc">애플리케이션이 종료될 때만 이 코루틴이 취소됩니다</li></ul><h2 id="2b2655e8-3169-8079-b286-ea03417f6524" class="">다른 접근 방법들</h2><p id="2b2655e8-3169-80fa-b8fe-c2ff0808be13" class=""><strong>GlobalScope 사용</strong> (권장되지 않음):</p><p id="2b2655e8-3169-8039-aa19-ea83befe661e" class=""><code>kotlinGlobalScope.launch(Dispatchers.IO) {<br/>    sendEmail()<br/>}</code></p><p id="2b2655e8-3169-8054-ac89-c0e9e0cbaa2e" class="">GlobalScope는 생명주기 관리가 없어 메모리 누수 위험이 있지만, &quot;fire-and-forget&quot; 작업에서는 사용 가능합니다.</p><p id="2b2655e8-3169-80ff-97ba-f16b5c8363bf" class=""><strong>독립적인 CoroutineScope 생성</strong> (GlobalScope와 유사):</p><p id="2b2655e8-3169-80d2-8e74-cce02c30673b" class=""><code>kotlinCoroutineScope(Dispatchers.IO).launch {<br/>    sendEmail()<br/>}</code></p><p id="2b2655e8-3169-8066-8243-d9a70cd26718" class="">반환된 <code><strong>Job</strong></code>을 무시한다면 GlobalScope와 기능적으로 동일합니다.</p><h2 id="2b2655e8-3169-80b7-832e-c91606ff36dd" class="">요약</h2><p id="2b2655e8-3169-8099-a98a-d45283d27416" class="">구조화된 동시성의 원칙은 여전히 작동하고 있습니다. 차이점은 <strong>어느 스코프에서 코루틴을 시작하느냐</strong>입니다:</p><ul id="2b2655e8-3169-801b-a4f2-e5f8824c3cbe" class="bulleted-list"><li style="list-style-type:disc"><strong>Request Scope</strong>에서 시작: HTTP 응답 후에도 해당 요청이 자식 코루틴 완료까지 대기</li></ul><ul id="2b2655e8-3169-80ad-92e4-e85546f527c9" class="bulleted-list"><li style="list-style-type:disc"><strong>Application Scope</strong>에서 시작: 요청과 독립적으로 실행되며, 애플리케이션 생명주기에 종속</li></ul><p id="2b2655e8-3169-8012-a5d0-ce9dd4a49013" class="">Ktor에서는 <code><strong>call.application.launch</strong></code>를 사용하여 요청과 독립적인 백그라운드 작업을 안전하게 실행할 수 있습니다.</p></details></li></ul><ul id="2b2655e8-3169-80da-8d56-d5406e96f166" class="toggle"><li><details open=""><summary>고아 코루틴</summary><p id="2b2655e8-3169-8032-b84e-eb33717b85f7" class="">고아 코루틴(Orphan Coroutine)은 일반적으로 <strong>부모와의 연결이 끊어진 코루틴</strong> 또는 부모가 먼저 종료되어 관리되지 않는 상태에 놓인 코루틴을 의미합니다. 공식적인 용어라기보다는 실무에서 부모-자식 구조화 동시성(Structured Concurrency)을 설명할 때 종종 비유적으로 사용됩니다.</p><h2 id="2b2655e8-3169-8041-824b-fc05f51b58ed" class="">코틀린의 코루틴 구조</h2><ul id="2b2655e8-3169-8042-a7ea-f8afcabc007c" class="bulleted-list"><li style="list-style-type:disc">코틀린 코루틴은 <strong>부모-자식 관계</strong>를 갖는 동시성 설계가 기본입니다.</li></ul><ul id="2b2655e8-3169-80fd-80ae-c3be259324bc" class="bulleted-list"><li style="list-style-type:disc">자식 코루틴은 부모의 컨텍스트를 상속하며, 부모가 종료되면(예: 취소) 자식도 자동으로 취소됩니다.</li></ul><ul id="2b2655e8-3169-80f5-b086-ed07b4c3361a" class="bulleted-list"><li style="list-style-type:disc">부모 없이 단독으로 동작하는 코루틴은 구조화된 동시성 패턴에 위배되며, 이 상태를 가리켜 고아 코루틴이라고 부르기도 합니다.</li></ul><h2 id="2b2655e8-3169-808c-88ec-d5c28d1d2237" class="">고아 코루틴의 문제점</h2><ul id="2b2655e8-3169-80e6-9514-c4e8cf303a18" class="bulleted-list"><li style="list-style-type:disc">관리되지 않는 코루틴은 예측하지 못한 시점에 실행되거나, 앱 종료 시에도 미처 정리되지 못해 <strong>리소스 누수</strong>나 <strong>버그</strong>의 원인이 될 수 있습니다.</li></ul><ul id="2b2655e8-3169-801c-a7d3-eb69b5931d0a" class="bulleted-list"><li style="list-style-type:disc">Structured Concurrency(구조화된 동시성)을 지키면 이런 고아 코루틴의 발생을 방지할 수 있습니다.</li></ul><h2 id="2b2655e8-3169-805e-8531-e9d1353baee1" class="">예시 코드</h2><p id="2b2655e8-3169-8046-a0aa-eda96e04e97d" class="">아래는 부모-자식 관계의 코루틴 예시입니다. 부모가 없는 채 launch로 생성하면 이 코루틴은 고아가 될 수 있습니다.</p><p id="2b2655e8-3169-802b-acf8-eb77585cef12" class=""><code>kotlin</code><em><code>// 올바른 예시 (구조화 O)</code></em><code><br/>runBlocking {<br/>    launch {<br/>        delay(1000)<br/>        println(&quot;Child finished&quot;)<br/>    }<br/>    </code><em><code>// 부모가 모든 자식 코루틴을 기다림</code></em><code><br/>}<br/><br/></code><em><code>// 고아 코루틴 예시 (구조화 X)</code></em><code><br/>fun orphanExample() {<br/>    GlobalScope.launch {<br/>        delay(1000)<br/>        println(&quot;Orphan finished&quot;)<br/>    }<br/>    </code><em><code>// 부모 runBlocking이 없음: 실행이 끝나기 전에 프로그램이 종료될 수 있음</code></em><code><br/>}</code></p><h2 id="2b2655e8-3169-802f-bb27-cf818616a4a9" class="">결론</h2><p id="2b2655e8-3169-80ae-bd2b-e6cc84cf65d9" class="">고아 코루틴은 <strong>부모 스코프와 분리되어 버린 관리되지 않는 코루틴</strong>을 의미합니다. 코루틴을 안전하게 사용하려면 항상 Structured Concurrency 원칙을 지켜 스코프에 맞춰 생성·취소해야 합니다.</p></details></li></ul><ul id="2b2655e8-3169-80a5-9ad2-eb7e0f4e35cf" class="toggle"><li><details open=""><summary><strong>Ktor 서버의 3가지 주요 스레드 그룹</strong></summary><p id="2b2655e8-3169-80f3-acb4-c9373c43331e" class="">Ktor는 <code>embeddedServer</code> 함수를 사용하여 Netty와 같은 엔진을 구성할 때 이 세 그룹의 크기를 설정할 수 있습니다. 이 그룹들은 서버의 병렬 처리 방식을 정의합니다.</p><p id="2b2655e8-3169-80c3-8a32-ff204ac983b0" class="">1. 연결 그룹 (Connection Group)</p><ul id="2b2655e8-3169-8064-bcad-c596d86914f7" class="bulleted-list"><li style="list-style-type:disc"><strong>설정 매개변수:</strong> <code>connectionGroupSize</code></li></ul><ul id="2b2655e8-3169-806c-8216-e97f48c43564" class="bulleted-list"><li style="list-style-type:disc"><strong>역할:</strong> 이 이벤트 그룹은 <strong>클라이언트로부터의 연결을 수락</strong>하는 역할을 수행합니다.</li></ul><p id="2b2655e8-3169-80b4-8285-cf21d466af51" class="">2. 워커 그룹 (Worker Group)</p><ul id="2b2655e8-3169-8041-b43d-f26fd72b8c61" class="bulleted-list"><li style="list-style-type:disc"><strong>설정 매개변수:</strong> <code>workerGroupSize</code></li></ul><ul id="2b2655e8-3169-806a-ad6a-c97966e6afe9" class="bulleted-list"><li style="list-style-type:disc"><strong>역할:</strong> 이 그룹은 연결을 처리하고, 메시지를 파싱하며, <strong>엔진의 내부 작업</strong>을 수행하는 데 사용되는 이벤트 그룹의 크기를 지정합니다.</li></ul><p id="2b2655e8-3169-8052-8c16-f4fb7e331c4d" class="">3. 호출 그룹 (Call Group)</p><ul id="2b2655e8-3169-8065-8c0b-e456157e795d" class="bulleted-list"><li style="list-style-type:disc"><strong>설정 매개변수:</strong> <code>callGroupSize</code></li></ul><ul id="2b2655e8-3169-800c-bbdd-fcbc80413a82" class="bulleted-list"><li style="list-style-type:disc"><strong>역할:</strong> 이 그룹은 <strong>실제 애플리케이션 코드를 실행</strong>하는 데 사용되는 이벤트 그룹의 크기를 지정합니다. Ktor의 라우트 핸들러 내의 코루틴이 이 스레드 풀 위에서 실행됩니다.</li></ul><p id="2b2655e8-3169-807b-8c1b-e916c93c6bfd" class=""><strong>성능 최적화의 중요성 (호출 그룹 관리)</strong></p><p id="2b2655e8-3169-8087-85e0-dc14bf8cca19" class="">이 세 그룹의 크기를 조정하는 것은 애플리케이션의 특정 요구 사항에 따라 서버의 처리량과 응답성을 최적화할 수 있도록 합니다. 특히 **호출 그룹(Call Group)**의 관리가 Ktor 서버 성능에 가장 중요합니다:</p><p id="2b2655e8-3169-801a-9e15-f1d26d520f01" class="">1. <strong>기본 설정의 위험성:</strong> Ktor 엔진은 일반적으로 사용 가능한 프로세서 수(CPU 코어 수)를 기준으로 이 그룹들의 기본 크기를 할당합니다. 예를 들어, 단일 CPU 환경에서 <code>callGroupSize</code>가 1로 설정될 경우, 한 번에 하나의 애플리케이션 작업만 실행될 수 있습니다.</p><p id="2b2655e8-3169-8047-b856-fc837d60068a" class="">2. <strong>스레드 블로킹 문제:</strong> Ktor는 코루틴을 기반으로 하지만, 만약 라우트 핸들러 내에서 <strong>블로킹 I/O 작업</strong> (예: JDBC 데이터베이스 호출, 대용량 파일 처리, <code>Thread.sleep()</code> 등)이 발생하면, 코루틴을 실행하는 Call Group의 스레드가 갇히게 됩니다.</p><p id="2b2655e8-3169-8022-b143-ca03d867793c" class="">3. <strong>응답성 저하:</strong> Call Group의 스레드가 블로킹되면, 서버의 제한된 워커 스레드 풀(엔진 스레드 풀)이 고갈되어 다른 요청(예: 헬스 체크)을 처리하지 못하고 서버의 응답성과 가용성(Liveness)이 치명적으로 저하될 수 있습니다.</p><p id="2b2655e8-3169-808e-bba9-cc506d8771a0" class="">4. <strong>해결책 (I/O 오프로딩):</strong> 서버의 응답성을 보호하고 기본 스레드 풀을 해제 상태로 유지하기 위해서는, 모든 블로킹 I/O 코드는 반드시 <code>withContext(Dispatchers.IO) { ... }</code> 블록으로 감싸서 <strong>Dispatchers.IO</strong>라는 별도의, 더 큰 스레드 풀로 작업을 오프로딩해야 합니다. 이렇게 하면 Call Group 스레드는 블로킹되지 않고 다른 요청을 처리할 수 있게 됩니다.</p><p id="2b2655e8-3169-809f-928c-f8bb7799d5b7" class=""><strong>구성 예시</strong></p><p id="2b2655e8-3169-802c-957e-cd37a0e82fec" class="">다음 코드는 Netty 엔진을 사용하여 이 세 가지 그룹의 크기를 명시적으로 설정하는 예시를 보여줍니다:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-802f-beda-c2168c22ba5b" class="code code-wrap"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">fun main() {
    embeddedServer(Netty, port = 8080, configure = {
        connectionGroupSize = 4 // 연결 수락 스레드 수 [1]
        workerGroupSize = 8     // 엔진 내부 처리 스레드 수 [1]
        callGroupSize = 16      // 애플리케이션 로직 실행 스레드 수 [1]
    }) {
        // Application modules
    }.start(wait = true)
}</code></pre><h3 id="2b2655e8-3169-80c3-9619-cec15d2d1c16" class="">✔ “호출 그룹(Caller group)” = <strong>코루틴이 어느 Job 계층에 속해 있는가 (Structured Concurrency의 부모·자식 관계)</strong></h3><p id="2b2655e8-3169-80d5-be45-dc35def38ca5" class="">→ 예외 전파, 취소 전파, 부모-자식 lifecycle 관리를 담당</p><p id="2b2655e8-3169-805a-aeb0-dc03e337c22b" class="">→ <strong>논리적 그룹(논리적 트리 구조)</strong></p><h3 id="2b2655e8-3169-8078-bc02-fc9720084080" class="">✔ “워커 그룹(Worker group)” = <strong>코루틴이 실제로 어느 스레드풀(Dispatchers)에 실행되는가</strong></h3><p id="2b2655e8-3169-801d-92a1-e670f7f93e47" class="">→ 실행 장소(스레드 풀)</p><p id="2b2655e8-3169-8090-9d60-d998144a4df6" class="">→ <strong>물리적 그룹(실행 환경)</strong></p><h1 id="2b2655e8-3169-80e6-a3c6-e312d2a41a49" class="">🔥 진짜 이해하기 쉽게 비유해볼게</h1><h3 id="2b2655e8-3169-80ec-ae75-e589267fae57" class="">🎭 1) 호출 그룹(Caller Group) = “수업 반”</h3><ul id="2b2655e8-3169-8041-85d1-d8f6bf9aaa99" class="bulleted-list"><li style="list-style-type:disc">같은 반 학생들은 한 명이 문제를 일으키면 담임(부모)이 반 전체를 책임져야 함</li></ul><ul id="2b2655e8-3169-803a-b247-e3121f953657" class="bulleted-list"><li style="list-style-type:disc">담임이 안 오면 학생들은 집에 못 감<p id="2b2655e8-3169-8026-b2be-c009c529cb87" class="">→ lifecycle 공유</p><p id="2b2655e8-3169-80c8-96c2-ee9f39531dcb" class="">→ 예외 전파</p><p id="2b2655e8-3169-8093-900e-dc816dbdc57e" class="">→ 취소 전파</p></li></ul><p id="2b2655e8-3169-80bb-b43b-dc7b4c2180cc" class="">➡ <strong>코루틴의 Job 계층 구조(부모–자식 관계)</strong></p><hr id="2b2655e8-3169-805d-954d-d5b3f94fe2d1"/><h3 id="2b2655e8-3169-803f-aef2-d16f28c16a04" class="">🔧 2) 워커 그룹(Worker Group) = “서로 다른 교실/실습실”</h3><ul id="2b2655e8-3169-8019-8b9d-e8345a5debcc" class="bulleted-list"><li style="list-style-type:disc">같은 반 학생들이라도<ul id="2b2655e8-3169-8012-8920-fea0a75fbbd2" class="bulleted-list"><li style="list-style-type:circle">어떤 학생은 컴퓨터실에서 공부하고</li></ul><ul id="2b2655e8-3169-8027-a903-fdad5b509275" class="bulleted-list"><li style="list-style-type:circle">다른 학생은 과학실에서 실험할 수 있음</li></ul></li></ul><ul id="2b2655e8-3169-8020-ac3b-d5dc5d27ae42" class="bulleted-list"><li style="list-style-type:disc">어디서 작업하느냐는 “반”과 상관없음</li></ul><p id="2b2655e8-3169-8007-b4a1-dcd5cb30a197" class="">➡ <strong>코루틴의 Dispatchers (스레드풀)</strong></p><ul id="2b2655e8-3169-8041-af23-f1ec53cbe476" class="bulleted-list"><li style="list-style-type:disc">Dispatchers.IO</li></ul><ul id="2b2655e8-3169-8087-ad15-e2ddfafbe216" class="bulleted-list"><li style="list-style-type:disc">Dispatchers.Default</li></ul><ul id="2b2655e8-3169-8055-90af-fd5ba045f026" class="bulleted-list"><li style="list-style-type:disc">Dispatchers.Main</li></ul><ul id="2b2655e8-3169-8053-ab5d-fb70d405c196" class="bulleted-list"><li style="list-style-type:disc">newSingleThreadContext</li></ul><ul id="2b2655e8-3169-80d7-974d-d56795cd7adc" class="bulleted-list"><li style="list-style-type:disc">etc…</li></ul><hr id="2b2655e8-3169-80bb-9468-e0178d21d45d"/><h1 id="2b2655e8-3169-806e-99eb-c8bc2f37cbd9" class="">📌 핵심 차이 정리</h1><table id="2b2655e8-3169-8006-af3c-c969448a229e" class="simple-table"><thead class="simple-table-header"><tr id="2b2655e8-3169-80e1-8728-e61f72806550"><th id="}Y?e" class="simple-table-header-color simple-table-header">개념</th><th id="KcgO" class="simple-table-header-color simple-table-header">Caller Group (호출 그룹)</th><th id="y=PF" class="simple-table-header-color simple-table-header">Worker Group (워커 그룹)</th></tr></thead><tbody><tr id="2b2655e8-3169-80ae-9876-d6b055634b36"><td id="}Y?e" class="">실체</td><td id="KcgO" class="">Job, coroutineScope 계층</td><td id="y=PF" class="">Dispatcher, thread pool</td></tr><tr id="2b2655e8-3169-8086-ab18-ff1e9af86b02"><td id="}Y?e" class="">역할</td><td id="KcgO" class="">lifecycle, 취소/예외 전파</td><td id="y=PF" class="">실행 위치 결정</td></tr><tr id="2b2655e8-3169-805f-8a14-e7bf69ce9b7e"><td id="}Y?e" class="">구조</td><td id="KcgO" class="">트리 구조 (부모→자식)</td><td id="y=PF" class="">스레드 그룹 또는 스레드풀</td></tr><tr id="2b2655e8-3169-80c9-aada-c0c4454f86e3"><td id="}Y?e" class="">언제 정해짐</td><td id="KcgO" class="">코루틴 생성 시 Job</td><td id="y=PF" class="">launch/async 시 Dispatcher</td></tr><tr id="2b2655e8-3169-80a2-9be2-c9b29dc84a0a"><td id="}Y?e" class="">전파</td><td id="KcgO" class="">예외, 취소가 전파됨</td><td id="y=PF" class="">전파 없음</td></tr><tr id="2b2655e8-3169-8020-97a8-fb3ec385657f"><td id="}Y?e" class="">예</td><td id="KcgO" class="">supervisorScope, coroutineScope</td><td id="y=PF" class="">Dispatchers.IO, Default</td></tr></tbody></table><hr id="2b2655e8-3169-8023-b3d3-c6f90f5abb3c"/><h1 id="2b2655e8-3169-80af-bad0-f7fbb7b189a7" class="">🧠 이해 포인트</h1><h2 id="2b2655e8-3169-80fd-9307-d8fbd7ae464b" class="">✔ 1) 코루틴은 시작할 때 “두 가지 정보를 동시에 가진다”</h2><h3 id="2b2655e8-3169-80e2-9592-efa265d4e2f0" class="">① 어느 스코프/Job 안의 자식인가? (Caller Group)</h3><p id="2b2655e8-3169-80d6-97fc-ed56f64f22c6" class="">→ lifecycle / structured concurrency</p><h3 id="2b2655e8-3169-80ab-bea1-f129d6667509" class="">② 어느 디스패처에서 실행되는가? (Worker Group)</h3><p id="2b2655e8-3169-80a5-a34e-c60da90c816a" class="">→ 스레드 선택</p><p id="2b2655e8-3169-80c8-a648-d1cd4ca6250d" class="">둘은 서로 완전히 <strong>독립적</strong>이다.</p><hr id="2b2655e8-3169-8095-ae41-d14e2f30f828"/><h1 id="2b2655e8-3169-8030-b08a-ec5bfc2a0f41" class="">⚡ 예시로 확실하게 이해해보자</h1><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-80df-9eee-cb9b24aa3b7a" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">coroutineScope { // 호출 그룹 (부모)
    launch(Dispatchers.IO) {  // 워커 그룹은 IO
        // 실행은 IO 스레드에서
        // lifecycle은 이 스코프에 종속됨
    }

    launch(Dispatchers.Default) {  // 워커 그룹은 Default
        // 실행은 Default 풀에서
        // lifecycle은 똑같이 부모에게 종속됨
    }
}

</code></pre><h3 id="2b2655e8-3169-8040-bf10-e5b393b79f12" class="">결과:</h3><ul id="2b2655e8-3169-80a0-a16a-df9bc6e5b257" class="bulleted-list"><li style="list-style-type:disc">실행 장소는 다름 (IO vs Default) ← 워커 그룹 차이</li></ul><ul id="2b2655e8-3169-805f-840a-e26bc70c97bf" class="bulleted-list"><li style="list-style-type:disc">하지만 둘 다 같은 부모 스코프의 자식임 ← 호출 그룹 동일<ul id="2b2655e8-3169-8048-9cb0-e4c2c693141b" class="bulleted-list"><li style="list-style-type:circle">하나가 오류 → 부모 취소 → 다른 작업도 취소됨</li></ul></li></ul><p id="2b2655e8-3169-80ef-aae6-ee73ce8ad021" class="">즉:</p><ul id="2b2655e8-3169-808f-a83a-de4052b3d0c5" class="bulleted-list"><li style="list-style-type:disc"><strong>호출 그룹은 논리적 통합</strong></li></ul><ul id="2b2655e8-3169-8085-9220-fd44a582669f" class="bulleted-list"><li style="list-style-type:disc"><strong>워커 그룹은 물리적 분리</strong></li></ul><hr id="2b2655e8-3169-80b8-9f5c-d1aa334ef825"/><h1 id="2b2655e8-3169-8011-aa12-ca6837e3c169" class="">🤯 가장 중요한 문장 하나로 요약하면</h1><blockquote id="2b2655e8-3169-806d-917a-c3e9fd47387f" class="">“코루틴의 부모-자식 구조(Caller Group)는 lifecycle 관리이며,<p id="2b2655e8-3169-8097-a60a-cf536464a076" class="">코루틴이 어떤 Dispatchers에서 실행되는지(Worker Group)는 실행 위치이다.</p><p id="2b2655e8-3169-806f-a092-e90cc8bb5655" class="">둘은 서로 독립적이며, 코루틴 생성 시 두 축 모두 결정된다.”</p></blockquote><p id="2b2655e8-3169-806e-a046-c6ae9e37c8c7" class=""><strong>커넥션 그룹 = 요청이 들어오는 파이프 관리 (I/O 레이어)</strong></p><p id="2b2655e8-3169-80de-b679-da65b9a1f9b4" class=""><strong>워커 그룹 = 코루틴이 실제로 어떤 스레드에서 실행될지 관리 (Dispatcher)</strong></p><p id="2b2655e8-3169-8048-96a9-e680954fedbe" class=""><strong>호출 그룹 = 코루틴 간의 관계/취소/예외 관리 (Job 트리)</strong></p></details></li></ul><ul id="2b2655e8-3169-8049-9e64-fb3db79fc2ed" class="toggle"><li><details open=""><summary>content Negotiation</summary><h2 id="2b2655e8-3169-8064-89ee-c50738571d04" class="">Kotlin의 Content Negotiation</h2><ul id="2b2655e8-3169-806c-a0db-c501e0956934" class="bulleted-list"><li style="list-style-type:disc">*Content Negotiation(콘텐츠 협상)**은 서버와 클라이언트가 HTTP 헤더를 통해 선호하는 데이터 포맷에 합의하는 메커니즘입니다. Kotlin에서는 주로 <strong>Ktor</strong>와 <strong>Spring Boot</strong> 프레임워크를 통해 구현됩니다.</li></ul><h2 id="2b2655e8-3169-80e5-a4b8-c369849b82de" class="">기본 개념</h2><p id="2b2655e8-3169-8085-935f-f54da56d9a18" class="">Content Negotiation은 다음 HTTP 헤더들을 사용합니다:</p><p id="2b2655e8-3169-8065-8378-ea8ae7093728" class=""><strong>요청 헤더:</strong></p><ul id="2b2655e8-3169-807d-ae46-d4d2b39f858b" class="bulleted-list"><li style="list-style-type:disc"><strong>Accept</strong>: 클라이언트가 원하는 응답 포맷 (예: <code><strong>application/json</strong></code>, <code><strong>application/xml</strong></code>)</li></ul><ul id="2b2655e8-3169-801b-a57a-e84a9cd06793" class="bulleted-list"><li style="list-style-type:disc"><strong>Content-Type</strong>: 요청 본문의 포맷</li></ul><p id="2b2655e8-3169-80b6-8962-c4f316151a5f" class=""><strong>응답 헤더:</strong></p><ul id="2b2655e8-3169-8072-9e6f-c75ff31cf0ea" class="bulleted-list"><li style="list-style-type:disc"><strong>Content-Type</strong>: 실제로 반환되는 데이터 포맷</li></ul><h2 id="2b2655e8-3169-80b5-9913-d295faa636df" class="">Ktor에서의 Content Negotiation</h2><p id="2b2655e8-3169-80e0-b7c7-e2d7080d91c5" class="">Ktor는 <strong>ContentNegotiation 플러그인</strong>을 통해 자동으로 직렬화/역직렬화를 처리합니다.</p><h2 id="2b2655e8-3169-8072-b409-eac5e9337b9d" class="">설정 방법</h2><p id="2b2655e8-3169-80f6-a585-e3fb06eae115" class=""><code>kotlinfun Application.configureSerialization() {<br/>    install(ContentNegotiation) {<br/>        json()<br/>        xml()<br/>        cbor()<br/>    }<br/>}</code></p><h2 id="2b2655e8-3169-800b-8af2-d0c85c195c91" class="">데이터 수신</h2><p id="2b2655e8-3169-80e1-8ba2-f72e148863f1" class="">클라이언트가 보낸 <code><strong>Content-Type</strong></code> 헤더에 따라 자동 역직렬화됩니다:</p><p id="2b2655e8-3169-800e-96d9-dd628e8d95ff" class=""><code>kotlin@Serializable<br/>data class Customer(val id: Int, val name: String)<br/><br/>routing {<br/>    post(&quot;/customers&quot;) {<br/>        val customer = call.receive&lt;Customer&gt;()<br/>        </code><em><code>// Content-Type 헤더에 따라 자동으로 역직렬화됨</code></em><code><br/>    }<br/>}</code></p><h2 id="2b2655e8-3169-804c-83a8-d12a85f8fa26" class="">데이터 전송</h2><p id="2b2655e8-3169-8014-9a26-e2f09282c128" class="">클라이언트의 <code><strong>Accept</strong></code> 헤더에 따라 적절한 포맷으로 응답합니다:</p><p id="2b2655e8-3169-80d2-8ffa-df41a5726411" class=""><code>kotlinrouting {<br/>    get(&quot;/customers/{id}&quot;) {<br/>        val customer = Customer(1, &quot;John Doe&quot;)<br/>        call.respond(customer)<br/>        </code><em><code>// Accept 헤더를 보고 JSON, XML 등으로 직렬화</code></em><code><br/>    }<br/>}</code></p><h2 id="2b2655e8-3169-808a-896c-d2d7e3f737a3" class="">Spring Boot에서의 Content Negotiation</h2><p id="2b2655e8-3169-8010-a5f7-e36d4f5add23" class="">Spring Boot는 컨트롤러 메소드의 파라미터를 통해 content negotiation을 처리합니다:</p><p id="2b2655e8-3169-8029-9271-c5652531a8e7" class=""><code>kotlin@RestController<br/>@RequestMapping(&quot;/customers&quot;)<br/>class CustomerController {<br/>    <br/>    @GetMapping(produces = [<br/>        MediaType.APPLICATION_JSON_VALUE, <br/>        MediaType.APPLICATION_XML_VALUE<br/>    ])<br/>    fun getCustomer(): CustomerResponse {<br/>        return CustomerResponse(1, &quot;John Doe&quot;)<br/>    }<br/>}</code></p><h2 id="2b2655e8-3169-8093-9d64-e27c2ef482f8" class="">Quality Values (품질값)</h2><p id="2b2655e8-3169-8002-9279-d5bec5df0988" class="">클라이언트가 여러 포맷을 선호도와 함께 지정할 수 있습니다:</p><p id="2b2655e8-3169-8029-a251-da01b5a29e74" class=""><code>textAccept: text/html;q=0.9, application/xml;q=0.8, application/json;q=0.7</code></p><p id="2b2655e8-3169-808d-a681-e1d0ddc73c25" class="">이 경우 서버는 HTML → XML → JSON 순서로 반환을 시도합니다.</p><h2 id="2b2655e8-3169-80a7-abc6-c7444b986f8c" class="">지원하지 않는 포맷 요청 시</h2><p id="2b2655e8-3169-807d-aa50-d271cb49d4f9" class="">클라이언트가 지원하지 않는 포맷을 요청하면 <strong>406 (Not Acceptable)</strong> 상태 코드를 반환합니다.</p><h2 id="2b2655e8-3169-8040-9249-d61cdea40a86" class="">Ktor에서 여러 직렬화기 설정</h2><p id="2b2655e8-3169-802e-a673-f3db7de40864" class=""><code>kotlinrouting {<br/>    get(&quot;/report&quot;) {<br/>        val data = &quot;Report data&quot;<br/>        call.respondText(text = data, contentType = ContentType.Application.Xml)<br/>    }<br/>}</code></p><p id="2b2655e8-3169-80e1-900f-c8704f97474e" class="">선언 순서에 따라 우선순위가 결정되며, 필요시 명시적으로 <code><strong>contentType</strong></code>을 지정할 수 있습니다.</p><h2 id="2b2655e8-3169-8049-8104-c4dac03b862a" class="">베스트 프랙티스</h2><p id="2b2655e8-3169-80b3-87be-f1b66458039d" class=""><strong>표준 헤더 사용</strong>: 커스텀 헤더보다 <code><strong>Accept</strong></code>와 <code><strong>Content-Type</strong></code> 헤더를 사용하세요.</p><p id="2b2655e8-3169-80c1-8b11-c5412ac7f8dd" class=""><code><strong>Vary</strong></code><strong> 헤더 설정</strong>: 캐싱 시스템이 올바르게 작동하도록 응답에 영향을 미치는 요청 헤더를 명시합니다.</p><p id="2b2655e8-3169-804c-9b48-c1e5b98feff1" class=""><strong>Accept 헤더 없을 때 처리</strong>: Ktor와 Spring Boot 모두 기본값(보통 첫 번째 지원 포맷)을 사용합니다.</p><p id="2b2655e8-3169-8015-a89c-f1ebad19356c" class="">Content Negotiation을 통해 같은 엔드포인트에서 웹 브라우저에는 HTML을, 모바일 클라이언트에는 JSON을 제공하는 유연한 API를 구축할 수 있습니다.</p><p id="2b2655e8-3169-8054-a0fa-ed1715a4802f" class="">fun Application.configureSerialization() {</p><p id="2b2655e8-3169-801c-ae3c-d0a5dc99fe90" class="">install(ContentNegotiation) {</p><p id="2b2655e8-3169-80b8-9415-d3c7fae5d039" class="">json()</p><p id="2b2655e8-3169-8003-af14-e6706ecfc2ac" class="">xml()</p><p id="2b2655e8-3169-80b1-9996-e03d8345cfb7" class="">cbor()</p><p id="2b2655e8-3169-803c-b679-e55b4f40703e" class="">}</p><p id="2b2655e8-3169-8094-9001-c3b36063e751" class="">}</p><p id="2b2655e8-3169-809c-bca5-c22d836f3579" class="">이렇게 그냥 형식들 다 넣으면 요청올때 json이면 알아서 json으로 바꿔줘?</p><p id="2b2655e8-3169-8091-a424-c45435ea5f41" class="">네, 정확히 그렇습니다!</p><p id="2b2655e8-3169-805e-a83e-d492c0eecddd" class="">클라이언트가 요청할 때 <code><strong>Accept</strong></code> 헤더나 <code><strong>Content-Type</strong></code> 헤더를 보내면, Ktor가 자동으로 그에 맞는 형식으로 직렬화/역직렬화를 해줍니다.</p><h2 id="2b2655e8-3169-80d2-9a59-d14eea980a01" class="">요청 예시</h2><p id="2b2655e8-3169-8048-a036-cd1b2330e4eb" class=""><strong>JSON 요청:</strong></p><p id="2b2655e8-3169-8045-8425-e0d0c5d22fa1" class=""><code>textPOST /customers HTTP/1.1<br/>Content-Type: application/json<br/><br/>{&quot;id&quot;: 1, &quot;name&quot;: &quot;John Doe&quot;}</code></p><p id="2b2655e8-3169-80fb-8800-d0f4333281c6" class="">→ Ktor가 JSON으로 자동 역직렬화</p><p id="2b2655e8-3169-80ea-a7e5-e353e05f3eaa" class=""><strong>XML 요청:</strong></p><p id="2b2655e8-3169-808d-85ad-de732e9d4cd6" class=""><code>textPOST /customers HTTP/1.1<br/>Content-Type: application/xml<br/><br/>&lt;customer&gt;<br/>  &lt;id&gt;1&lt;/id&gt;<br/>  &lt;name&gt;John Doe&lt;/name&gt;<br/>&lt;/customer&gt;</code></p><p id="2b2655e8-3169-803d-820c-d1e5f58ac0ee" class="">→ Ktor가 XML로 자동 역직렬화</p><h2 id="2b2655e8-3169-807f-9b43-fd3fa3fad2d1" class="">응답 예시</h2><p id="2b2655e8-3169-8073-8331-cf834b3911dc" class=""><strong>클라이언트가 JSON을 원할 때:</strong></p><p id="2b2655e8-3169-801d-a392-da934e5f3ad5" class=""><code>textGET /customers/1 HTTP/1.1<br/>Accept: application/json</code></p><p id="2b2655e8-3169-80c4-b219-f8f2d8fc7261" class="">→ Ktor가 JSON으로 응답</p><p id="2b2655e8-3169-80fa-a564-d85bceed0b1a" class=""><strong>클라이언트가 XML을 원할 때:</strong></p><p id="2b2655e8-3169-80b6-964a-ed0399774784" class=""><code>textGET /customers/1 HTTP/1.1<br/>Accept: application/xml</code></p><p id="2b2655e8-3169-80e5-8b28-e0bf8d714fcc" class="">→ Ktor가 XML로 응답</p><h2 id="2b2655e8-3169-80ed-bcbc-e32d886b6503" class="">실제 코드 예시</h2><p id="2b2655e8-3169-80bf-880a-e53c0df5f730" class=""><code>kotlin@Serializable<br/>data class Customer(val id: Int, val name: String)<br/><br/>routing {<br/>    post(&quot;/customers&quot;) {<br/>        </code><em><code>// Content-Type 헤더를 자동으로 감지해서 역직렬화</code></em><code><br/>        val customer = call.receive&lt;Customer&gt;()<br/>        println(customer)<br/>    }<br/>    <br/>    get(&quot;/customers/{id}&quot;) {<br/>        </code><em><code>// Accept 헤더를 자동으로 감지해서 직렬화</code></em><code><br/>        val customer = Customer(1, &quot;John Doe&quot;)<br/>        call.respond(customer)<br/>    }<br/>}</code></p><h2 id="2b2655e8-3169-8003-bce9-ca842b7ce625" class="">우선순위</h2><p id="2b2655e8-3169-80cd-adee-df4b1b3ab81f" class="">여러 형식을 등록했을 때 <code><strong>Accept</strong></code> 헤더가 없으면, <strong>등록한 순서대로 첫 번째 형식</strong>이 기본값이 됩니다.</p><p id="2b2655e8-3169-8079-b4a4-caf9c859a8b9" class=""><code>kotlininstall(ContentNegotiation) {<br/>    json()      </code><em><code>// 1순위 (Accept 헤더 없을 때 기본값)</code></em><code><br/>    xml()       </code><em><code>// 2순위</code></em><code><br/>    cbor()      </code><em><code>// 3순위</code></em><code><br/>}</code></p><p id="2b2655e8-3169-8094-a595-c76a80389dff" class="">따라서 기본으로 사용하고 싶은 형식을 맨 앞에 놓으면 됩니다!</p></details></li></ul><ul id="2b2655e8-3169-80b8-8e7f-fb0393977626" class="toggle"><li><details open=""><summary><strong>Call Logging</strong></summary><p id="2b2655e8-3169-8037-932f-ec765c468716" class=""><strong>Call Logging</strong>은 Ktor 서버에 들어오는 모든 HTTP 요청과 응답을 기록하는 기능입니다. 디버깅이나 모니터링, API 사용 추적할 때 매우 유용합니다.</p><h2 id="2b2655e8-3169-80be-b22c-f5e2a5ca08a1" class="">설치 및 기본 사용</h2><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-80a0-8ee1-c9181f5da49d" class="code code-wrap"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">kotlinfun Application.configureLogging() {
    install(CallLogging) {
        level = Level.INFO
    }
}</code></pre><h2 id="2b2655e8-3169-808d-93c9-dfcb28d14b8b" class="">로그 출력 예시</h2><p id="2b2655e8-3169-8063-a762-ca97cf0e2a37" class="">서버를 실행하고 요청을 보내면 다음과 같이 로깅됩니다:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-802f-b177-e383ee10f450" class="code code-wrap"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">text2025-11-21 11:06:00.123 [main] INFO  ktor.application - 200 OK GET /customers/1
2025-11-21 11:06:01.456 [main] INFO  ktor.application - 201 Created POST /customers
2025-11-21 11:06:02.789 [main] INFO  ktor.application - 400 Bad Request POST /customers</code></pre><p id="2b2655e8-3169-80f7-84bc-f544c4b9a553" class="">
</p><h2 id="2b2655e8-3169-8050-bf1b-ec9d3e85175d" class="">더 자세한 로깅</h2><p id="2b2655e8-3169-8061-8ac5-cbc381f31a18" class="">특정 경로만 로깅하거나 요청/응답 상세 정보를 기록할 수 있습니다:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-8046-9067-fd2f3ea6f8e3" class="code code-wrap"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">kotlininstall(CallLogging) {
    level = Level.INFO
    
    // 특정 경로만 로깅
    filter { call -&gt;
        call.request.path().startsWith(&quot;/customers&quot;)
    }
    
    // 요청 전 로깅
    callBeforeRequest { call -&gt;
        println(&quot;요청: ${call.request.httpMethod} ${call.request.uri}&quot;)
        println(&quot;Headers: ${call.request.headers}&quot;)
    }
    
    // 응답 후 로깅
    callAfterResponse { call -&gt;
        println(&quot;응답: ${call.response.status}&quot;)
    }
}</code></pre><p id="2b2655e8-3169-80c0-9b94-d924a52858a7" class="">
</p><h2 id="2b2655e8-3169-8054-9832-ecd06a379bfe" class="">실제 사용 예시</h2><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-801f-b96e-d43e4bcb62c0" class="code code-wrap"><code class="language-JavaScript" style="white-space:pre-wrap;word-break:break-all">kotlinfun Application.configureSerialization() {
    install(CallLogging) {
        level = Level.INFO
    }
    
    install(ContentNegotiation) {
        json()
    }
    
    routing {
        post(&quot;/customers&quot;) {
            val customer = call.receive&lt;Customer&gt;()
            call.respond(HttpStatusCode.Created, customer)
            // 로그: 201 Created POST /customers
        }
    }
}</code></pre><p id="2b2655e8-3169-80dd-a047-cbc38e80856b" class="">
</p><h2 id="2b2655e8-3169-802c-914f-e2681e4e24df" class="">로그 레벨</h2><ul id="2b2655e8-3169-80d1-a57b-e197896dcea3" class="bulleted-list"><li style="list-style-type:disc"><strong>DEBUG</strong>: 가장 상세한 정보</li></ul><ul id="2b2655e8-3169-8088-b946-c7055f76b70f" class="bulleted-list"><li style="list-style-type:disc"><strong>INFO</strong>: 기본값, 요청/응답 상태만 표시</li></ul><ul id="2b2655e8-3169-8051-a150-e5c56f5e65d4" class="bulleted-list"><li style="list-style-type:disc"><strong>WARN</strong>: 경고 수준 이상만 표시</li></ul><ul id="2b2655e8-3169-80a7-942f-dee0967dbb03" class="bulleted-list"><li style="list-style-type:disc"><strong>ERROR</strong>: 에러만 표시</li></ul><p id="2b2655e8-3169-80bf-ba3f-c42d77a6f953" class="">개발 중에는 <strong>DEBUG</strong>나 <strong>INFO</strong>, 프로덕션에서는 <strong>WARN</strong> 이상을 권장합니다.</p><h2 id="2b2655e8-3169-8066-a967-d6ff86df352a" class="">요약</h2><p id="2b2655e8-3169-809d-9a4b-c57af533da6c" class="">Call Logging은 <strong>누가, 언제, 어떤 요청을 했고, 서버가 어떻게 응답했는지</strong> 추적하는 기능입니다. API 개발할 때 필수적인 플러그인입니다!</p></details></li></ul><ul id="2b2655e8-3169-80e3-becb-eb9c599a4318" class="toggle"><li><details open=""><summary>Caching Headers</summary><h2 id="2b2655e8-3169-8099-bd12-f9fd16720673" class="">왜 필요한가?</h2><ol type="1" id="2b2655e8-3169-8016-8c36-f8489786eafe" class="numbered-list" start="1"><li><strong>성능 향상</strong>: 같은 요청을 다시 할 때 서버에 접근하지 않고 캐시된 데이터를 사용 → 빠른 응답</li></ol><ol type="1" id="2b2655e8-3169-80c8-9003-ee480a9b2878" class="numbered-list" start="2"><li><strong>서버 부하 감소</strong>: 동일한 요청이 반복되지 않음</li></ol><ol type="1" id="2b2655e8-3169-80d8-a409-c4361a15375a" class="numbered-list" start="3"><li><strong>네트워크 대역폭 절약</strong>: 데이터를 다시 전송하지 않음</li></ol><ol type="1" id="2b2655e8-3169-8017-ac1c-d0b7570a3225" class="numbered-list" start="4"><li><strong>사용자 경험 개선</strong>: 더 빠른 페이지 로딩</li></ol><h2 id="2b2655e8-3169-8016-94f8-c66cc83ed352" class="">주요 Caching Headers</h2><p id="2b2655e8-3169-80dd-8fe7-c1e003f312eb" class=""><strong>1. Cache-Control (가장 중요)</strong></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-80b1-980a-f4a391091168" class="code code-wrap"><code class="language-undefined" style="white-space:pre-wrap;word-break:break-all">Cache-Control: max-age=3600</code></pre><p id="2b2655e8-3169-8019-9e8d-efa42301c3ba" class="">→ 3600초(1시간) 동안 캐시 유지</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-8009-a80e-d8cacd3e0e98" class="code code-wrap"><code class="language-undefined" style="white-space:pre-wrap;word-break:break-all">Cache-Control: public, max-age=86400</code></pre><p id="2b2655e8-3169-80ed-b7cc-ffc8f6b9f38a" class="">→ 모두가 접근 가능, 1일 동안 캐시</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-8015-98fa-e1c5cb127447" class="code code-wrap"><code class="language-undefined" style="white-space:pre-wrap;word-break:break-all">Cache-Control: private, max-age=1800</code></pre><p id="2b2655e8-3169-80af-9858-f1a4d16c00de" class="">→ 개인만 캐시 가능, 30분 동안 캐시</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-8021-8efb-eb7473b81803" class="code code-wrap"><code class="language-undefined" style="white-space:pre-wrap;word-break:break-all">Cache-Control: no-cache, no-store</code></pre><p id="2b2655e8-3169-806e-a4f9-dce9b5e57712" class="">→ 캐시하지 않음 (민감한 데이터)</p><p id="2b2655e8-3169-807d-b737-f9b8a839ede0" class=""><strong>2. ETag (Entity Tag)</strong></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-802e-bd09-c3c82e79fb32" class="code code-wrap"><code class="language-undefined" style="white-space:pre-wrap;word-break:break-all">ETag: &quot;33a64df551&quot;</code></pre><p id="2b2655e8-3169-80b5-a894-f16d98a1ef30" class="">→ 리소스의 버전/해시값. 리소스가 변경되면 다른 ETag 반환</p><p id="2b2655e8-3169-8010-9568-f839f7d2cbca" class=""><strong>3. Last-Modified</strong></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-8000-8d42-e49faf20e95d" class="code code-wrap"><code class="language-undefined" style="white-space:pre-wrap;word-break:break-all">Last-Modified: Wed, 21 Nov 2025 11:00:00 GMT</code></pre><p id="2b2655e8-3169-80a8-8b38-c922ae3a7b39" class="">→ 리소스가 마지막으로 수정된 시간</p><p id="2b2655e8-3169-802b-a5ec-d1a225f2ae5b" class=""><strong>4. Expires</strong></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-80ef-9550-dc6cd968cf14" class="code code-wrap"><code class="language-undefined" style="white-space:pre-wrap;word-break:break-all">Expires: Wed, 21 Nov 2025 12:00:00 GMT</code></pre><p id="2b2655e8-3169-80ac-b52e-ddcf56e3d2c6" class="">→ 절대 시간으로 캐시 만료 시점 지정 (Cache-Control이 권장됨)</p><h2 id="2b2655e8-3169-80ee-bd26-f53e8e5488c6" class="">Ktor에서 Caching Headers 설정</h2><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-80c8-92bd-e3ea196a386d" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">fun Application.configureCaching() {
    install(CachingHeaders) {
        options { call -&amp;gt;
            when {
                call.request.uri.startsWith(&quot;/static/&quot;) -&amp;gt; {
                    // 정적 파일은 1년 캐시
                    CachingOptions(CacheControl.MaxAge(maxAgeSeconds = 31536000))
                }
                call.request.uri.startsWith(&quot;/api/&quot;) -&amp;gt; {
                    // API는 5분 캐시
                    CachingOptions(CacheControl.MaxAge(maxAgeSeconds = 300))
                }
                call.request.uri.startsWith(&quot;/user/&quot;) -&amp;gt; {
                    // 개인 정보는 캐시하지 않음
                    CachingOptions(CacheControl.NoCache(CacheControl.Visibility.Private))
                }
                else -&amp;gt; null
            }
        }
    }
}</code></pre><h2 id="2b2655e8-3169-804c-be58-c4af2603df4a" class="">실제 사용 예시</h2><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-8006-b070-e07f321a0902" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">routing {
    // 자주 변하지 않는 고객 정보
    get(&quot;/customers/{id}&quot;) {
        call.caching = CachingOptions(
            CacheControl.MaxAge(maxAgeSeconds = 3600, visibility = CacheControl.Visibility.Public)
        )
        val customer = Customer(1, &quot;John Doe&quot;)
        call.respond(customer)
    }
    
    // 실시간으로 변하는 데이터
    get(&quot;/orders/live&quot;) {
        call.caching = CachingOptions(
            CacheControl.NoCache(CacheControl.Visibility.Private)
        )
        call.respond(getCurrentOrders())
    }
}</code></pre><h2 id="2b2655e8-3169-8023-bf03-e917a7afcf59" class="">클라이언트 요청/응답 흐름</h2><p id="2b2655e8-3169-804f-94ce-df0501b624a7" class=""><strong>첫 번째 요청:</strong></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-80b1-b93f-dc23441e6ee0" class="code code-wrap"><code class="language-undefined" style="white-space:pre-wrap;word-break:break-all">GET /customers/1</code></pre><p id="2b2655e8-3169-8048-b40b-eff348da255e" class="">응답:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-800a-bd16-ec4d8be576f9" class="code code-wrap"><code class="language-undefined" style="white-space:pre-wrap;word-break:break-all">HTTP/1.1 200 OK
Cache-Control: max-age=3600
Content-Type: application/json

{&quot;id&quot;: 1, &quot;name&quot;: &quot;John Doe&quot;}</code></pre><p id="2b2655e8-3169-80e6-beb8-d8fa2693bf21" class="">→ 클라이언트가 1시간 동안 이 데이터를 저장</p><p id="2b2655e8-3169-8066-b490-e7dde2d27283" class=""><strong>같은 요청을 5분 후에 다시 할 때:</strong></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-800a-addd-d9e5d8652333" class="code code-wrap"><code class="language-undefined" style="white-space:pre-wrap;word-break:break-all">GET /customers/1</code></pre><p id="2b2655e8-3169-8007-ab42-caf364edca3d" class="">→ 서버에 요청하지 않고 저장된 캐시 데이터 사용 (아직 3600초가 안 지남)</p><p id="2b2655e8-3169-80dc-ac76-c1cbca389382" class=""><strong>1시간 이상 후에 다시 요청할 때:</strong></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-801f-8130-ca1439c7aeeb" class="code code-wrap"><code class="language-undefined" style="white-space:pre-wrap;word-break:break-all">GET /customers/1</code></pre><p id="2b2655e8-3169-808c-86a8-d9f988ee5915" class="">→ 캐시가 만료되었으므로 다시 서버에 요청</p><h2 id="2b2655e8-3169-80f4-b906-f46d1bb47c17" class="">캐싱 전략</h2><table id="2b2655e8-3169-8099-9737-c4b2bfefa9bf" class="simple-table"><tbody><tr id="2b2655e8-3169-80d5-8e47-d918c0f34936"><td id="}&gt;Yy" class=""><strong>유형</strong></td><td id=":UAP" class=""><strong>max-age</strong></td><td id="~T&gt;=" class=""><strong>예시</strong></td></tr><tr id="2b2655e8-3169-8097-b523-e0d4d7bb0bde"><td id="}&gt;Yy" class="">정적 파일 (이미지, CSS, JS)</td><td id=":UAP" class="">31536000 (1년)</td><td id="~T&gt;=" class=""><code><strong>/images/logo.png</strong></code></td></tr><tr id="2b2655e8-3169-80e9-bd15-e49d6f5cb9dc"><td id="}&gt;Yy" class="">API 데이터</td><td id=":UAP" class="">300-3600 (5분~1시간)</td><td id="~T&gt;=" class=""><code><strong>/api/products</strong></code></td></tr><tr id="2b2655e8-3169-801a-b802-d1e57d2f75e5"><td id="}&gt;Yy" class="">실시간 데이터</td><td id=":UAP" class="">0 또는 no-cache</td><td id="~T&gt;=" class=""><code><strong>/api/live-stock</strong></code></td></tr><tr id="2b2655e8-3169-80e2-a6e9-fb4fa209499a"><td id="}&gt;Yy" class="">개인정보</td><td id=":UAP" class="">no-store</td><td id="~T&gt;=" class=""><code><strong>/user/profile</strong></code></td></tr></tbody></table><h2 id="2b2655e8-3169-803d-adc6-fda8f93b4186" class="">요약</h2><p id="2b2655e8-3169-807f-8ff3-c7351f3110c5" class="">Caching Headers는 **&quot;이 응답은 언제까지 다시 요청 없이 사용해도 되나?&quot;**를 클라이언트에게 알려주는 지시문입니다. 올바르게 설정하면 성능이 크게 향상됩니다!</p></details></li></ul><ul id="2b2655e8-3169-80e4-9a41-d1ff0b7d3c05" class="toggle"><li><details open=""><summary><strong>StatusPages</strong></summary><p id="2b2655e8-3169-80a7-91f2-d91a6c8c1af7" class=""><strong>Ktor의 StatusPages</strong>는 HTTP 에러(404, 500 등)나 <strong>예외 발생 시 커스텀 응답을 제공</strong>하는 플러그인입니다. 사용자 친화적인 에러 메시지를 보여줄 때 사용합니다.</p><h2 id="2b2655e8-3169-807a-8aa0-ed3c244f0cbf" class="">기본 설정</h2><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-8063-85ef-cca0e5d387dc" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">fun Application.configureStatusPages() {
    install(StatusPages) {
        status(HttpStatusCode.NotFound) { call, _ -&gt;
            call.respondText(&quot;페이지를 찾을 수 없습니다&quot;, status = HttpStatusCode.NotFound)
        }
        
        status(HttpStatusCode.Unauthorized) { call, _ -&gt;
            call.respond(HttpStatusCode.Unauthorized, &quot;인증이 필요합니다&quot;)
        }
    }
}</code></pre><h2 id="2b2655e8-3169-801c-bcbf-efaf5b4bbfd9" class="">예외 처리</h2><p id="2b2655e8-3169-8051-a29f-e9b93e26e507" class="">StatusPages는 예외를 잡아서 적절한 응답으로 변환합니다:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-80dd-9c95-f051cad891a6" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">install(StatusPages) {
    // 특정 예외 처리
    exception&amp;lt;IllegalArgumentException&amp;gt; { call, cause -&gt;
        call.respond(
            HttpStatusCode.BadRequest,
            mapOf(&quot;error&quot; to cause.message)
        )
    }
    
    // 모든 예외 처리
    exception&amp;lt;Exception&amp;gt; { call, cause -&gt;
        call.respondText(&quot;서버 오류: ${cause.message}&quot;, status = HttpStatusCode.InternalServerError)
    }
}</code></pre><h2 id="2b2655e8-3169-802a-afba-e00b11b57408" class="">실제 사용 예시</h2><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-80fb-a40e-f36724ace4d6" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">@Serializable
data class ErrorResponse(val error: String, val statusCode: Int)

fun Application.configureStatusPages() {
    install(StatusPages) {
        // 404 에러
        status(HttpStatusCode.NotFound) { call, _ -&gt;
            call.respond(
                HttpStatusCode.NotFound,
                ErrorResponse(&quot;리소스를 찾을 수 없습니다&quot;, 404)
            )
        }
        
        // 500 에러
        status(HttpStatusCode.InternalServerError) { call, _ -&gt;
            call.respond(
                HttpStatusCode.InternalServerError,
                ErrorResponse(&quot;서버 내부 오류가 발생했습니다&quot;, 500)
            )
        }
        
        // Custom 예외 처리
        exception&amp;lt;CustomerNotFoundException&amp;gt; { call, cause -&gt;
            call.respond(
                HttpStatusCode.NotFound,
                ErrorResponse(cause.message ?: &quot;고객을 찾을 수 없습니다&quot;, 404)
            )
        }
        
        exception&amp;lt;ValidationException&amp;gt; { call, cause -&gt;
            call.respond(
                HttpStatusCode.BadRequest,
                ErrorResponse(&quot;입력값이 올바르지 않습니다: ${cause.message}&quot;, 400)
            )
        }
    }
}

class CustomerNotFoundException(id: Long) : Exception(&quot;고객 #$id를 찾을 수 없습니다&quot;)
class ValidationException(msg: String) : Exception(msg)

routing {
    get(&quot;/customers/{id}&quot;) {
        val id = call.parameters[&quot;id&quot;]?.toLongOrNull()
            ?: throw ValidationException(&quot;ID는 숫자여야 합니다&quot;)
        
        val customer = getCustomer(id)
            ?: throw CustomerNotFoundException(id)
        
        call.respond(customer)
    }
}</code></pre><h2 id="2b2655e8-3169-80a8-80d2-df98db6661e7" class="">클라이언트가 받는 응답</h2><p id="2b2655e8-3169-80a1-b99b-fdf4e29cbf9f" class=""><strong>정상 요청:</strong></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-80e0-b706-d643aeaedaef" class="code code-wrap"><code class="language-undefined" style="white-space:pre-wrap;word-break:break-all">GET /customers/1

200 OK
{
  &quot;id&quot;: 1,
  &quot;name&quot;: &quot;John Doe&quot;
}</code></pre><p id="2b2655e8-3169-8036-aa59-f87a685497a1" class=""><strong>존재하지 않는 고객:</strong></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-801e-af40-d1f595eaafa7" class="code code-wrap"><code class="language-undefined" style="white-space:pre-wrap;word-break:break-all">GET /customers/999

404 Not Found
{
  &quot;error&quot;: &quot;고객 #999를 찾을 수 없습니다&quot;,
  &quot;statusCode&quot;: 404
}</code></pre><p id="2b2655e8-3169-8001-a9a2-d78dfefcc484" class=""><strong>잘못된 ID:</strong></p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-800d-bf87-f76cfca00cd2" class="code code-wrap"><code class="language-undefined" style="white-space:pre-wrap;word-break:break-all">GET /customers/abc

400 Bad Request
{
  &quot;error&quot;: &quot;입력값이 올바르지 않습니다: ID는 숫자여야 합니다&quot;,
  &quot;statusCode&quot;: 400
}</code></pre><h2 id="2b2655e8-3169-8006-9cea-c2020c7aea2c" class="">여러 상태 코드 한 번에 처리</h2><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-8083-aa4e-d9c0dbb7dbe6" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">install(StatusPages) {
    status(HttpStatusCode.BadRequest, HttpStatusCode.Unauthorized) { call, status -&gt;
        call.respond(
            status,
            ErrorResponse(status.description, status.value)
        )
    }
}</code></pre><h2 id="2b2655e8-3169-80d8-8226-ea0efd2a8c6a" class="">장점</h2><ol type="1" id="2b2655e8-3169-8026-8e01-ebd9a2621fef" class="numbered-list" start="1"><li><strong>일관된 에러 포맷</strong>: 모든 에러를 같은 형식으로 반환</li></ol><ol type="1" id="2b2655e8-3169-804c-b76e-f8cc28835285" class="numbered-list" start="2"><li><strong>깔끔한 코드</strong>: try-catch를 쓰지 않고 예외 처리 가능</li></ol><ol type="1" id="2b2655e8-3169-80a3-9994-cedc4d718cac" class="numbered-list" start="3"><li><strong>사용자 친화적</strong>: 기술적인 에러 메시지 대신 이해하기 쉬운 메시지 제공</li></ol><ol type="1" id="2b2655e8-3169-803d-8794-f3b86cdcabe3" class="numbered-list" start="4"><li><strong>로깅 가능</strong>: 에러 발생 시 로깅 추가 가능</li></ol><h2 id="2b2655e8-3169-807e-90f8-fc730b706b64" class="">로깅 추가</h2><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-80a6-a661-cfb881360fc2" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">exception&amp;lt;Exception&amp;gt; { call, cause -&gt;
    logger.error(&quot;요청 실패: ${call.request.uri}&quot;, cause)
    call.respond(
        HttpStatusCode.InternalServerError,
        ErrorResponse(&quot;서버 오류가 발생했습니다&quot;, 500)
    )
}</code></pre><h2 id="2b2655e8-3169-8013-86a0-d1270217f533" class="">요약</h2><p id="2b2655e8-3169-80dd-ab5a-f326b2c9ba80" class="">StatusPages는 <strong>에러 상황을 적절하게 처리해서 사용자에게 이해하기 쉬운 메시지를 제공</strong>하는 기능입니다. API 개발할 때 거의 필수적으로 사용하는 플러그인입니다!</p></details></li></ul><ul id="2b2655e8-3169-8088-8559-ee6e469d0c3a" class="toggle"><li><details open=""><summary>커넥션 풀링</summary><h2 id="2b2655e8-3169-808f-b478-e9e9168fd2fd" class="">커넥션 풀링이 없을 때 (비효율)</h2><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-8071-90d2-d056408d03fd" class="code code-wrap"><code class="language-undefined" style="white-space:pre-wrap;word-break:break-all">매 요청마다:
1️⃣ DB 연결 생성 (시간 소비 ⏱️)
2️⃣ 쿼리 실행
3️⃣ DB 연결 종료

요청 1000개 → 연결 생성 1000번, 종료 1000번 (매우 느림!)</code></pre><h2 id="2b2655e8-3169-80c1-96d1-d73ec553261d" class="">커넥션 풀링이 있을 때 (효율적)</h2><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-80d5-88c1-e7ae0928d8b0" class="code code-wrap"><code class="language-undefined" style="white-space:pre-wrap;word-break:break-all">시작시 한 번:
1️⃣ DB 연결 10개 미리 생성 (pool에 보관)

매 요청마다:
2️⃣ pool에서 유휴 연결 가져오기 (빠름!)
3️⃣ 쿼리 실행
4️⃣ 연결을 pool에 반환 (또 다른 요청이 사용 가능)

요청 1000개 → 같은 연결들을 재사용 (매우 빠름!)</code></pre><h2 id="2b2655e8-3169-8079-afe8-c08e8ceb2887" class="">시각적 비교</h2><h2 id="2b2655e8-3169-80ed-ba0f-e548bfd07d76" class="">커넥션 풀링 없음 ❌</h2><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-800b-81ad-e64b18797514" class="code code-wrap"><code class="language-undefined" style="white-space:pre-wrap;word-break:break-all">Request 1: Connect(1초) → Query(0.1초) → Close(1초) = 2.1초
Request 2: Connect(1초) → Query(0.1초) → Close(1초) = 2.1초
Request 3: Connect(1초) → Query(0.1초) → Close(1초) = 2.1초
...
총 시간: 2.1초 × 1000 = 2100초 (35분!)</code></pre><h2 id="2b2655e8-3169-80c5-a4d0-d3b24bc90976" class="">커넥션 풀링 있음 ✅</h2><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-80b4-87a6-cb8298a2720e" class="code code-wrap"><code class="language-undefined" style="white-space:pre-wrap;word-break:break-all">초기화: Connect × 10 = 10초

Request 1: Borrow(0.01초) → Query(0.1초) → Return(0.01초) = 0.12초
Request 2: Borrow(0.01초) → Query(0.1초) → Return(0.01초) = 0.12초
Request 3: Borrow(0.01초) → Query(0.1초) → Return(0.01초) = 0.12초
...
총 시간: 10초 + (0.12초 × 1000) = 130초 (2분)</code></pre><p id="2b2655e8-3169-80b8-bd17-e8db56b55df5" class=""><strong>16배 이상 빠름!</strong></p><h2 id="2b2655e8-3169-80bd-acf0-f8a7cdb22bde" class="">Ktor + HikariCP 설정 예시</h2><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-805a-9b15-fee09df8221d" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">// build.gradle.kts
dependencies {
    implementation(&quot;com.zaxxer:HikariCP:5.0.1&quot;)
    implementation(&quot;org.postgresql:postgresql:42.6.0&quot;)
}

// Application.kt
import com.zaxxer.hikari.HikariConfig
import com.zaxxer.hikari.HikariDataSource

fun main() {
    // HikariCP 설정 (커넥션 풀)
    val config = HikariConfig().apply {
        jdbcUrl = &quot;jdbc:postgresql://localhost:5432/mydb&quot;
        username = &quot;user&quot;
        password = &quot;password&quot;
        maximumPoolSize = 10    // 👈 최대 10개 연결
        minimumIdle = 5         // 👈 최소 5개 유휴 연결 유지
        connectionTimeout = 30000  // 30초
        idleTimeout = 600000       // 10분
        maxLifetime = 1800000      // 30분
    }
    
    val dataSource = HikariDataSource(config)
    
    // 사용
    val connection = dataSource.connection
    // 쿼리 실행...
    connection.close()  // 실제로 닫지 않고 pool에 반환
}</code></pre><h2 id="2b2655e8-3169-80b8-8320-ca2a1468bce6" class="">커넥션 풀 크기 정하기</h2><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-8004-8fca-fabc46551f96" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">val config = HikariConfig().apply {
    // 작은 서비스
    maximumPoolSize = 5
    
    // 중간 서비스
    maximumPoolSize = 10
    
    // 대규모 서비스
    maximumPoolSize = 20-50
}

// 일반적인 공식: CPU 코어 수 × 2 + 예비 = 적절한 풀 크기
// 예: 4코어 → (4 × 2) + 2 = 10</code></pre><h2 id="2b2655e8-3169-8005-8fdf-d5655bd1de54" class="">커넥션 풀 상태 모니터링</h2><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-80c5-8f97-cfa827ae7ead" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">// pool 상태 확인
println(&quot;Active connections: ${dataSource.hikariPoolMXBean.activeConnections}&quot;)
println(&quot;Idle connections: ${dataSource.hikariPoolMXBean.idleConnections}&quot;)
println(&quot;Total connections: ${dataSource.hikariPoolMXBean.totalConnections}&quot;)</code></pre><p id="2b2655e8-3169-8076-bc99-ed2ff7b5f3b7" class="">예시 출력:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-80bf-954f-c8811ff11070" class="code code-wrap"><code class="language-undefined" style="white-space:pre-wrap;word-break:break-all">Active connections: 3
Idle connections: 7
Total connections: 10</code></pre><h2 id="2b2655e8-3169-8026-a7f1-eab460b6d485" class="">실제 쿼리 실행 예시</h2><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-80a5-9c4b-d6ca584c3dad" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">fun getCustomer(id: Long): Customer? {
    val dataSource = HikariDataSource(hikariConfig)
    
    dataSource.connection.use { connection -&gt;
        // pool에서 연결을 가져옴
        val statement = connection.prepareStatement(
            &quot;SELECT id, name, email FROM customers WHERE id = ?&quot;
        )
        statement.setLong(1, id)
        
        val resultSet = statement.executeQuery()
        if (resultSet.next()) {
            return Customer(
                id = resultSet.getLong(&quot;id&quot;),
                name = resultSet.getString(&quot;name&quot;),
                email = resultSet.getString(&quot;email&quot;)
            )
        }
    }
    // connection.close() 시 실제로 닫지 않고 pool에 반환됨
    
    return null
}</code></pre><h2 id="2b2655e8-3169-80b1-9145-eb63f36e53bc" class="">커넥션 풀의 장점</h2><table id="2b2655e8-3169-8030-86d7-ce37d8500953" class="simple-table"><tbody><tr id="2b2655e8-3169-8053-bf5f-fb443645f01e"><td id="onFN" class=""><strong>장점</strong></td><td id="rDyJ" class=""><strong>설명</strong></td></tr><tr id="2b2655e8-3169-80b1-890a-f66250b1845b"><td id="onFN" class=""><strong>성능 향상</strong></td><td id="rDyJ" class="">DB 연결 생성 오버헤드 제거</td></tr><tr id="2b2655e8-3169-8083-a5b1-d9deb5686b06"><td id="onFN" class=""><strong>리소스 효율</strong></td><td id="rDyJ" class="">연결을 재사용하므로 시스템 리소스 절약</td></tr><tr id="2b2655e8-3169-80d7-b59c-e31b04e06c7f"><td id="onFN" class=""><strong>응답성 개선</strong></td><td id="rDyJ" class="">대기 시간 감소</td></tr><tr id="2b2655e8-3169-8097-969f-f4437aa686a6"><td id="onFN" class=""><strong>안정성</strong></td><td id="rDyJ" class="">많은 동시 요청 처리 가능</td></tr><tr id="2b2655e8-3169-8092-9129-ffe24b458a61"><td id="onFN" class=""><strong>연결 제한</strong></td><td id="rDyJ" class="">시스템 리소스 보호 (maxPoolSize)</td></tr></tbody></table><h2 id="2b2655e8-3169-80eb-9516-f5c3b218b528" class="">커넥션 풀의 문제점</h2><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-80c3-8511-e93e42f0715c" class="code code-wrap"><code class="language-undefined" style="white-space:pre-wrap;word-break:break-all">⚠️ 커넥션 누수 (Connection Leak)
connection을 close()하지 않으면 pool에 반환 안 됨
→ 시간이 지나면서 모든 연결이 사용 중 상태
→ 새 요청이 대기 (데드락)

해결: 항상 try-with-resources 또는 .use {} 사용
connection.use { ... }  // 자동으로 close()</code></pre><h2 id="2b2655e8-3169-8085-85a6-d69f72833ff3" class="">요약</h2><p id="2b2655e8-3169-8063-9491-f3f5cd38e0c7" class=""><strong>커넥션 풀링은:</strong></p><ul id="2b2655e8-3169-805c-850b-e1237698c9bc" class="bulleted-list"><li style="list-style-type:disc">DB 연결을 <strong>미리 여러 개 만들어서</strong> pool에 보관</li></ul><ul id="2b2655e8-3169-804d-94a6-e5c30724c1cf" class="bulleted-list"><li style="list-style-type:disc">요청할 때마다 pool에서 <strong>가져가고</strong> 사용 후 <strong>반환</strong></li></ul><ul id="2b2655e8-3169-800a-870a-e1584967b7b8" class="bulleted-list"><li style="list-style-type:disc">연결 생성/종료 오버헤드 제거</li></ul><ul id="2b2655e8-3169-80a5-b757-f1189ef8479a" class="bulleted-list"><li style="list-style-type:disc"><strong>성능이 수십 배 향상</strong>됨</li></ul><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-8040-8b9f-f91f411bf2e7" class="code code-wrap"><code class="language-undefined" style="white-space:pre-wrap;word-break:break-all">풀링 없음: 요청 → 연결 생성(느림) → 쿼리 → 종료
풀링 있음: 요청 → 기존 연결 가져가기(빠름) → 쿼리 → 반환</code></pre><p id="2b2655e8-3169-80b0-b5ad-fb8c9396c9e0" class=""><strong>현대 웹 애플리케이션에서는 필수</strong>입니다!</p></details></li></ul><ul id="2b2655e8-3169-802a-83d3-eae5a5ea3c1d" class="toggle"><li><details open=""><summary>정지지점이랑 함수 색칠</summary><ul id="2b2655e8-3169-80ff-8c48-f8211e0234d2" class="bulleted-list"><li style="list-style-type:disc">*정지지점(suspension point)**은 코루틴이 실행을 멈추고(일시중단), 나중에 다시 이어서 실행할 수 있는 <strong>특별한 함수 호출 지점</strong>입니다.</li></ul><h2 id="2b2655e8-3169-8063-8a18-c8df39432af1" class="">코루틴 함수 예시</h2><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-8077-b8a7-f62ebb74e4db" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">suspend fun download(): String {
    // 1초간 대기 (실제로 스레드를 블로킹하지 않음)
    delay(1000)           // &amp;lt;-- 정지지점(suspension point)
    // delay가 끝나면 코드 재개(이어 실행)
    return &quot;다운로드됨&quot;
}</code></pre><p id="2b2655e8-3169-80a1-b9be-c52a1cb0af4a" class="">정지지점은 <strong>suspend 함수</strong> 안에서,</p><ul id="2b2655e8-3169-801f-b369-f308f127dba4" class="bulleted-list"><li style="list-style-type:disc"><code><strong>delay()</strong></code></li></ul><ul id="2b2655e8-3169-802c-91fe-e3a841d3bdfe" class="bulleted-list"><li style="list-style-type:disc">네트워크 등 시간 걸리는 작업을 하는 <code><strong>suspend</strong></code> 함수</li></ul><ul id="2b2655e8-3169-80e9-8669-e5e8f1a63c7b" class="bulleted-list"><li style="list-style-type:disc">혹은 중단가능 블록(<code><strong>withContext</strong></code> 등) 호출 시 생깁니다.</li></ul><h2 id="2b2655e8-3169-8000-8b0b-f77faaaa23e1" class="">특징</h2><ul id="2b2655e8-3169-8054-9897-f3c0b9dc80f9" class="bulleted-list"><li style="list-style-type:disc">정지지점에서 코루틴이 멈출 수 있다가, 조건을 만족하면(대기 끝 등) 다시 진행</li></ul><ul id="2b2655e8-3169-8092-b613-ec7c06622255" class="bulleted-list"><li style="list-style-type:disc">같은 스레드에 여러 코루틴이 &quot;공정하게&quot; 번갈아 실행될 수 있게 도와줌</li></ul><ul id="2b2655e8-3169-807a-9ce0-e2a0204cc545" class="bulleted-list"><li style="list-style-type:disc"><strong>블로킹(blocking)이 아니라 suspension</strong> (자원 효율적)</li></ul><p id="2b2655e8-3169-802e-95db-cc6fa5879729" class=""><strong>정지지점이란:</strong></p><p id="2b2655e8-3169-80ce-bec3-ee887e5d6ee6" class="">코루틴의 실행을 일시정지했다가, 필요한 때(예: 네트워크 통신 완료) 다시 이어서 실행하는 &quot;포인트&quot;!</p><hr id="2b2655e8-3169-800a-a60c-d79da0a27bc2"/><h2 id="2b2655e8-3169-8095-8cde-de35cd5eb675" class="">2. 함수 색칠(Function Colouring) – 코루틴 제약사항</h2><h2 id="2b2655e8-3169-8051-a613-d6efd45b2966" class="">정의</h2><p id="2b2655e8-3169-80c2-bddd-d10ccadce9e3" class="">함수 색칠은 코드에 <em>&quot;색깔을 칠했다&quot;</em> 라는 비유에서 온 표현입니다.</p><p id="2b2655e8-3169-801d-9488-fe5722df47bb" class="">즉,</p><ul id="2b2655e8-3169-8012-abc7-d02b81cb234a" class="bulleted-list"><li style="list-style-type:disc"><strong>일반 함수</strong>(평범한 함수)는 &quot;흰색&quot;</li></ul><ul id="2b2655e8-3169-8024-b4f5-f840b3b5d487" class="bulleted-list"><li style="list-style-type:disc"><strong>중단 함수</strong>(<code><strong>suspend</strong></code>)는 &quot;파란색이나 빨간색&quot;처럼 구분된다는 뜻이에요.</li></ul><h2 id="2b2655e8-3169-8097-a11f-d1168ec86076" class="">제약사항</h2><p id="2b2655e8-3169-80f9-a675-c4631c840101" class=""><strong>핵심 규칙:</strong></p><ul id="2b2655e8-3169-8057-ac0e-c4a6eb6b8fef" class="bulleted-list"><li style="list-style-type:disc"><code><strong>suspend</strong></code> 함수(중단함수)는 오직 <code><strong>suspend</strong></code> 함수 또는 코루틴 스코프 안에서만 호출할 수 있다.</li></ul><ul id="2b2655e8-3169-803b-84f4-c342dcab8c1d" class="bulleted-list"><li style="list-style-type:disc"><strong>일반 함수 안에서 중단 함수 직접 호출 불가</strong>→ 호출하려면 코루틴 스코프(<code><strong>launch</strong></code>, <code><strong>runBlocking</strong></code> 등)로 감싸야 함</li></ul><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-8053-bc00-ff3fec0f42ea" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">suspend fun networkCall() {
    delay(1000)  // 정지지점
}

// ❌ 일반 함수에서 suspend 함수 호출 (에러 발생)
fun wrong() {
    networkCall()  // 컴파일 에러!
}

// ✅ suspend 함수에서 suspend 함수 호출 가능
suspend fun right() {
    networkCall()  // OK!
}

// ✅ 코루틴 스코프(launch 등)로 감싸면 가능
fun allowed() {
    CoroutineScope(Dispatchers.IO).launch {
        networkCall()  // OK!
    }
}</code></pre><h2 id="2b2655e8-3169-80e1-831e-cf956c8ac137" class="">함수 색칠의 실전 문제</h2><p id="2b2655e8-3169-80b2-9df8-d2f199e8dcc8" class="">코드의 일부 함수가 <code><strong>suspend</strong></code>로 바뀌면,</p><p id="2b2655e8-3169-802e-ac82-e7ee256ffc0b" class="">그 함수를 호출하는 <strong>위의 함수도 모두 suspend로 바꾸거나 launch로 감싸야 함</strong></p><p id="2b2655e8-3169-80cc-bda9-f31b27d65706" class="">→ 이게 <strong>함수 색칠 문제</strong> (suspend &quot;전염&quot; 현상)</p><h2 id="2b2655e8-3169-80ce-9bd1-fdf10b52d77e" class="">예시</h2><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-806e-997e-d7c049e2be32" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">// 초기 코드
fun getUser(id: String): User { ... }  // 일반 함수

// getUser가 네트워크 호출 추가하며 suspend로 변경
suspend fun getUser(id: String): User { ... }

// → getUser를 호출하려던 함수도 모두 suspend로 바꿔야 함!</code></pre><h2 id="2b2655e8-3169-8015-aaf9-c84ad6e9cce6" class="">색칠이 필요한 이유</h2><p id="2b2655e8-3169-8056-8bc6-c3066ccb3361" class="">코틀린 컴파일러는 &quot;정지지점이 있는 함수(suspend)&quot;와 &quot;없는 함수&quot;를 엄격하게 구분해요.</p><p id="2b2655e8-3169-8095-85a3-c314ddfa1015" class="">그래서, 일반 함수는 정지지점 지원이 안 되고,</p><p id="2b2655e8-3169-80e2-81f5-d67517c55987" class="">정지지점이 있는 suspend 함수는 오직 그 &quot;색깔&quot;을 가진 곳에서만 호출 가능.</p><hr id="2b2655e8-3169-8061-a61b-e9a5138bafb3"/><h2 id="2b2655e8-3169-801c-b4de-fb6acaf228b2" class="">요약표</h2><table id="2b2655e8-3169-80b2-8953-e8be1f83efe8" class="simple-table"><tbody><tr id="2b2655e8-3169-805d-a6e1-fef34fd85c0f"><td id="Z|Y?" class=""><strong>개념</strong></td><td id="bew=" class=""><strong>설명</strong></td><td id="&gt;{|n" class=""><strong>코드 예시</strong></td></tr><tr id="2b2655e8-3169-80ec-8e15-e08bcb4fc965"><td id="Z|Y?" class=""><strong>정지지점</strong></td><td id="bew=" class="">코루틴이 멈울 수 있는 곳</td><td id="&gt;{|n" class="">delay(), suspend 함수 호출 위치</td></tr><tr id="2b2655e8-3169-809b-b0b8-d9134bd990af"><td id="Z|Y?" class=""><strong>함수 색칠</strong></td><td id="bew=" class="">suspend 함수는 코루틴/다른 suspend 함수에서만 호출 가능</td><td id="&gt;{|n" class="">일반 함수에서는 suspend 함수 직접 호출 불가</td></tr></tbody></table><hr id="2b2655e8-3169-8060-a62a-db1677536e3b"/><h2 id="2b2655e8-3169-80d5-948c-d847a98c4994" class="">간단 리뷰 (암기 팁)</h2><ul id="2b2655e8-3169-802f-838b-ea6acfa52ca5" class="bulleted-list"><li style="list-style-type:disc"><strong>정지지점:</strong> &quot;여기서 코루틴이 멈출 수 있음!&quot;</li></ul><ul id="2b2655e8-3169-807f-9b51-e262d200a09d" class="bulleted-list"><li style="list-style-type:disc"><strong>함수 색칠:</strong> &quot;suspend는 suspend/코루틴에서만! 일반 함수에서 직접 못 써!&quot;</li></ul><p id="2b2655e8-3169-803a-9f45-d766da0f6b63" class="">혹시 더 깊은 예시나 그림 설명 원하면 말씀해주세요!</p><p id="2b2655e8-3169-80be-97b1-fffb7a97b289" class="">코루틴 공부에 흔히 헷갈리는 부분이라 복습하고 실습 많이 해보는 걸 추천해요.</p><p id="2b2655e8-3169-802b-9feb-f495483968ab" class="">(원하는 활용/실전팁도 알려드릴 수 있습니다!)</p><p id="2b2655e8-3169-80f8-b46e-ef483a37f20f" class="">학습 단계 말씀해 주시면 더 맞춤 설명도 가능해요.</p></details></li></ul><ul id="2b2655e8-3169-8096-91f9-e2a143f74321" class="toggle"><li><details open=""><summary>DB 값 변할 때마다 UI 자동 갱신 이걸 flow로 어떻게 해?</summary><p id="2b2655e8-3169-809e-9778-c848cb14812d" class="">좋아.</p><p id="2b2655e8-3169-806e-9460-c6f76e0aa661" class=""><strong>“DB 값이 바뀌면 UI가 자동으로 갱신되는 구조를 Flow로 어떻게 만들까?”</strong></p><p id="2b2655e8-3169-80d5-9d21-c22f39af549a" class="">이건 Android, KMM, Backend(reactive DB), Desktop 등에서 아주 많이 쓰는 패턴이야.</p><p id="2b2655e8-3169-806c-8a01-d7456e4b79b9" class="">아래는 <strong>DB → Flow → Repository → ViewModel → UI</strong></p><p id="2b2655e8-3169-809b-87d5-e53526e1765b" class="">이렇게 데이터가 흐르는 구조를 원리부터 예시까지 완전히 설명해줄게.</p><hr id="2b2655e8-3169-800a-b436-de06bd5842a5"/><h1 id="2b2655e8-3169-8021-a31f-f77816a993f6" class="">⭐ 핵심 개념 (완전 쉽게)</h1><h3 id="2b2655e8-3169-8020-aaa5-c2b245278066" class="">🔹 Flow는 “스트림”</h3><h3 id="2b2655e8-3169-8074-b1bd-ff52190603f0" class="">🔹 DB가 변경될 때마다 Flow에서 새로운 값을 <code>emit</code></h3><h3 id="2b2655e8-3169-8087-9178-c83fac194bb1" class="">🔹 UI는 <code>collect</code>하고 있다가 새로운 값이 오면 자동으로 반응</h3><p id="2b2655e8-3169-80fe-8a2d-ee909be2d768" class="">즉:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-808b-bc40-cdbc32cffc32" class="code code-wrap"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">DB변경  →  Flow.emit()  →  ViewModel.stateFlow 업데이트  →  UI 자동 갱신

</code></pre><hr id="2b2655e8-3169-80fd-9e69-c0014d65b93c"/><h1 id="2b2655e8-3169-8046-ac0c-ebc7f4492e3a" class="">⭐ 1) 구현하는 방법은 DB 종류에 따라 다르다</h1><h2 id="2b2655e8-3169-80af-86bb-e512bfa30f6d" class="">✔ A) Android(Room) — 공식 지원 (<strong>Flow로 바로 반환 가능</strong>)</h2><p id="2b2655e8-3169-8095-8a1d-cf2b7ea3eb65" class="">Room DAO에서 바로 Flow를 반환할 수 있어.</p><h3 id="2b2655e8-3169-807f-8e94-d331bb1575b2" class="">DAO</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-8014-abc4-ffd258aaa070" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">@Dao
interface UserDao {
    @Query(&quot;SELECT * FROM users&quot;)
    fun observeUsers(): Flow&lt;List&lt;User&gt;&gt;
}

</code></pre><p id="2b2655e8-3169-8097-8917-e3055e229bc7" class="">↳ 여기서 Room이 DB가 바뀌면 자동으로 새 Flow emission을 만들어줘.</p><h3 id="2b2655e8-3169-807c-a6cb-fe5846eb8be0" class="">Repository</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-8009-adf5-febd373707c3" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">class UserRepository(private val dao: UserDao) {
    fun observeUsers(): Flow&lt;List&lt;User&gt;&gt; = dao.observeUsers()
}

</code></pre><h3 id="2b2655e8-3169-8005-894a-d03368a0a881" class="">ViewModel</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-8004-8916-e0a293823873" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">val users = repository.observeUsers()
    .stateIn(
        viewModelScope,
        SharingStarted.WhileSubscribed(),
        emptyList()
    )

</code></pre><h3 id="2b2655e8-3169-80e3-b4a0-fcd267f2e826" class="">UI (Jetpack Compose 기준)</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-80a7-9586-e4f1f57f4fd1" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">val users by viewModel.users.collectAsState()

</code></pre><p id="2b2655e8-3169-80ef-9515-f3a81fcf8916" class="">➡ DB가 변경되면 UI 자동 업데이트 끝.</p><hr id="2b2655e8-3169-805d-9395-c57b8052202e"/><h1 id="2b2655e8-3169-8075-8092-e8e55442122b" class="">✔ B) KMM + SQLDelight — Query.asFlow() 사용</h1><p id="2b2655e8-3169-8098-b78b-dcb472832bcf" class="">SQLDelight도 Flow 기반 옵저버 패턴 있음.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-80d9-9bce-d022b9269076" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">fun observeUsers(): Flow&lt;List&lt;User&gt;&gt; =
    queries.selectAllUsers().asFlow().mapToList()

</code></pre><p id="2b2655e8-3169-8064-8932-e1c6d4e4028c" class="">이것도 DB가 변경되면 자동으로 Flow emission 발생.</p><hr id="2b2655e8-3169-8070-bbca-c74c1cd43b95"/><h1 id="2b2655e8-3169-8081-8fb4-ede97b7c05f6" class="">✔ C) Spring WebFlux / R2DBC — Flux/Flow 변환</h1><p id="2b2655e8-3169-8061-893c-c2749b4844ee" class="">Spring R2DBC는 Reactive Stream을 반환하고 Flow로 변환 가능.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-801d-a0da-c3485e64e1b7" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">fun observeUsers(): Flow&lt;User&gt; =
    userRepository.findAll().asFlow()

</code></pre><p id="2b2655e8-3169-8017-95d9-c2370e5c4c19" class="">DB 변경 시 Publisher가 새 값을 push.</p><hr id="2b2655e8-3169-8074-aa95-d10ac60462f9"/><h1 id="2b2655e8-3169-80aa-a830-fd14dd1806f6" class="">✔ D) 일반 JDBC / JPA — 직접 Flow로 감싸기</h1><p id="2b2655e8-3169-8074-bcf4-c1ca73283da3" class="">JPA는 반응형이 아니라서 “폴링 기반”으로 Flow를 만들 수 있음.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-803b-b207-e2cd75376104" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">fun observeUsers(): Flow&lt;List&lt;User&gt;&gt; = flow {
    var lastHash: Int? = null

    while (true) {
        val users = userRepository.findAll()
        val newHash = users.hashCode()

        if (lastHash != newHash) {
            emit(users)       // 새로운 값 emit
            lastHash = newHash
        }

        delay(500)            // 0.5초마다 DB 체크
    }
}

</code></pre><p id="2b2655e8-3169-80cd-8415-fe4469168fc8" class="">➡ 완전한 reactive는 아니지만 “DB가 바뀌면 UI 자동 갱신” 가능.</p><hr id="2b2655e8-3169-8048-9c6e-dcdecf66d1bc"/><h1 id="2b2655e8-3169-80c1-ac9c-ed0715812752" class="">⭐ 2) Flow가 UI에 연결되는 방식</h1><p id="2b2655e8-3169-8009-9b5a-db6238f97d07" class="">Flow는 ViewModel에서 <strong>StateFlow</strong>로 변환하는 것이 가장 일반적이야.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-8009-ac0f-f4ee7d5b8bce" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">val uiState = repository.observeUsers()
    .stateIn(
        viewModelScope,
        SharingStarted.WhileSubscribed(),
        emptyList()
    )

</code></pre><p id="2b2655e8-3169-8086-a087-f0a59a49a373" class="">UI는 항상 stateFlow를 observe하기만 하면 됨.</p><hr id="2b2655e8-3169-8007-99d0-c2f665e92e7a"/><h1 id="2b2655e8-3169-80d3-83cf-e531a5eec33b" class="">⭐ 3) Flow 기반 구조를 그림으로 표현하면:</h1><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-80ee-b607-d3fd93265cd2" class="code code-wrap"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">┌──────────┐
│   DB     │  (변경 발생)
└────┬─────┘
     │
     ▼
┌──────────────┐
│ DB → Flow     │ (Room/SQLDelight가 자동 emit)
└────┬─────────┘
     │
     ▼
┌──────────────┐
│ Repository    │ (그대로 스트림 통과)
└────┬─────────┘
     │
     ▼
┌──────────────┐
│ ViewModel 값  │ (StateFlow로 변환)
└────┬─────────┘
     │
     ▼
┌──────────────┐
│ UI Collect    │ (자동 갱신)
└──────────────┘

</code></pre><hr id="2b2655e8-3169-80b0-a789-fd027efda737"/><h1 id="2b2655e8-3169-80a1-b975-c7e7b0a5c9db" class="">⭐ 4) 네 실무 프로젝트에 적용 예시</h1><p id="2b2655e8-3169-80c5-89ce-f027ca199d3e" class="">네가 KMM, Kotlin, Android, Ktor 백엔드를 쓰니까</p><p id="2b2655e8-3169-80a1-b22d-f921f583eff8" class="">아래 구조가 거의 정답이야.</p><h3 id="2b2655e8-3169-80a6-9943-fc1ee30b7d8c" class="">❗ UPIK / While / MeTwin / Coding Platform</h3><p id="2b2655e8-3169-8087-89f9-f87175e46f55" class="">→ “포스트 목록 / 프로필 정보 / 채팅 메시지 / 투표 결과” 같은 UI들은</p><p id="2b2655e8-3169-8008-8dc2-f8c266a848c5" class="">대부분 Flow로 “자동 갱신” 가능.</p><p id="2b2655e8-3169-806c-be88-c1b4cc335ce6" class="">네가 구현한 Ktor + Android 조합 예시:</p><h3 id="2b2655e8-3169-8015-961d-f90a24628edb" class="">Repository</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-80a1-9400-d99d3d9e4097" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">class VoteRepository(
    private val local: VoteDao,
    private val remote: VoteApi
) {
    fun observeVotes(): Flow&lt;List&lt;Vote&gt;&gt; =
        local.getAllVotes()   // DB Flow
}

</code></pre><h3 id="2b2655e8-3169-80fc-9a1d-d624dbfaf405" class="">ViewModel</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-8067-991d-fab3435dbd2c" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">val votes = repository.observeVotes()
    .stateIn(viewModelScope, SharingStarted.WhileSubscribed(), emptyList())

</code></pre><h3 id="2b2655e8-3169-803a-9fbc-f7f232a0e2d2" class="">UI</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-8041-8e04-fb5d0e199878" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">val votes by viewModel.votes.collectAsState()

</code></pre><p id="2b2655e8-3169-80a4-a395-c5bef5b865a4" class="">➡ 백그라운드에서 DB 업데이트만 하면</p><p id="2b2655e8-3169-8047-8e29-ec1f3ecea794" class="">UI는 자동으로 최신 투표 리스트를 그리게 됨.</p><hr id="2b2655e8-3169-805e-ac8d-c805ccc8a066"/><h1 id="2b2655e8-3169-80bd-a00a-fc8fcaf8b513" class="">⭐ 결론</h1><p id="2b2655e8-3169-8022-8b15-fec81d6eb942" class=""><strong>Flow로 DB 변화 감지 → UI 자동 갱신</strong>은 아래처럼 한다:</p><ul id="2b2655e8-3169-8069-8022-e7832da76f81" class="bulleted-list"><li style="list-style-type:disc">Room: Query 결과 자체가 Flow</li></ul><ul id="2b2655e8-3169-808f-bf13-c5396112fcf5" class="bulleted-list"><li style="list-style-type:disc">SQLDelight: Query.asFlow()</li></ul><ul id="2b2655e8-3169-80d0-8812-f0fa1a14d150" class="bulleted-list"><li style="list-style-type:disc">R2DBC: Reactive Publisher를 Flow로 변환</li></ul><ul id="2b2655e8-3169-80c4-b61b-c822e429315f" class="bulleted-list"><li style="list-style-type:disc">JDBC/JPA: 폴링해서 Flow emit</li></ul><ul id="2b2655e8-3169-8026-bca9-fe0ddc91e6df" class="bulleted-list"><li style="list-style-type:disc">UI는 StateFlow/SharedFlow를 collect</li></ul></details></li></ul><ul id="2b2655e8-3169-808e-8ef6-dc6b75f56950" class="toggle"><li><details open=""><summary>StateFlow &amp; SharedFlow</summary><p id="2b2655e8-3169-804c-89d8-f2aaedcb2746" class="">좋아. 이 둘은 Flow의 “핫 스트림(Hot Stream)” 버전인데,</p><p id="2b2655e8-3169-80bd-bf94-c957ba109e91" class="">역할이 완전히 다르기 때문에 헷갈리면 안 돼.</p><p id="2b2655e8-3169-803f-892f-c53e35c545ec" class="">아주 명확하고 직관적으로 설명해줄게.</p><hr id="2b2655e8-3169-804a-8e80-cb2b1586a706"/><h1 id="2b2655e8-3169-8036-b6e3-ecef19e3f743" class="">⭐ 결론(깨달을 버전)</h1><h3 id="2b2655e8-3169-8078-a1ea-faca928d13fa" class="">✔ <strong>StateFlow = “항상 최신 상태를 가지고 있는 상태 저장 Flow”</strong></h3><p id="2b2655e8-3169-80ff-bfe5-dc3687f32be1" class="">(UI 상태·로그인 여부·토글 값·카운터 등)</p><h3 id="2b2655e8-3169-8032-8c5b-f4fdca22cd7f" class="">✔ <strong>SharedFlow = “여러 소비자에게 이벤트를 브로드캐스트하는 Flow”</strong></h3><p id="2b2655e8-3169-80aa-a930-e31bb4f5b84c" class="">(Toast, Navigation 이벤트, WebSocket 메시지 등)</p><hr id="2b2655e8-3169-808f-86f0-e3100a574280"/><h1 id="2b2655e8-3169-8049-810d-d3d987158a16" class="">🔥 그림으로 먼저 이해하자</h1><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-800d-8214-cf3b50fe4c18" class="code code-wrap"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">StateFlow
   ┌──────────────┐
   │   값 하나 유지 │  ← 항상 하나 존재
   └───────┬──────┘
           ↓
  구독하면 “현재 값” 바로 받음
  값이 바뀔 때마다 새 값이 나옴

SharedFlow
   ┌────────────────────┐
   │ 값 저장 X / 이벤트만 전달 │
   └───────┬───────────┘
           ↓
  구독해도 “이전 값” 못 받음
  emit된 시점부터 오는 이벤트만 받음

</code></pre><hr id="2b2655e8-3169-800b-83d1-de5fd31aae1f"/><h1 id="2b2655e8-3169-8082-820f-e232f81af78b" class="">🌟 1) StateFlow — 항상 &quot;상태&quot;를 들고 있는 Flow</h1><h3 id="2b2655e8-3169-80f9-937f-e16964f98748" class="">특징 요약</h3><ul id="2b2655e8-3169-80b7-96ca-c68bdc7bcdd1" class="bulleted-list"><li style="list-style-type:disc">항상 <strong>현재 값(current value)</strong> 1개를 저장함</li></ul><ul id="2b2655e8-3169-80a4-88a1-f7b7f9cf6854" class="bulleted-list"><li style="list-style-type:disc">구독하면 <strong>즉시 최신 값 제공</strong></li></ul><ul id="2b2655e8-3169-8037-ae94-eb9debfa7726" class="bulleted-list"><li style="list-style-type:disc">LiveData와 비슷하지만 코루틴 기반</li></ul><ul id="2b2655e8-3169-80c6-9cad-fd4f099d219f" class="bulleted-list"><li style="list-style-type:disc">UI State, 로딩 여부, 로그인 상태 등에 사용</li></ul><h3 id="2b2655e8-3169-80cf-971b-da3791855840" class="">예시</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-80e2-b4f1-f9c270d32599" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">private val _count = MutableStateFlow(0)
val count: StateFlow&lt;Int&gt; = _count

fun increment() {
    _count.value += 1
}

</code></pre><p id="2b2655e8-3169-809f-ab99-e18bf859d45f" class="">UI에서는 이렇게 받음:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-8025-91ef-e8808fe9240f" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">val count by viewModel.count.collectAsState()

</code></pre><h3 id="2b2655e8-3169-8004-9490-c303f60b5b40" class="">언제 쓰나?</h3><p id="2b2655e8-3169-800c-b121-db62b5af609f" class="">✔ UI State</p><p id="2b2655e8-3169-808c-95b0-e8e65ad75161" class="">✔ 화면 상태 모델(MVI)</p><p id="2b2655e8-3169-8098-a2e8-df2a8b6d2073" class="">✔ Form 입력값</p><p id="2b2655e8-3169-8079-99bc-f0a2ca300775" class="">✔ 로그인 상태</p><p id="2b2655e8-3169-805f-b1cf-f70438e6892f" class="">✔ 테마/설정 값</p><p id="2b2655e8-3169-80ab-a0f0-f356a5acfe29" class="">➡ “항상 최신 상태를 들고 있어야 하는 값”이 필요할 때.</p><hr id="2b2655e8-3169-8032-957b-f54ed59e97aa"/><h1 id="2b2655e8-3169-807f-87ca-e6bb8b9e917e" class="">🌟 2) SharedFlow — 이벤트/신호를 여러 관찰자에게 전파</h1><h3 id="2b2655e8-3169-8086-b241-fb592b281817" class="">특징 요약</h3><ul id="2b2655e8-3169-804d-892a-d968fabb8876" class="bulleted-list"><li style="list-style-type:disc">값 저장 안 함(기본 설정: replay=0)</li></ul><ul id="2b2655e8-3169-8077-b952-ca88fe0d21ab" class="bulleted-list"><li style="list-style-type:disc"><strong>이벤트가 발생한 순간에만 emit됨</strong></li></ul><ul id="2b2655e8-3169-807f-be3b-d83ae1747f92" class="bulleted-list"><li style="list-style-type:disc">여러 subscriber에게 동시에 보내는 브로드캐스트 Flow</li></ul><ul id="2b2655e8-3169-80f5-92e3-d8653462255a" class="bulleted-list"><li style="list-style-type:disc">StateFlow처럼 &quot;현재 값&quot;이라는 개념 없음</li></ul><h3 id="2b2655e8-3169-8047-a55c-c347e107774e" class="">기본 형태</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-80f9-beed-e836a8660b32" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">private val _events = MutableSharedFlow&lt;String&gt;()
val events = _events.asSharedFlow()

suspend fun sendEvent(msg: String) {
    _events.emit(msg)
}

</code></pre><p id="2b2655e8-3169-806d-8a58-d6ea6a6f30ef" class="">UI에서는 collect만 하면 이벤트 받을 수 있음:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-806a-a52c-d363c2332d38" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">viewModel.events.collect { event -&gt;
    showToast(event)
}

</code></pre><h3 id="2b2655e8-3169-807f-8128-ede04f533a98" class="">언제 쓰나?</h3><p id="2b2655e8-3169-80aa-aab0-d389985b79c7" class="">✔ Toast 메시지</p><p id="2b2655e8-3169-80b6-8c91-fa83d3be83db" class="">✔ Snackbar</p><p id="2b2655e8-3169-8016-9ea9-fdf3c7276695" class="">✔ Navigation 이벤트(한 번만 처리해야 하는 것)</p><p id="2b2655e8-3169-80da-9222-c93effbe8968" class="">✔ WebSocket broadcast</p><p id="2b2655e8-3169-80b8-ad4f-fb3c3ec84530" class="">✔ 채팅 메시지 실시간 push</p><p id="2b2655e8-3169-8051-b474-eb22e5ed5ac0" class="">✔ 알림 이벤트</p><p id="2b2655e8-3169-8027-9681-d22188f62444" class="">➡ “상태”가 아니라 “한 번 지나가면 끝나는 이벤트”에 사용</p><hr id="2b2655e8-3169-807a-99d2-e01f4dc23cc7"/><h1 id="2b2655e8-3169-80bd-905c-c4be39e52649" class="">🌟 핵심 차이 한 번에 요약</h1><table id="2b2655e8-3169-805f-965d-e9dc05312cb9" class="simple-table"><thead class="simple-table-header"><tr id="2b2655e8-3169-8041-9458-f76e9300134d"><th id="M&gt;Fx" class="simple-table-header-color simple-table-header">구분</th><th id="z~Y{" class="simple-table-header-color simple-table-header">StateFlow</th><th id="__zl" class="simple-table-header-color simple-table-header">SharedFlow</th></tr></thead><tbody><tr id="2b2655e8-3169-8025-ac85-e94ea496f72c"><td id="M&gt;Fx" class="">값 저장?</td><td id="z~Y{" class="">✔ 현재 값 1개 저장</td><td id="__zl" class="">❌ 기본값 저장 없음</td></tr><tr id="2b2655e8-3169-808b-b30c-fde019ace276"><td id="M&gt;Fx" class="">새로운 구독자</td><td id="z~Y{" class="">바로 최신 값 받음</td><td id="__zl" class="">emit 이후 것만 받음</td></tr><tr id="2b2655e8-3169-8097-a457-d114be219dc1"><td id="M&gt;Fx" class="">무엇에 쓰나</td><td id="z~Y{" class="">UI 상태</td><td id="__zl" class="">이벤트, 알림, 메시지</td></tr><tr id="2b2655e8-3169-8057-a209-d8b62698766e"><td id="M&gt;Fx" class="">Behavior</td><td id="z~Y{" class="">BehaviorSubject 비슷</td><td id="__zl" class="">PublishSubject 비슷</td></tr><tr id="2b2655e8-3169-80dc-8839-d349ee385ee5"><td id="M&gt;Fx" class="">replay</td><td id="z~Y{" class="">항상 1</td><td id="__zl" class="">기본 0, 커스텀 가능</td></tr></tbody></table><hr id="2b2655e8-3169-80d0-8192-fb7e86c181c4"/><h1 id="2b2655e8-3169-8036-bca1-f27a8c050959" class="">🧠 이해를 돕는 비유</h1><h3 id="2b2655e8-3169-8076-a787-c3ed8619d38b" class=""><strong>StateFlow = 현재 온도계를 계속 들고 있어서, 누구든 와서 보면 현재 온도를 알 수 있다.</strong></h3><h3 id="2b2655e8-3169-80cc-a1ec-fbd44cd7c8ff" class=""><strong>SharedFlow = 종을 울리면 주변 모두가 그 소리를 듣는다.</strong></h3><p id="2b2655e8-3169-8047-a59f-eac4e29dc137" class="">(늦게 온 사람은 못 듣는다.)</p><hr id="2b2655e8-3169-80fc-9028-d8fc3f68f133"/><h1 id="2b2655e8-3169-80e3-91d2-c478d80088cb" class="">🚀 실제 실무 패턴 예시</h1><h2 id="2b2655e8-3169-80a9-b6ac-f5aa075f2d4e" class="">1) UI 상태: StateFlow 사용</h2><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-8002-b884-ca67a0d8f49f" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">val uiState = MutableStateFlow(HomeUiState())

</code></pre><h2 id="2b2655e8-3169-804a-8836-e79dfc606e40" class="">2) 화면 이벤트: SharedFlow 사용</h2><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-8072-9c28-feb427144c6a" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">val navigationEvents = MutableSharedFlow&lt;NavigationEvent&gt;()

</code></pre><hr id="2b2655e8-3169-80e7-9598-f02a2919c446"/><h1 id="2b2655e8-3169-8092-ad64-e82bf9a6f86d" class="">⭐ 한 줄 정리</h1><blockquote id="2b2655e8-3169-803d-ae4a-f8b691e72548" class="">StateFlow = 상태를 들고 있는 Hot Flow<p id="2b2655e8-3169-80e4-b8ef-eb30b2f6c125" class=""><strong>SharedFlow = 이벤트를 여러 observer에게 전달하는 Hot Flow</strong></p></blockquote><p id="2b2655e8-3169-8005-9ac4-e71cc184f0ca" class="">둘은 목적이 완전히 다르다.</p><hr id="2b2655e8-3169-80cd-a924-d46cb0d6dfa3"/><p id="2b2655e8-3169-806f-b1ce-fd52998de5e1" class="">원하면</p><p id="2b2655e8-3169-8098-aa3c-c1b8e9bbd5b6" class="">✔ StateFlow/SharedFlow의 내부 동작 구조</p><p id="2b2655e8-3169-80df-8be8-d7b632a51e25" class="">✔ replay/buffer/catch 파라미터 설명</p><p id="2b2655e8-3169-80d9-9f4e-c9d1c4426ec3" class="">✔ MVVM + MVI 구조에서 추천 패턴</p><p id="2b2655e8-3169-8066-b01e-d31149f85d02" class="">✔ 네가 만들고 있는 프로젝트 기준으로 구조화</p></details></li></ul><ul id="2b2655e8-3169-8020-ac6f-faaaeb85eb44" class="toggle"><li><details open=""><summary>카프카는 굳이 안쓰고 코루틴으로도 다 되는거아니야?</summary><p id="2b2655e8-3169-805f-9d90-e78c62b761ab" class="">좋은 질문이고, <strong>많은 사람들이 코루틴 Flow가 너무 강력하다 보니까 “이거면 카프카 필요 없지?”라고 착각하는 포인트</strong>야.</p><p id="2b2655e8-3169-80a1-ab66-e1b4f82cb3e5" class="">근데 <strong>절대적으로 “대체 불가능한 영역”이 서로 달라서 서로 경쟁 관계가 아님.</strong></p><p id="2b2655e8-3169-80ed-aee6-e67ab5b0489d" class="">아래 설명 보면 바로 감이 온다.</p><hr id="2b2655e8-3169-8000-b76c-f1746d93a7c5"/><h1 id="2b2655e8-3169-80fd-873f-c057e97b038e" class="">⭐ 결론부터</h1><h3 id="2b2655e8-3169-80d1-83e0-c8728e36b950" class="">❌ <strong>Flow/SharedFlow/StateFlow ≠ Kafka 대체품 아님</strong></h3><h3 id="2b2655e8-3169-805a-8b57-d201201cbc63" class="">✔ <strong>Flow는 </strong><em><strong>프로세스 내부</strong></em><strong> 비동기 스트림 기술</strong></h3><h3 id="2b2655e8-3169-8071-9548-d99f6e473043" class="">✔ <strong>Kafka는 </strong><em><strong>분산 시스템 간</strong></em><strong> 데이터 파이프라인/이벤트 로그 저장소</strong></h3><p id="2b2655e8-3169-804c-a3a8-c74974dc0158" class="">즉, <strong>역할 자체가 완전 다름.</strong></p><hr id="2b2655e8-3169-8001-976f-d0fdab1a208a"/><h1 id="2b2655e8-3169-80e0-8f84-e9e80f8739ce" class="">🔥 1) Flow는 <em>앱 내부 메모리에서만</em> 동작</h1><p id="2b2655e8-3169-80d4-81c7-cc8983a1d9ff" class="">Flow는 다음 같은 특징을 가짐:</p><ul id="2b2655e8-3169-8086-ab69-daa158b56e71" class="bulleted-list"><li style="list-style-type:disc">메모리 안에서만 존재</li></ul><ul id="2b2655e8-3169-802c-b491-f8e77f8b4258" class="bulleted-list"><li style="list-style-type:disc">구독자가 있어야 emit 가능</li></ul><ul id="2b2655e8-3169-80a1-9ff4-e8eef695a9b4" class="bulleted-list"><li style="list-style-type:disc">프로세스가 종료되면 값 사라짐</li></ul><ul id="2b2655e8-3169-80ea-ba2f-d8f6be7985d4" class="bulleted-list"><li style="list-style-type:disc">다른 서버/장비/프로세스와 공유 불가</li></ul><ul id="2b2655e8-3169-8074-a1d9-d39c45531cc4" class="bulleted-list"><li style="list-style-type:disc">백프레셔 지원</li></ul><ul id="2b2655e8-3169-8060-acb8-ee7e59f4c414" class="bulleted-list"><li style="list-style-type:disc">UI, 내부 비동기 작업, DB 연결 등에 최적화됨</li></ul><p id="2b2655e8-3169-802b-95ac-c621df783dd0" class="">즉, Flow는 <strong>앱 내부에서 쓰는 작은 파이프</strong>일 뿐.</p><hr id="2b2655e8-3169-804e-9af4-d47a70248469"/><h1 id="2b2655e8-3169-809d-9332-d52022d3c7b7" class="">🔥 2) Kafka는 <em>서버 간, 데이터 센터 규모</em> 메시지 파이프라인</h1><p id="2b2655e8-3169-8017-954c-c31fa97c339a" class="">Kafka는 완전히 다른 수준의 시스템이야:</p><ul id="2b2655e8-3169-8080-b226-d3f7d04ab18b" class="bulleted-list"><li style="list-style-type:disc">디스크에 영구 저장됨 (Log-based storage)</li></ul><ul id="2b2655e8-3169-80be-8c9d-cdd1f26aa09a" class="bulleted-list"><li style="list-style-type:disc">수백만 개 메시지를 초당 처리</li></ul><ul id="2b2655e8-3169-808b-a293-c042d2099f6d" class="bulleted-list"><li style="list-style-type:disc">여러 서버/컨슈머에게 분산</li></ul><ul id="2b2655e8-3169-8061-b0ef-ddcb41b16651" class="bulleted-list"><li style="list-style-type:disc">장애 복구 가능 (replication)</li></ul><ul id="2b2655e8-3169-80f6-97a1-d6ae05d95c67" class="bulleted-list"><li style="list-style-type:disc">메시지 순서 보장</li></ul><ul id="2b2655e8-3169-80d1-adc6-e7074477581c" class="bulleted-list"><li style="list-style-type:disc">메시지 누락 없이 전달 (at-least-once)</li></ul><ul id="2b2655e8-3169-80a6-b793-f39e70a37ada" class="bulleted-list"><li style="list-style-type:disc">컨슈머 그룹 / 재처리 / OFFSET 관리</li></ul><ul id="2b2655e8-3169-80d1-8db6-d665f0ee5606" class="bulleted-list"><li style="list-style-type:disc">브로커-파티션 기반의 고성능 분산 처리</li></ul><p id="2b2655e8-3169-80cd-960d-f8ad9600a9cb" class="">즉, Kafka는</p><p id="2b2655e8-3169-80ec-be07-f7b80ac4d9be" class=""><strong>“대규모 분산 시스템을 연결하는 이벤트 스트림 저장소”</strong> 역할.</p><hr id="2b2655e8-3169-805d-8b4e-cf72be5ca38e"/><h1 id="2b2655e8-3169-8067-9a41-ca11c6bb7585" class="">⭐ Flow vs Kafka 비교표</h1><table id="2b2655e8-3169-802f-a9ae-ebf1056d4b87" class="simple-table"><thead class="simple-table-header"><tr id="2b2655e8-3169-806f-a7d8-c9b0f524860e"><th id="r&lt;W\" class="simple-table-header-color simple-table-header">항목</th><th id="yWZs" class="simple-table-header-color simple-table-header">Flow / SharedFlow</th><th id="ZkKW" class="simple-table-header-color simple-table-header">Kafka</th></tr></thead><tbody><tr id="2b2655e8-3169-8066-b9ac-c933bae34048"><td id="r&lt;W\" class="">범위</td><td id="yWZs" class="">앱 내부</td><td id="ZkKW" class="">서버·서비스 간 전체 시스템</td></tr><tr id="2b2655e8-3169-8052-ac8f-e5a2a4486a70"><td id="r&lt;W\" class="">저장</td><td id="yWZs" class="">메모리, 휘발성</td><td id="ZkKW" class="">디스크 저장, 장애 내구성</td></tr><tr id="2b2655e8-3169-80c3-92c7-d1fd91f50866"><td id="r&lt;W\" class="">영속성</td><td id="yWZs" class="">없음</td><td id="ZkKW" class="">있음</td></tr><tr id="2b2655e8-3169-80df-b1bc-e7dd37740cfb"><td id="r&lt;W\" class="">배포</td><td id="yWZs" class="">단일 프로세스</td><td id="ZkKW" class="">분산 클러스터</td></tr><tr id="2b2655e8-3169-80ce-a02f-d06638621775"><td id="r&lt;W\" class="">속도</td><td id="yWZs" class="">매우 빠름 (단일)</td><td id="ZkKW" class="">매우 빠름 (분산)</td></tr><tr id="2b2655e8-3169-806a-99f6-dd20d65df4b9"><td id="r&lt;W\" class="">소비자 스케일링</td><td id="yWZs" class="">불가능</td><td id="ZkKW" class="">컨슈머 그룹으로 무제한 확장</td></tr><tr id="2b2655e8-3169-80c2-bffb-eb797f8266b9"><td id="r&lt;W\" class="">장애 복구</td><td id="yWZs" class="">없음</td><td id="ZkKW" class="">Replica + leader/follower</td></tr><tr id="2b2655e8-3169-8064-a345-f7f432d8c363"><td id="r&lt;W\" class="">메시지 순서</td><td id="yWZs" class="">없음/제한적</td><td id="ZkKW" class="">파티션 기준 순서 보장</td></tr><tr id="2b2655e8-3169-803b-b96e-c970425850da"><td id="r&lt;W\" class="">재처리</td><td id="yWZs" class="">불가</td><td id="ZkKW" class="">offset 조절로 재처리 가능</td></tr><tr id="2b2655e8-3169-8004-86e5-d39e5f05d24a"><td id="r&lt;W\" class="">용도</td><td id="yWZs" class="">UI, 내부 이벤트, DB 연동</td><td id="ZkKW" class="">로그, 메시징, 이벤트 소싱, 데이터 파이프라인</td></tr></tbody></table><hr id="2b2655e8-3169-8095-9a80-f08bd58fd3bc"/><h1 id="2b2655e8-3169-803a-9f25-fcaeb2c45c40" class="">⭐ 예시로 더 직관적으로</h1><h3 id="2b2655e8-3169-8020-8e5f-d8a4fba94dc4" class="">📌 Flow로 가능한 일:</h3><ul id="2b2655e8-3169-80f8-8b4d-dbac92280e0c" class="bulleted-list"><li style="list-style-type:disc">버튼 클릭 이벤트 처리</li></ul><ul id="2b2655e8-3169-80bd-9bfe-d60aed01ae26" class="bulleted-list"><li style="list-style-type:disc">DB 값 변경 감지 → UI 업데이트</li></ul><ul id="2b2655e8-3169-806f-acfe-c6ea1a75e154" class="bulleted-list"><li style="list-style-type:disc">내부 비동기 데이터 스트림</li></ul><ul id="2b2655e8-3169-802c-bde3-dc8b90cad54d" class="bulleted-list"><li style="list-style-type:disc">실시간 UI 상태 관리(MVI)</li></ul><h3 id="2b2655e8-3169-80aa-acc8-f64f57b1e5ac" class="">📌 Flow로 절대 불가능한 일:</h3><ul id="2b2655e8-3169-801b-9ce9-ee743eaed81b" class="bulleted-list"><li style="list-style-type:disc">여러 서버에서 들어오는 이벤트 모으기</li></ul><ul id="2b2655e8-3169-80ad-8ff8-c298812c9681" class="bulleted-list"><li style="list-style-type:disc">1억 개 로그를 한 곳에 모으기</li></ul><ul id="2b2655e8-3169-80cc-8414-f7f857526e53" class="bulleted-list"><li style="list-style-type:disc">장애 나도 데이터 유실 없이 저장</li></ul><ul id="2b2655e8-3169-80dd-a55a-c1e2073b6615" class="bulleted-list"><li style="list-style-type:disc">서버 10대가 동시에 같은 메시지를 소비</li></ul><ul id="2b2655e8-3169-80b4-8b44-cf1e5fec0f37" class="bulleted-list"><li style="list-style-type:disc">“지난주 메시지를 다시 읽기”</li></ul><hr id="2b2655e8-3169-80a7-a18c-e293fcd9ecd5"/><h1 id="2b2655e8-3169-8060-b345-e8a85a12e56e" class="">⭐ Flow와 Kafka의 역할 차이 비유</h1><h3 id="2b2655e8-3169-80f8-87e5-e908f91fb0e5" class="">Flow</h3><blockquote id="2b2655e8-3169-8085-8ab6-f8a000aa39bd" class="">“집 안에서 사용하는 수도관(물 흐름)”</blockquote><h3 id="2b2655e8-3169-80b8-a066-cfd8369de8b6" class="">Kafka</h3><blockquote id="2b2655e8-3169-80f1-bdbe-e83b08d6195d" class="">“도시 전체를 연결하는 상수도 시스템”</blockquote><p id="2b2655e8-3169-80d1-b62b-eef5c0747d93" class="">Flow는 <strong>앱 내부</strong>의 작은 스트림</p><p id="2b2655e8-3169-800c-b26c-ec78d7954e85" class="">Kafka는 <strong>대규모 서비스 간</strong>의 스트림</p><p id="2b2655e8-3169-8049-8f0f-d6689757679e" class="">둘은 애초에 비교 대상 자체가 아님.</p><hr id="2b2655e8-3169-8078-8976-cd7d0ae22721"/><h1 id="2b2655e8-3169-80bf-aa6c-f1f68092e372" class="">⭐ 만약 너가 만들고 있는 서비스(UPIK / While / MeTwin / Coding Platform)에서는?</h1><h3 id="2b2655e8-3169-8050-890d-d861669d147f" class="">✔ 누가 새 글을 올리면 전체 유저에게 알림 보내기</h3><p id="2b2655e8-3169-8048-87c8-d6dc6a6b9eef" class="">→ Kafka (또는 Redis Stream, RabbitMQ)</p><h3 id="2b2655e8-3169-80c0-867e-c1b9e44cda2c" class="">✔ Android에서 DB 값 바뀌어서 UI 업데이트</h3><p id="2b2655e8-3169-807c-9ed8-e9d24498399b" class="">→ Flow/StateFlow</p><h3 id="2b2655e8-3169-8027-bace-c40aa89ab47e" class="">✔ Ktor 내부에서 비동기 태스크 처리</h3><p id="2b2655e8-3169-8047-973a-c96b51400db7" class="">→ Flow</p><h3 id="2b2655e8-3169-80c2-9939-ecfe87c418d8" class="">✔ 여러 마이크로서비스가 동일 이벤트를 들고 처리</h3><p id="2b2655e8-3169-8046-bc44-d2c97983f614" class="">→ Kafka</p><h3 id="2b2655e8-3169-808d-8bf6-dcafde331b35" class="">✔ 10만 명 유저에게 실시간 이벤트 브로드캐스트</h3><p id="2b2655e8-3169-809b-84f9-f5305cf621a1" class="">→ Kafka + WebSocket</p><hr id="2b2655e8-3169-80ed-a5a6-e54265b38c2a"/><h1 id="2b2655e8-3169-8094-ae38-c9d84a52843f" class="">⭐ 핵심 정리</h1><blockquote id="2b2655e8-3169-80ef-89f6-ef75ec9f7e9a" class="">Flow = 내부 비동기 스트림<p id="2b2655e8-3169-800e-b60a-fa7ff88c3fb1" class=""><strong>Kafka = 분산 이벤트 로그 시스템</strong></p></blockquote><p id="2b2655e8-3169-8062-805b-f05c972d4287" class="">Flow는 앱/서버 내부만 해결</p><p id="2b2655e8-3169-801a-a68f-c94f90b3bdaa" class="">Kafka는 데이터센터 단위의 문제를 해결</p><p id="2b2655e8-3169-80da-8803-fc06888fd329" class="">그래서 <strong>서로 대체될 수 없음.</strong></p><hr id="2b2655e8-3169-803c-8dd3-d1209b97e904"/><p id="2b2655e8-3169-80bf-b6a7-f1b1df132dd0" class="">원하면</p><ul id="2b2655e8-3169-806a-add4-cb9e982a9e46" class="bulleted-list"><li style="list-style-type:disc">Kafka → Coroutines로 consumer 구현</li></ul><ul id="2b2655e8-3169-8043-b402-d48dc9c8a05e" class="bulleted-list"><li style="list-style-type:disc">Flow로 Kafka 메시지를 consume하는 예시</li></ul><ul id="2b2655e8-3169-8096-a92c-e8b5371e252e" class="bulleted-list"><li style="list-style-type:disc">네 프로젝트에서 Kafka 필요 여부</li></ul><ul id="2b2655e8-3169-80af-b056-f49d44a1d7f0" class="bulleted-list"><li style="list-style-type:disc">Redis Stream vs Kafka vs Flow 비교</li></ul></details></li></ul><ul id="2b2655e8-3169-8021-8d8e-f328989b1e5e" class="toggle"><li><details open=""><summary>그러면 카프카를 코루틴을 이용해서 만들수도있지않을까?</summary><p id="2b2655e8-3169-8089-a9e7-fecf35187f28" class="">좋은 질문이고, <strong>많은 개발자들이 처음에는 이렇게 생각했다가 결국 “아… 그래서 Kafka가 필요한 거구나” 하고 깨닫는 포인트</strong>야.</p><p id="2b2655e8-3169-8078-a634-c1e394aab4fb" class="">결론부터 아주 명확하게 말해줄게.</p><hr id="2b2655e8-3169-80a3-9dfa-d911ff054523"/><h1 id="2b2655e8-3169-80bb-86b4-c2e668af022b" class="">⭐ 결론</h1><h3 id="2b2655e8-3169-80b6-bc8c-dd609cc90f00" class="">✔ <strong>“코루틴으로 Kafka와 비슷한 구조를 흉내낼 수는 있다.”</strong></h3><h3 id="2b2655e8-3169-80f2-8954-d4cdd2cb9474" class="">❌ <strong>하지만 절대로 Kafka의 기능을 완전 대체하는 건 불가능하다.</strong></h3><h3 id="2b2655e8-3169-809f-b0fc-e7c62a47f26b" class="">(원리적인 한계 때문에)</h3><p id="2b2655e8-3169-80ed-bcf7-d6ee85ae23b3" class="">왜 그런지 아주 현실적이고 기술적으로 설명해줄게.</p><hr id="2b2655e8-3169-80f1-b4b7-f82aeb0dc46a"/><h1 id="2b2655e8-3169-800b-a8ce-fbcc0512b2a9" class="">⭐ 1) 코루틴으로 Kafka의 “일부 기능”은 만들 수 있다</h1><p id="2b2655e8-3169-800b-80c9-fccbab1cdc6c" class="">예를 들어:</p><ul id="2b2655e8-3169-800f-b060-d1e66df61bda" class="bulleted-list"><li style="list-style-type:disc">Flow로 메시지 스트림 만들기</li></ul><ul id="2b2655e8-3169-801d-a07d-df60955b9126" class="bulleted-list"><li style="list-style-type:disc">SharedFlow로 여러 소비자에게 broadcast</li></ul><ul id="2b2655e8-3169-803b-a022-e6f6263c6240" class="bulleted-list"><li style="list-style-type:disc">Disk에 append-log 저장해서 메시지 보존</li></ul><ul id="2b2655e8-3169-8055-afe9-e4e083354423" class="bulleted-list"><li style="list-style-type:disc">파일에서 다시 읽어 재처리 구현</li></ul><ul id="2b2655e8-3169-80fa-90e0-c1e059e89736" class="bulleted-list"><li style="list-style-type:disc">백그라운드 코루틴으로 생산자/소비자 만들기</li></ul><p id="2b2655e8-3169-80a6-862a-c9a666ab4826" class="">이런 형태를 만들 수 있어:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-8004-8f5c-e85cd1ee8b5e" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">class MiniKafka {
    private val logFile = File(&quot;events.log&quot;)
    private val eventFlow = MutableSharedFlow&lt;String&gt;(replay = 0)

    suspend fun produce(event: String) {
        logFile.appendText(&quot;$event\n&quot;)
        eventFlow.emit(event)
    }

    fun consume(): Flow&lt;String&gt; = flow {
        // 로그 재처리
        logFile.forEachLine { emit(it) }

        // 이후 실시간 이벤트
        eventFlow.collect { emit(it) }
    }
}

</code></pre><p id="2b2655e8-3169-802a-9b89-c3ad4dbccbcd" class="">이러면 &quot;Kafka 짭&quot;을 하나 만드는 거지.</p><hr id="2b2655e8-3169-809d-9f9d-cc3bc44e3685"/><h1 id="2b2655e8-3169-80f4-afa5-d1840c982250" class="">⭐ 2) 그런데 “코루틴이 절대 구현할 수 없는 기능들”이 있다</h1><p id="2b2655e8-3169-80a8-88ee-ddbb90add635" class="">Kafka가 대체할 수 없는 이유는 **Kafka의 본질이 ‘분산 시스템 + 파일 기반 로그 스토리지 엔진’**이기 때문이야.</p><p id="2b2655e8-3169-80b0-a6f2-c3a9bae814fb" class="">코루틴은 <strong>스레드/비동기 문제를 해결하는 도구이지, 분산 시스템을 만드는 도구가 아님.</strong></p><hr id="2b2655e8-3169-8016-a49b-dbec8d02e479"/><h1 id="2b2655e8-3169-80dd-8046-e270a1aa446a" class="">❌ 코루틴이 절대 구현 불가능한 Kafka 특징</h1><h3 id="2b2655e8-3169-8050-acd3-cb5be0869ff0" class="">1) <strong>분산 시스템(Distributed System)</strong></h3><ul id="2b2655e8-3169-8067-a6ed-d85f0a6b4a9c" class="bulleted-list"><li style="list-style-type:disc">여러 서버에 걸쳐 파티션 분산 저장</li></ul><ul id="2b2655e8-3169-808a-b101-ef183f447213" class="bulleted-list"><li style="list-style-type:disc">Leader / Follower 구조</li></ul><ul id="2b2655e8-3169-80cc-8c73-d9f55a8c20c1" class="bulleted-list"><li style="list-style-type:disc">클러스터 구성</li></ul><ul id="2b2655e8-3169-80da-8473-f8fe5407329f" class="bulleted-list"><li style="list-style-type:disc">브로커 간 통신 및 replication</li></ul><ul id="2b2655e8-3169-80bc-b75a-cee7a56bb449" class="bulleted-list"><li style="list-style-type:disc">장애 발생 시 자동 failover</li></ul><p id="2b2655e8-3169-80e0-b8ca-c46cc08b13a3" class="">➡ 코루틴으로는 서버 간 분산 시스템을 구현할 수 없음.</p><hr id="2b2655e8-3169-8029-a874-d858cbaaa46f"/><h3 id="2b2655e8-3169-8013-ac90-e6cf1af49fbc" class="">2) <strong>고성능 디스크 기반 로그 저장(Log-based Storage Engine)</strong></h3><p id="2b2655e8-3169-80e5-bd1d-c45676f283ed" class="">Kafka는 다음을 보장함:</p><ul id="2b2655e8-3169-807b-a1b6-ffc0fb94ec63" class="bulleted-list"><li style="list-style-type:disc">Append-only 로그 구조</li></ul><ul id="2b2655e8-3169-8041-af46-f5233012b9c1" class="bulleted-list"><li style="list-style-type:disc">Zero-copy I/O</li></ul><ul id="2b2655e8-3169-8005-af16-c25ce4f07e21" class="bulleted-list"><li style="list-style-type:disc">OS Page Cache 활용</li></ul><ul id="2b2655e8-3169-8026-bed4-eac853889292" class="bulleted-list"><li style="list-style-type:disc">Segment 파일 관리</li></ul><ul id="2b2655e8-3169-80b8-b2ad-c96c066fcec4" class="bulleted-list"><li style="list-style-type:disc">Checkpoint, offset 관리</li></ul><ul id="2b2655e8-3169-80dc-84e4-de358e6aada2" class="bulleted-list"><li style="list-style-type:disc">매우 빠른 순차 디스크 쓰기</li></ul><p id="2b2655e8-3169-8070-983d-cbdf0b0d3a96" class="">Flow/SharedFlow는 모두 메모리 기반.</p><p id="2b2655e8-3169-80c3-b268-e43fdcbdf0cc" class="">디스크 기반 메시지 저장 엔진을 만들 수 없음.</p><hr id="2b2655e8-3169-8093-a296-cc000fa17b12"/><h3 id="2b2655e8-3169-80bf-bd3c-d1564961dd15" class="">3) <strong>컨슈머 그룹/Offset 관리</strong></h3><p id="2b2655e8-3169-80ec-bdfe-f2873c7cbb2b" class="">Kafka의 핵심:</p><ul id="2b2655e8-3169-80aa-8f0f-f1800fa77a89" class="bulleted-list"><li style="list-style-type:disc">그룹별 offset 추적</li></ul><ul id="2b2655e8-3169-8042-a00d-eb54d1fa5995" class="bulleted-list"><li style="list-style-type:disc">재처리(retention)</li></ul><ul id="2b2655e8-3169-805d-9528-fbb0166ea6a5" class="bulleted-list"><li style="list-style-type:disc">특정 offset부터 읽기</li></ul><ul id="2b2655e8-3169-800c-8c56-c05e5b4db5a6" class="bulleted-list"><li style="list-style-type:disc">컨슈머 분산 처리</li></ul><p id="2b2655e8-3169-8044-abfe-daf06aa12a8a" class="">이 모든 건 <strong>분산 데이터 구조 + 트랜잭션 로그 + Zookeeper(or KRaft)</strong> 덕분에 가능함.</p><p id="2b2655e8-3169-8013-a246-eb254598b486" class="">코루틴으로 offset 관리, 분산 컨슈머, 재처리 등을 직접 만드는 건</p><p id="2b2655e8-3169-807f-ad8b-e56eff67064c" class="">실제로 하면 “Kafka를 10년 동안 재구현”하는 꼴이 됨.</p><hr id="2b2655e8-3169-80cd-a69b-f80734799de8"/><h3 id="2b2655e8-3169-8031-9c8a-c878b3bfbf13" class="">4) <strong>장애에 강한 데이터 내구성(Durability)</strong></h3><p id="2b2655e8-3169-8012-b5bb-d9689aa298a3" class="">Kafka는 디스크에 메시지를 저장하고, replica를 유지하여</p><ul id="2b2655e8-3169-8023-8a3f-cf1784e1193a" class="bulleted-list"><li style="list-style-type:disc">서버가 꺼져도</li></ul><ul id="2b2655e8-3169-80fd-9596-dca1558749be" class="bulleted-list"><li style="list-style-type:disc">하나의 노드가 죽어도</li></ul><ul id="2b2655e8-3169-802c-ae79-fe73bdf06559" class="bulleted-list"><li style="list-style-type:disc">클러스터가 재시작돼도</li></ul><p id="2b2655e8-3169-800f-bfa4-ed52f8eb3178" class="">메시지를 절대 유실하지 않음.</p><p id="2b2655e8-3169-806e-8249-f6205892b846" class="">Flow는 메모리 기반이라 서버 꺼지면 모두 사라짐.</p><hr id="2b2655e8-3169-8081-8b72-fff811c4972b"/><h3 id="2b2655e8-3169-8068-b095-d1ca9836eb95" class="">5) <strong>수십만~수백만 TPS 처리량</strong></h3><p id="2b2655e8-3169-80dc-bdb8-f2b149e1e70e" class="">Kafka는 시스템 전체가 고성능 이벤트 처리에 최적화되어 있음:</p><ul id="2b2655e8-3169-80d9-83e3-e17579573636" class="bulleted-list"><li style="list-style-type:disc">배치 처리</li></ul><ul id="2b2655e8-3169-8066-81bc-fdd22f76d869" class="bulleted-list"><li style="list-style-type:disc">압축</li></ul><ul id="2b2655e8-3169-8094-a0f6-fd63a0e95017" class="bulleted-list"><li style="list-style-type:disc">전송 최적화</li></ul><ul id="2b2655e8-3169-802f-9a68-c51d1c2489ac" class="bulleted-list"><li style="list-style-type:disc">파티셔닝</li></ul><ul id="2b2655e8-3169-8052-a848-e06887b53fe6" class="bulleted-list"><li style="list-style-type:disc">Zero-copy 전송</li></ul><ul id="2b2655e8-3169-80c5-9e30-f98f12788687" class="bulleted-list"><li style="list-style-type:disc">OS 커널 레벨 튜닝</li></ul><p id="2b2655e8-3169-80a9-b6b3-e0c3b3d02db8" class="">코루틴으로는 절대 이런 성능 못냄.</p><hr id="2b2655e8-3169-80a2-b1c5-e377423d6b58"/><h1 id="2b2655e8-3169-80fe-a9a5-c5eba5eec8e1" class="">⭐ 비유로 이해하면 쉽게 끝</h1><h3 id="2b2655e8-3169-80af-955c-e7ce7770fa3c" class="">Flow / SharedFlow</h3><blockquote id="2b2655e8-3169-80aa-9b5f-c61b8ac946b1" class="">“앱 내부에서 쓰는 작은 파이프”</blockquote><h3 id="2b2655e8-3169-8042-91bb-d193e9f24261" class="">Kafka</h3><blockquote id="2b2655e8-3169-8005-9eea-c11859179929" class="">“수백만 집을 연결하는 도시 전체 수도망”</blockquote><p id="2b2655e8-3169-80af-8822-f3feabe18284" class="">코루틴으로 수도꼭지(Flow)는 만들 수 있지만</p><p id="2b2655e8-3169-80d1-811b-e2532a33f03c" class="">도시 전체 배수 시스템(Kafka)은 절대 못 만듦.</p><hr id="2b2655e8-3169-80d8-96e9-fac089f5f7cd"/><h1 id="2b2655e8-3169-8037-b165-dd7fae7065ad" class="">⭐ 결론 정리</h1><h3 id="2b2655e8-3169-8012-909d-c839d4597c86" class="">✔ <strong>코루틴으로 Kafka와 비슷한 구조를 흉내내는 ‘장난감 버전’을 만들 수는 있다.</strong></h3><h3 id="2b2655e8-3169-8060-bc79-f6fbccbccf29" class="">❌ <strong>그러나 Kafka가 제공하는 분산성, 내구성, 성능, 로그 저장 엔진, 컨슈머 그룹, 오프셋 관리 등 핵심 기능은 절대로 구현할 수 없다.</strong></h3><h3 id="2b2655e8-3169-800e-b71f-c5b1a019e403" class="">➜ 따라서 Flow/SharedFlow는 Kafka의 대체가 아니라 <strong>아예 역할이 다른 기술.</strong></h3></details></li></ul><ul id="2b2655e8-3169-809c-9171-f7cae51db75f" class="toggle"><li><details open=""><summary>Channel (Producer-Consumer)</summary><p id="2b2655e8-3169-80aa-8f06-efc146cd2a68" class="">좋은 키워드에 눈을 박았네 😏</p><p id="2b2655e8-3169-80ab-baa3-cb13f6ccc45a" class=""><code>Channel (Producer-Consumer)</code>는 코루틴 세계에서 **“안전한 큐(Queue)” + “생산자-소비자 패턴”**을 구현하는 도구라고 보면 돼.</p><p id="2b2655e8-3169-8096-9ea9-c18732997311" class="">차근차근 풀어볼게.</p><hr id="2b2655e8-3169-807b-9e7c-f76b764c2b9b"/><h2 id="2b2655e8-3169-8087-9876-fa1b90d18b32" class="">1. Producer-Consumer 패턴이 뭐냐면</h2><p id="2b2655e8-3169-80da-87d8-f3197b990250" class="">아주 고전적인 패턴이야:</p><ul id="2b2655e8-3169-8094-85ad-dd553757c008" class="bulleted-list"><li style="list-style-type:disc"><strong>Producer(생산자)</strong> : 데이터를 만들어서 어딘가에 넣는 역할</li></ul><ul id="2b2655e8-3169-802a-94da-d0a9ca2cec84" class="bulleted-list"><li style="list-style-type:disc"><strong>Consumer(소비자)</strong> : 그 데이터를 하나씩 꺼내서 처리하는 역할</li></ul><ul id="2b2655e8-3169-80f5-bf91-df3e5f2293d0" class="bulleted-list"><li style="list-style-type:disc">둘 사이에 <strong>버퍼(큐)</strong> 같은 걸 두고, 느긋하게 서로 독립적으로 돌아가게 만드는 구조</li></ul><p id="2b2655e8-3169-803b-a4d1-fe62f2d78f24" class="">예:</p><ul id="2b2655e8-3169-8064-9d6f-ee5f23b98af2" class="bulleted-list"><li style="list-style-type:disc">생산자: 메시지를 계속 생성</li></ul><ul id="2b2655e8-3169-8064-b1ac-ce322f5cf142" class="bulleted-list"><li style="list-style-type:disc">소비자: 메시지를 하나씩 처리 (속도가 느려도 괜찮음, 버퍼에 쌓였다가 처리)</li></ul><hr id="2b2655e8-3169-8044-aa59-f5a96796b531"/><h2 id="2b2655e8-3169-80f3-ba90-db55db019051" class="">2. Channel은 코루틴용 “큐”야</h2><p id="2b2655e8-3169-8023-ba0f-ca77028330ee" class="">Kotlin의 <code>Channel</code>은 <strong>코루틴끼리 데이터를 주고받는 파이프 / 큐</strong>라고 보면 돼.</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-8005-811b-f3e4623a0ad1" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">val channel = Channel&lt;Int&gt;()

// 생산자
launch {
    for (i in 1..5) {
        println(&quot;생산: $i&quot;)
        channel.send(i) // 큐에 넣기
    }
    channel.close()
}

// 소비자
launch {
    for (x in channel) { // 큐에서 꺼내기
        println(&quot;소비: $x&quot;)
    }
}

</code></pre><p id="2b2655e8-3169-8035-b0f4-c95e6ed0d4c0" class="">실행 흐름은 이런 느낌:</p><ul id="2b2655e8-3169-8061-9c86-dcdad923877e" class="bulleted-list"><li style="list-style-type:disc">Producer 코루틴: <code>send(i)</code>로 채널에 값 푸시</li></ul><ul id="2b2655e8-3169-80be-aed9-e1627ea924c3" class="bulleted-list"><li style="list-style-type:disc">Consumer 코루틴: <code>for (x in channel)</code>로 값 하나씩 꺼냄</li></ul><ul id="2b2655e8-3169-806f-a736-c7ac778c8f44" class="bulleted-list"><li style="list-style-type:disc">채널이 중간에서 “안전한 큐” 역할</li></ul><hr id="2b2655e8-3169-80bc-a866-f8bde720b476"/><h2 id="2b2655e8-3169-8085-a9b9-c30c604c22a0" class="">3. Channel이 좋은 이유</h2><h3 id="2b2655e8-3169-80fa-9f1c-d75e667399d3" class="">✅ 1) 코루틴 간 안전한 통신</h3><ul id="2b2655e8-3169-80f8-97a0-c351437c5bc9" class="bulleted-list"><li style="list-style-type:disc">스레드/락 직접 안 쓰고도 <strong>여러 코루틴이 동시에 send/receive 가능</strong></li></ul><ul id="2b2655e8-3169-80fe-971c-db1da3e15468" class="bulleted-list"><li style="list-style-type:disc">내부에서 알아서 동기화 처리해줌</li></ul><h3 id="2b2655e8-3169-806c-928f-d963c46ee6e2" class="">✅ 2) Producer/Consumer 속도가 달라도 괜찮음</h3><ul id="2b2655e8-3169-80ad-980f-c94a3cc4b13d" class="bulleted-list"><li style="list-style-type:disc">생산 속도 &gt; 소비 속도 → 채널 버퍼에 쌓임</li></ul><ul id="2b2655e8-3169-8068-abe4-c8fadc37b338" class="bulleted-list"><li style="list-style-type:disc">소비 속도 &gt; 생산 속도 → 소비자는 <code>receive()</code>에서 잠깐 “기다림”</li></ul><h3 id="2b2655e8-3169-80dc-8781-e2fb4c1f9a10" class="">✅ 3) 다양한 버퍼 전략</h3><p id="2b2655e8-3169-8077-80ed-f443f78739e3" class="">채널 생성할 때 타입을 고를 수 있어:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-8097-b154-cb284af38d08" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">Channel&lt;Int&gt;()               // 기본: Rendezvous (버퍼 없음)
Channel&lt;Int&gt;(capacity = 10)  // 버퍼 10개
Channel.CONFLATED            // 최신 값만 유지
Channel.UNLIMITED            // 이론상 무한 버퍼

</code></pre><hr id="2b2655e8-3169-8098-b284-e22e4879cefe"/><h2 id="2b2655e8-3169-80d0-bd5d-ef7e9667313c" class="">4. Channel vs Flow 차이 (이거 중요)</h2><p id="2b2655e8-3169-8099-8835-f056ee9772ed" class="">너 지금 Flow도 같이 공부 중이라 헷갈리기 딱 좋음.</p><h3 id="2b2655e8-3169-80fb-8382-d15a030a3a93" class="">🔹 Channel</h3><ul id="2b2655e8-3169-808a-9d48-fc9969f8f5f6" class="bulleted-list"><li style="list-style-type:disc"><strong>“푸시(push)” 기반</strong>: <code>send()</code> 하는 쪽이 먼저 값을 밀어 넣음</li></ul><ul id="2b2655e8-3169-8003-b817-f1cb5ea6030a" class="bulleted-list"><li style="list-style-type:disc">양방향 통신 느낌</li></ul><ul id="2b2655e8-3169-80a1-ac2f-c6810a558455" class="bulleted-list"><li style="list-style-type:disc">생산자/소비자 구조에 최적화</li></ul><ul id="2b2655e8-3169-80f2-b292-dc20a09c57eb" class="bulleted-list"><li style="list-style-type:disc">저수준 통신 primitve에 가까움<p id="2b2655e8-3169-80d2-a63e-ee2305821aac" class="">(코루틴용 큐)</p></li></ul><h3 id="2b2655e8-3169-8030-9736-c6c42251b279" class="">🔹 Flow</h3><ul id="2b2655e8-3169-8086-9ce8-f50565a466cc" class="bulleted-list"><li style="list-style-type:disc"><strong>“풀(pull)” 기반</strong>: collect가 호출되면 그때부터 값 생산</li></ul><ul id="2b2655e8-3169-80f4-a9b7-f09a78bfcee8" class="bulleted-list"><li style="list-style-type:disc">보통 단방향 데이터 스트림</li></ul><ul id="2b2655e8-3169-8075-a9bd-f74a001c3cdf" class="bulleted-list"><li style="list-style-type:disc">선언형 파이프라인 (map/filter/collect 등)</li></ul><ul id="2b2655e8-3169-806a-a75a-e6e4c48b1bad" class="bulleted-list"><li style="list-style-type:disc">고수준 스트림 처리에 적합</li></ul><p id="2b2655e8-3169-801d-b889-e12b57ad8a69" class="">실무 감각으로 정리하면:</p><blockquote id="2b2655e8-3169-805c-9e27-d8119ee099ac" class="">“Channel은 도구(Queue)고, Flow는 API 스타일(스트림)이다.”<p id="2b2655e8-3169-8060-8441-f7a3ffc2dfae" class="">Channel을 쓸 상황이면 대부분 Flow나 SharedFlow로 추상화하는 게 더 깔끔한 경우가 많음.</p></blockquote><hr id="2b2655e8-3169-8086-968d-ec2c5e1cac20"/><h2 id="2b2655e8-3169-80b6-b742-ce81d3b1cabb" class="">5. 조금 더 직관적인 비유</h2><ul id="2b2655e8-3169-8019-a9b2-d7140d7006c5" class="bulleted-list"><li style="list-style-type:disc"><strong>Channel</strong><p id="2b2655e8-3169-8059-aff5-c690b7a04cb0" class="">→ “생산 라인과 조립 라인 사이의 컨베이어 벨트”</p></li></ul><ul id="2b2655e8-3169-80a0-a93b-d886f46cfa3c" class="bulleted-list"><li style="list-style-type:disc"><strong>Producer</strong><p id="2b2655e8-3169-80e3-808b-f94e0a016b5f" class="">→ 컨베이어 위에 물건 올리는 사람</p></li></ul><ul id="2b2655e8-3169-80b7-92c6-ff0f216f6bc7" class="bulleted-list"><li style="list-style-type:disc"><strong>Consumer</strong><p id="2b2655e8-3169-8034-8199-eb41bd4766d3" class="">→ 컨베이어에서 물건 꺼내서 조립하는 사람</p></li></ul><p id="2b2655e8-3169-80f9-9483-fc33476a5119" class="">Channel은 그냥 그 <strong>벨트(중간 버퍼)</strong> 역할.</p><hr id="2b2655e8-3169-8012-a432-cbcb420f5f2b"/><h2 id="2b2655e8-3169-80d1-a657-c97901e630e1" class="">6. 언제 Channel을 직접 쓸까?</h2><p id="2b2655e8-3169-8057-b908-f88cd95af6a2" class="">요즘엔 “가능하면 Flow/StateFlow/SharedFlow 먼저 쓰고,</p><p id="2b2655e8-3169-8013-9ffe-c93298e4173e" class="">그래도 애매하면 Channel” 이런 느낌이긴 한데, 그래도 쓰는 경우:</p><ul id="2b2655e8-3169-80d0-ac9a-fc8f2e2b4c8c" class="bulleted-list"><li style="list-style-type:disc">코루틴 간 <strong>양방향 통신</strong>이 필요한 경우</li></ul><ul id="2b2655e8-3169-8027-8f01-f85bc5cb35e8" class="bulleted-list"><li style="list-style-type:disc"><strong>여러 Producer / 여러 Consumer</strong>가 같은 큐를 공유해야 할 때</li></ul><ul id="2b2655e8-3169-803d-a5c1-f8fe5317afe7" class="bulleted-list"><li style="list-style-type:disc">네가 <strong>직접 작은 메시지 큐 같은 걸 코루틴 안에서 구현할 때</strong></li></ul><ul id="2b2655e8-3169-8017-bc6d-e46437783268" class="bulleted-list"><li style="list-style-type:disc">select { } 와 같이 <strong>여러 채널 중 하나에서 오는 걸 처리</strong>할 때</li></ul></details></li></ul><ul id="2b2655e8-3169-80fb-b114-cd8d74c92e9e" class="toggle"><li><details open=""><summary>EventBus</summary><h2 id="2b2655e8-3169-803a-a7f5-cf8ab672faab" class="">⭐ EventBus가 뭐냐면</h2><p id="2b2655e8-3169-805c-9eca-e8c8874e849d" class="">한 줄로 말하면:</p><blockquote id="2b2655e8-3169-8043-a22c-eb7b153e4a97" class="">여러 곳에서 이벤트를 발행(post)하면,<br/>그 이벤트를 듣겠다고 등록한 애들한테 자동으로 알려주는 중앙 허브</blockquote><p id="2b2655e8-3169-806e-adb2-e56b032e7f6a" class="">즉, <strong>전역 Pub-Sub(발행–구독) 시스템</strong>이야.</p><ul id="2b2655e8-3169-8070-a78a-d48d713260e9" class="bulleted-list"><li style="list-style-type:disc"><strong>발행자(Producer)</strong>: “이 버튼 눌림!”, “로그인 성공!”, “알림 도착!” 같은 이벤트를 버스에 올림</li></ul><ul id="2b2655e8-3169-8020-ac43-c8b990cb5c43" class="bulleted-list"><li style="list-style-type:disc"><strong>구독자(Consumer)</strong>: “나 로그인 성공 이벤트 생기면 알려줘” 하고 구독해둠</li></ul><ul id="2b2655e8-3169-800d-b04b-c32d04dc9591" class="bulleted-list"><li style="list-style-type:disc"><strong>EventBus</strong>: 둘을 서로 모르게(의존 없이) 연결해주는 중간 허브</li></ul><hr id="2b2655e8-3169-80e1-afab-d6f3a32e30e6"/><h2 id="2b2655e8-3169-807a-b887-f5b92fcacaeb" class="">🧠 네가 이미 알고 있는 것들이랑 비교해보면</h2><h3 id="2b2655e8-3169-800f-9aec-cea2c8ebd037" class="">Channel</h3><ul id="2b2655e8-3169-8042-97b9-e1938d557100" class="bulleted-list"><li style="list-style-type:disc">채널 객체를 같이 들고 있는 <strong>코루틴 집단끼리만</strong> 통신</li></ul><ul id="2b2655e8-3169-805b-b606-d3dc66914bac" class="bulleted-list"><li style="list-style-type:disc">좀 더 “로우레벨 큐”</li></ul><h3 id="2b2655e8-3169-8029-9b18-c47896101253" class="">Flow (SharedFlow)</h3><ul id="2b2655e8-3169-80f3-988e-d617066887a2" class="bulleted-list"><li style="list-style-type:disc">스트림/상태/이벤트를 <strong>타입 안전하게</strong> 흘려보내는 고수준 API</li></ul><h3 id="2b2655e8-3169-80fa-8824-c104f32739f8" class="">EventBus</h3><ul id="2b2655e8-3169-80b6-9c9d-c43c8660eab8" class="bulleted-list"><li style="list-style-type:disc">“앱 전체 레벨에서 아무데서나 이벤트 쏘고,<p id="2b2655e8-3169-80c3-a389-eeb62a38b2b5" class="">아무데서나 들을 수 있는 <strong>전역 방송 시스템</strong>”</p></li></ul><p id="2b2655e8-3169-8062-a294-c5451178a05c" class="">느낌적으로:</p><ul id="2b2655e8-3169-808b-9510-feb882125c4b" class="bulleted-list"><li style="list-style-type:disc"><strong>Channel = point-to-point 파이프</strong></li></ul><ul id="2b2655e8-3169-80ea-8d2f-d5094b4fe525" class="bulleted-list"><li style="list-style-type:disc"><strong>EventBus = 공중파 방송국</strong></li></ul><hr id="2b2655e8-3169-807a-8e68-e88bbb3b9a68"/><h2 id="2b2655e8-3169-8081-813f-e794f176f971" class="">📡 EventBus 동작 이미지</h2><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-806e-87d4-da631a23c76f" class="code code-wrap"><code class="language-Plain Text" style="white-space:pre-wrap;word-break:break-all">[로그인 화면]  ----\
[푸시 리시버]  -----&gt;   ( EventBus )  -----&gt; [홈 화면 UI]
[백그라운드 작업] ----/                       [알림 배너]
                                               [통계 로거]

</code></pre><ul id="2b2655e8-3169-80b8-b860-dee3a42774a1" class="bulleted-list"><li style="list-style-type:disc">로그인 화면: <code>EventBus.post(LoginSuccess(userId))</code></li></ul><ul id="2b2655e8-3169-806a-b4e4-d57d8c1c3652" class="bulleted-list"><li style="list-style-type:disc">홈 화면, 알림 배너, 통계 로거 등:<p id="2b2655e8-3169-8052-b06b-c9c15e4c463f" class=""><code>EventBus.subscribe&lt;LoginSuccess&gt; { ... }</code></p></li></ul><p id="2b2655e8-3169-80f8-91d4-f87c78d88a9e" class="">발행자는 “누가 듣는지” 몰라도 되고,</p><p id="2b2655e8-3169-8059-968d-e72bfd3fff88" class="">구독자는 “누가 쏘는지” 몰라도 됨 → <strong>결합도 낮아짐</strong></p><hr id="2b2655e8-3169-8019-b63c-da8be2d301b4"/><h2 id="2b2655e8-3169-8007-9b43-d2440879e917" class="">👀 라이브러리로서의 EventBus</h2><p id="2b2655e8-3169-801c-adb6-eade6d58ac65" class="">안드로이드에서 한때 많이 썼던 게 <strong>greenrobot/EventBus</strong>, <strong>Otto</strong> 같은 것들:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-8052-a2e4-ed35220d6e8b" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">EventBus.getDefault().post(LoginSuccessEvent(user))

@Subscribe(threadMode = ThreadMode.MAIN)
fun onLoginSuccess(event: LoginSuccessEvent) {
    // UI 업데이트
}

</code></pre><p id="2b2655e8-3169-80d2-8db5-d72d43893b32" class="">이런 식으로 “어디서나 post, 어디서나 subscribe”가 됨.</p><hr id="2b2655e8-3169-8078-92ee-d287661d7a69"/><h2 id="2b2655e8-3169-80af-869e-d2736cbbf762" class="">⚠️ 근데 요즘은 왜 덜 쓰냐?</h2><p id="2b2655e8-3169-8097-9e34-d849950372c5" class=""><strong>너무 편해서 막 쓰다 보면 지옥문 열림</strong>:</p><ol type="1" id="2b2655e8-3169-8058-90ca-c3246c3deb32" class="numbered-list" start="1"><li><strong>누가 어떤 이벤트를 보내는지 추적이 힘듦</strong><p id="2b2655e8-3169-806a-b782-c1b1cfcce45c" class="">→ 코드 의존성이 숨어버림 (숨은 의존성, 스파게티)</p></li></ol><ol type="1" id="2b2655e8-3169-802f-8622-c0274cd6a52f" class="numbered-list" start="2"><li><strong>타입/이름으로만 통신하니까 구조가 느슨해지다가 망가짐</strong><p id="2b2655e8-3169-8006-9f1e-e7c3e1f06b41" class="">→ “이 이벤트 누가 듣고 있지?” 감이 안 잡힘</p></li></ol><ol type="1" id="2b2655e8-3169-80f2-b884-cde3e41c26aa" class="numbered-list" start="3"><li><strong>생명주기 관리 실수</strong><p id="2b2655e8-3169-808c-8ddb-c0259f3e48eb" class="">→ 구독 해제 안 하면 메모리 릭, 이상한 타이밍에 콜백 호출 등</p></li></ol><p id="2b2655e8-3169-80dc-838d-e259fc0f73d0" class="">그래서 요즘은:</p><ul id="2b2655e8-3169-806a-9ed3-f6d187443cbc" class="bulleted-list"><li style="list-style-type:disc">안드로이드: <code>StateFlow / SharedFlow / LiveData</code></li></ul><ul id="2b2655e8-3169-8009-b7f9-f0022fc90af3" class="bulleted-list"><li style="list-style-type:disc">서버/앱 내부: <code>Flow</code>, <code>Channel</code>, 명시적인 DI/Observer 패턴</li></ul><p id="2b2655e8-3169-80b5-9101-f573c4e57a10" class="">같은 걸로 대체하는 추세야.</p><hr id="2b2655e8-3169-80ee-91a9-cc4a146c43b6"/><h2 id="2b2655e8-3169-806e-9d05-d23718f0b9e5" class="">🔁 코루틴으로 EventBus 만들면?</h2><p id="2b2655e8-3169-8022-8db8-dca7e70c6f9c" class="">사실 SharedFlow로 이렇게 만들면 그게 곧 “EventBus”야:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-800d-942e-d0218a27cc91" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">sealed interface AppEvent {
    data class LoginSuccess(val userId: String) : AppEvent
    data object Logout : AppEvent
}

object EventBus {
    private val _events = MutableSharedFlow&lt;AppEvent&gt;()
    val events = _events.asSharedFlow()

    suspend fun post(event: AppEvent) {
        _events.emit(event)
    }
}

</code></pre><p id="2b2655e8-3169-8095-bd0f-e65daea28627" class="">구독:</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2b2655e8-3169-8077-8df6-d332503e951b" class="code code-wrap"><code class="language-Kotlin" style="white-space:pre-wrap;word-break:break-all">CoroutineScope(Dispatchers.Main).launch {
    EventBus.events.collect { event -&gt;
        when (event) {
            is AppEvent.LoginSuccess -&gt; { /* UI 업데이트 */ }
            is AppEvent.Logout -&gt; { /* 로그아웃 처리 */ }
        }
    }
}

</code></pre><p id="2b2655e8-3169-8066-9c99-f9df6def2e6a" class="">이게 **“코루틴/Flow 버전 EventBus”**라고 보면 돼.</p><hr id="2b2655e8-3169-800d-83a8-f6ea4fec582c"/><h2 id="2b2655e8-3169-80e7-9b4a-c956956d71e5" class="">✅ 정리</h2><ul id="2b2655e8-3169-8058-949c-c5a5a17f130a" class="bulleted-list"><li style="list-style-type:disc"><strong>EventBus = 전역 이벤트 허브 (Pub-Sub)</strong></li></ul><ul id="2b2655e8-3169-8081-bab2-d0b17a97ec3b" class="bulleted-list"><li style="list-style-type:disc">여러 producer → 하나의 버스 → 여러 consumer</li></ul><ul id="2b2655e8-3169-80f7-b215-ff702178a885" class="bulleted-list"><li style="list-style-type:disc">서로 직접 참조 안 하고 “이벤트로만 연결”되게 해주는 도구</li></ul><ul id="2b2655e8-3169-80b3-b696-f5eaa88d181a" class="bulleted-list"><li style="list-style-type:disc">너무 남발하면 의존성이 숨겨져서 유지보수 지옥 → 그래서 요즘은 <code>SharedFlow/StateFlow + 명시적인 구조</code> 선호</li></ul></details></li></ul><p id="2a8655e8-3169-8046-8c31-eb2e607ffe58" class="">코루틴은 스레드를 점유하지 않고, 잠깐 비워두면 다른 코루틴이 그 자리를 쓴다.</p><p id="2a8655e8-3169-80d2-ae1e-ed22cf757f44" class="">
</p><figure id="2ae655e8-3169-8011-907a-e46933dbb4ac" class="link-to-page"><a href="https://www.notion.so/2ae655e831698011907ae46933dbb4ac?pvs=21">코틀린 동시성 프로그래밍</a></figure></div></article><span class="sans" style="font-size:14px;padding-top:2em"></span></body></html>