{
  "chapters": [
    {
      "id": "coroutine-basics",
      "title": "코루틴 기초",
      "description": "코루틴의 기본 개념, suspend 함수, 코루틴 빌더를 학습합니다.",
      "lessons": [
        {
          "id": "코루틴-0",
          "title": "코루틴이란 무엇일까요?",
          "content": "코루틴은 비동기 프로그래밍을 더 쉽고 읽기 쉽게 만들어주는 경량 스레드입니다. 이 챕터에서는 코루틴의 기본 개념부터 실전 활용까지 차근차근 알아봅니다.",
          "order": 0
        },
        {
          "id": "1-코루틴-기본-개념-3",
          "title": "코루틴 기본 개념",
          "content": "코루틴(Coroutine)은 일시 중단 가능한 계산입니다. 스레드보다 훨씬 가볍고 (수천 개 동시 실행 가능), 메모리 오버헤드가 적으며, 컨텍스트 스위칭 비용이 거의 없습니다.",
          "codeExample": "suspend fun fetchUser(id: String): User {\n    delay(1000)  // 1초 대기 (스레드 블로킹 없음!)\n    return User(id, \"홍길동\")\n}",
          "initialCode": "// 코드를 여기에 작성하세요\n",
          "order": 1
        },
        {
          "id": "1-2-suspend-함수의-동작-원리-5",
          "title": "suspend 함수의 동작 원리",
          "content": "suspend 함수는 코루틴을 일시 중단할 수 있는 지점(suspension point)을 가집니다. `delay(1000)`가 호출되면 코루틴은 중단되고, 스레드는 다른 작업을 수행할 수 있습니다. 1초 후 코루틴은 원래 중단되었던 지점부터 다시 실행됩니다. 이는 스레드를 차단하는 `Thread.sleep()`과 다릅니다.",
          "codeExample": "suspend fun fetchUser(id: String): User {\n    delay(1000)  // 1초 대기 (스레드 블로킹 없음!)\n    return User(id, \"홍길동\")\n}",
          "initialCode": "// 코드를 여기에 작성하세요\n",
          "order": 2
        },
        {
          "id": "1-3-코루틴-빌더-6",
          "title": "코루틴 빌더",
          "content": "`launch`: 결과를 반환하지 않는 코루틴을 시작합니다. 'fire-and-forget' 작업에 사용됩니다.\n`async`: 결과를 반환하는 코루틴을 시작합니다. `Deferred<T>` 객체를 반환하며, `.await()`를 통해 결과를 얻을 수 있습니다.\n`runBlocking`: 현재 스레드를 차단하면서 코루틴을 실행합니다. 주로 테스트나 `main` 함수에서 코루틴 환경을 시작할 때 사용됩니다.",
          "codeExample": "GlobalScope.launch {\n    println(\"코루틴 시작\")\n    delay(1000)\n    println(\"1초 후\")\n}",
          "initialCode": "// GlobalScope.launch를 사용하여 코루틴을 시작해보세요\n// \"코루틴 시작\"을 출력하세요\n\n",
          "order": 3,
          "validation": {
            "type": "contains",
            "pattern": "GlobalScope.launch",
            "message": "정답입니다! 코루틴을 성공적으로 시작했습니다. 🎉"
          },
          "hint": "GlobalScope.launch { } 블록 안에 코드를 작성하세요."
        },
        {
          "id": "1-suspend는-비용이-0-이-아니다-81",
          "title": "suspend는 비용이 0이 아니다",
          "content": "`suspend fun`은 컴파일러가 자동으로 상태 머신(state machine) 코드로 변환합니다. 이 과정에서 현재 상태를 `Continuation` 객체로 저장하고 재개 시 복원하는 오버헤드가 발생합니다. 따라서 아주 짧은 연산(e.g., `x + y`)에 `suspend`를 붙이면 오히려 성능이 저하될 수 있습니다.",
          "order": 4
        },
        {
          "id": "82-when-to-use-suspend",
          "title": "언제 suspend를 사용해야 하는가?",
          "content": "`suspend`는 스레드를 오랫동안 점유하지만 실제 CPU 작업은 거의 없는 I/O 대기(DB 쿼리, 네트워크 요청, 파일 읽기/쓰기 등) 작업에 사용해야 가장 효과적입니다. CPU를 계속 사용하는 계산 작업에는 `suspend`를 붙이는 것이 의미가 없습니다.",
          "order": 5
        }
      ],
      "order": 0
    },
    {
      "id": "coroutine-dispatchers",
      "title": "디스패처와 컨텍스트",
      "description": "코루틴이 어떤 스레드에서 실행될지 결정하는 디스패처에 대해 학습합니다.",
      "lessons": [
        {
          "id": "2-dispatchers-상세-7",
          "title": "Dispatchers 상세",
          "content": "디스패처는 코루틴이 실행될 스레드를 결정합니다. 적절한 디스패처를 선택하는 것은 성능에 매우 중요합니다.",
          "codeExample": "suspend fun processLargeData(data: List<Int>): List<Int> =\n    withContext(Dispatchers.Default) {\n        data.map { it * 2 }  // CPU 집약적 작업\n            .sorted()\n    }",
          "initialCode": "// 코드를 여기에 작성하세요\n",
          "order": 0
        },
        {
          "id": "2-1-dispatcher-종류와-사용-시나리오-8",
          "title": "Dispatcher 종류와 사용 시나리오",
          "content": "`Dispatchers.Default`: CPU 집약적인 작업에 사용됩니다. (예: 정렬, 계산)\n`Dispatchers.IO`: 파일 읽기/쓰기, 네트워크 요청, DB 쿼리 등 I/O 작업에 사용됩니다.\n`Dispatchers.Main`: UI 스레드에서 실행됩니다. (Android/Desktop UI 작업)\n`Dispatchers.Unconfined`: 특정 스레드에 국한되지 않습니다. 예측이 어려워 일반적으로 사용하지 않습니다.",
          "codeExample": "suspend fun processLargeData(data: List<Int>): List<Int> =\n    withContext(Dispatchers.Default) {\n        data.map { it * 2 }  // CPU 집약적 작업\n            .sorted()\n    }",
          "initialCode": "// 코드를 여기에 작성하세요\n",
          "order": 1
        },
        {
          "id": "2-2-dispatcher-전환-9",
          "title": "Dispatcher 전환",
          "content": "`withContext`를 사용하면 코루틴의 실행 컨텍스트(디스패처)를 안전하게 전환할 수 있습니다. 작업의 성격에 맞는 디스패처로 전환하여 효율성을 높일 수 있습니다.",
          "codeExample": "suspend fun complexOperation() {\n    println(\"Start Thread: ${Thread.currentThread().name}\")\n\n    withContext(Dispatchers.IO) {\n        println(\"IO Thread: ${Thread.currentThread().name}\")\n        // 파일 읽기\n    }\n\n    withContext(Dispatchers.Default) {\n        println(\"Default Thread: ${Thread.currentThread().name}\")\n        // 데이터 처리\n    }\n\n    println(\"End Thread: ${Thread.currentThread().name}\")\n}",
          "initialCode": "// 코드를 여기에 작성하세요\n",
          "order": 2
        }
      ],
      "order": 1
    },
    {
      "id": "coroutine-structured-concurrency",
      "title": "구조화된 동시성",
      "description": "코루틴의 생명주기를 관리하는 구조화된 동시성에 대해 학습합니다.",
      "lessons": [
        {
          "id": "3-구조화된-동시성-11",
          "title": "구조화된 동시성 개념",
          "content": "구조화된 동시성(Structured Concurrency)은 코루틴의 생명주기를 명확하게 관리하는 원칙입니다. 부모 코루틴이 취소되면 모든 자식 코루틴도 취소되며, 부모는 모든 자식이 완료될 때까지 기다립니다. 이를 통해 리소스 누수를 방지하고 코드를 더 안전하게 만듭니다.",
          "codeExample": "suspend fun fetchUserData(userId: String): UserData = coroutineScope {\n    val userDeferred = async { fetchUser(userId) }\n    val ordersDeferred = async { fetchOrders(userId) }\n\n    UserData(\n        user = userDeferred.await(),\n        orders = ordersDeferred.await()\n    )\n}",
          "initialCode": "// 코드를 여기에 작성하세요\n",
          "order": 0
        },
        {
          "id": "3-2-coroutinescope-13",
          "title": "coroutineScope",
          "content": "`coroutineScope` 블록은 모든 자식 코루틴이 완료될 때까지 반환되지 않습니다. 또한, 하나의 자식 코루틴이 실패하면 다른 모든 자식 코루틴도 함께 취소됩니다. 여러 작업이 모두 성공해야 할 때 유용합니다.",
          "codeExample": "suspend fun fetchUserData(userId: String): UserData = coroutineScope {\n    val userDeferred = async { fetchUser(userId) }\n    val ordersDeferred = async { fetchOrders(userId) }\n\n    UserData(\n        user = userDeferred.await(),\n        orders = ordersDeferred.await()\n    )\n}",
          "initialCode": "// 코드를 여기에 작성하세요\n",
          "order": 1
        },
        {
          "id": "3-3-supervisorscope-14",
          "title": "supervisorScope",
          "content": "`supervisorScope`는 `coroutineScope`와 달리 하나의 자식 코루틴이 실패해도 다른 자식 코루틴에 영향을 주지 않습니다. 독립적인 여러 작업을 병렬로 실행하고, 일부가 실패하더라도 나머지는 계속 실행되어야 할 때 사용합니다.",
          "codeExample": "suspend fun fetchDataWithFallback(userId: String): UserData = supervisorScope {\n    val userDeferred = async { fetchUser(userId) }\n    val ordersDeferred = async {\n        try {\n            fetchOrders(userId)\n        } catch (e: Exception) {\n            emptyList()  // 실패 시 빈 리스트 반환\n        }\n    }\n\n    UserData(\n        user = userDeferred.await(),\n        orders = ordersDeferred.await()\n    )\n}",
          "initialCode": "// 코드를 여기에 작성하세요\n",
          "order": 2
        }
      ],
      "order": 2
    },
    {
      "id": "coroutine-scope",
      "title": "코루틴 스코프",
      "description": "코루틴의 생명주기를 제어하는 코루틴 스코프에 대해 학습합니다.",
      "lessons": [
        {
          "id": "4-코루틴-스코프-16",
          "title": "코루틴 스코프",
          "content": "모든 코루틴은 `CoroutineScope` 내에서 실행됩니다. 스코프는 코루틴의 생명주기를 제어하며, 스코프가 취소되면 그 안의 모든 코루틴도 취소됩니다.",
          "codeExample": "// ❌ 나쁜 예: 생명주기 관리가 안 됨\nGlobalScope.launch {\n    delay(10000)\n    println(\"10초 후\")\n}",
          "initialCode": "// 코드를 여기에 작성하세요\n",
          "order": 0
        },
        {
          "id": "4-1-globalscope-사용-지양-17",
          "title": "GlobalScope (사용 지양)",
          "content": "`GlobalScope`는 애플리케이션의 전체 생명주기에 종속된 코루틴을 시작합니다. 이는 코루틴이 언제 끝날지 보장할 수 없으므로 메모리 누수의 원인이 될 수 있습니다. 특별한 경우가 아니면 사용을 지양해야 합니다.",
          "codeExample": "// ❌ 나쁜 예: 생명주기 관리가 안 됨\nGlobalScope.launch {\n    delay(10000)\n    println(\"10초 후\")\n}",
          "initialCode": "// 코드를 여기에 작성하세요\n",
          "order": 1
        },
        {
          "id": "4-2-coroutinescope-생성-18",
          "title": "CoroutineScope 생성",
          "content": "명시적인 `CoroutineScope`를 생성하여 코루틴의 생명주기를 직접 관리하는 것이 좋습니다. 일반적으로 클래스나 컴포넌트의 생명주기에 맞춰 스코프를 생성하고, 해당 컴포넌트가 파괴될 때 `scope.cancel()`을 호출하여 모든 코루틴을 정리합니다.",
          "codeExample": "class MyService {\n    private val scope = CoroutineScope(Dispatchers.Default + SupervisorJob())\n\n    fun startBackgroundTask() {\n        scope.launch {\n            // 백그라운드 작업\n        }\n    }\n\n    fun cleanup() {\n        scope.cancel()  // 모든 코루틴 취소\n    }\n}",
          "initialCode": "// 코드를 여기에 작성하세요\n",
          "order": 2
        },
        {
          "id": "코틀린의-코루틴-구조-123",
          "title": "고아 코루틴(Orphan Coroutine)",
          "content": "부모 스코프와 분리되어 관리되지 않는 코루틴을 '고아 코루틴'이라고 부릅니다. `GlobalScope`를 사용하거나 부모-자식 관계를 무시하면 발생할 수 있으며, 리소스 누수나 예측 불가능한 버그의 원인이 될 수 있습니다. 항상 구조화된 동시성 원칙을 지켜 스코프에 맞춰 코루틴을 생성하고 관리해야 합니다.",
          "order": 3
        }
      ],
      "order": 3
    },
    {
      "id": "coroutine-error-handling",
      "title": "에러 처리",
      "description": "코루틴에서 발생하는 예외를 처리하는 방법을 학습합니다.",
      "lessons": [
        {
          "id": "5-에러-처리-20",
          "title": "코루틴 에러 처리",
          "content": "코루틴에서의 에러 처리는 구조화된 동시성 원칙에 따라 동작합니다. 자식 코루틴에서 발생한 예외는 부모에게 전파됩니다.",
          "codeExample": "suspend fun fetchUser(id: String): User? {\n    return try {\n        // DB 조회\n    } catch (e: Exception) {\n        null\n    }\n}",
          "initialCode": "// 코드를 여기에 작성하세요\n",
          "order": 0
        },
        {
          "id": "5-1-try-catch-21",
          "title": "try-catch 블록",
          "content": "일반적인 동기 코드와 마찬가지로 `try-catch` 블록을 사용하여 `suspend` 함수 호출을 감싸고 예외를 처리할 수 있습니다. 가장 기본적인 예외 처리 방법입니다.",
          "codeExample": "suspend fun fetchUser(id: String): User? {\n    return try {\n        // DB 조회\n    } catch (e: Exception) {\n        null\n    }\n}",
          "initialCode": "// 코드를 여기에 작성하세요\n",
          "order": 1
        },
        {
          "id": "5-2-coroutineexceptionhandler-22",
          "title": "CoroutineExceptionHandler",
          "content": "`CoroutineExceptionHandler`를 `CoroutineScope`의 컨텍스트에 추가하여 잡히지 않은 예외를 처리할 수 있습니다. 주로 전역적인 로깅이나 에러 리포팅에 사용됩니다.",
          "codeExample": "val exceptionHandler = CoroutineExceptionHandler { _, exception ->\n    logger.error(\"코루틴 예외 발생\", exception)\n}\n\nval scope = CoroutineScope(Dispatchers.Default + exceptionHandler)\n\nscope.launch {\n    throw RuntimeException(\"에러!\")\n}",
          "initialCode": "// 코드를 여기에 작성하세요\n",
          "order": 2
        },
        {
          "id": "5-3-supervisorjob으로-격리-23",
          "title": "SupervisorJob으로 격리",
          "content": "`SupervisorJob`을 사용하면 자식 코루틴의 실패가 다른 형제 코루틴이나 부모에게 전파되는 것을 막을 수 있습니다. `supervisorScope`와 함께 사용하여 독립적인 작업들을 안전하게 처리할 수 있습니다.",
          "codeExample": "suspend fun processMultipleItems(items: List<String>) = supervisorScope {\n    items.forEach { item ->\n        launch {\n            try {\n                processItem(item)\n            } catch (e: Exception) {\n                // 이 실패는 다른 아이템 처리에 영향을 주지 않음\n            }\n        }\n    }\n}",
          "initialCode": "// 코드를 여기에 작성하세요\n",
          "order": 3
        }
      ],
      "order": 4
    },
    {
      "id": "coroutine-patterns",
      "title": "실전 패턴",
      "description": "타임아웃, 재시도, 병렬 처리 등 실전에서 유용한 코루틴 패턴을 학습합니다.",
      "lessons": [
        {
          "id": "6-1-타임아웃-설정-26",
          "title": "타임아웃 설정",
          "content": "`withTimeout` 또는 `withTimeoutOrNull`을 사용하여 코루틴 작업에 시간 제한을 설정할 수 있습니다. 정해진 시간 내에 작업이 완료되지 않으면 `TimeoutCancellationException`이 발생하거나 `null`이 반환됩니다.",
          "codeExample": "suspend fun fetchWithTimeout(url: String): String? {\n    return withTimeoutOrNull(5000) {  // 5초 타임아웃\n        // 네트워크 요청\n    }\n}",
          "initialCode": "// 코드를 여기에 작성하세요\n",
          "order": 0
        },
        {
          "id": "6-2-재시도-패턴-27",
          "title": "재시도 패턴",
          "content": "일시적인 오류에 대응하기 위해 재시도 로직을 구현할 수 있습니다. `delay`를 사용하여 지수 백오프(exponential backoff)와 같은 전략을 적용하면 시스템 부하를 줄일 수 있습니다.",
          "codeExample": "suspend fun <T> retry(times: Int = 3, block: suspend () -> T): T {\n    repeat(times - 1) {\n        try {\n            return block()\n        } catch (e: Exception) {\n            // 로깅\n        }\n        delay(1000)\n    }\n    return block() // 마지막 시도\n}",
          "initialCode": "// 코드를 여기에 작성하세요\n",
          "order": 1
        },
        {
          "id": "6-3-병렬-처리-패턴-28",
          "title": "병렬 처리 패턴",
          "content": "`coroutineScope`와 `async`를 함께 사용하면 여러 작업을 병렬로 실행하고 모든 결과가 준비될 때까지 기다릴 수 있습니다. `awaitAll()` 함수를 사용하면 여러 `Deferred` 객체의 결과를 한 번에 받을 수 있습니다.",
          "codeExample": "suspend fun processAllUsers(userIds: List<String>): List<User> = coroutineScope {\n    userIds.map { id ->\n        async { fetchUser(id) }\n    }.awaitAll()\n}",
          "initialCode": "// 코드를 여기에 작성하세요\n",
          "order": 2
        },
        {
          "id": "6-4-캐싱-패턴-29",
          "title": "캐싱 패턴",
          "content": "자주 요청되는 데이터는 메모리에 캐싱하여 성능을 향상시킬 수 있습니다. `Mutex`를 사용하여 여러 코루틴이 동시에 캐시를 수정하는 것을 방지하고 데이터 일관성을 유지할 수 있습니다.",
          "codeExample": "class CachedService {\n    private val cache = ConcurrentHashMap<String, Data>()\n    private val mutex = Mutex()\n\n    suspend fun getData(key: String): Data {\n        cache[key]?.let { return it }\n\n        return mutex.withLock {\n            cache[key]?.let { return it }\n            val newData = // DB 또는 네트워크에서 데이터 조회\n            cache[key] = newData\n            newData\n        }\n    }\n}",
          "initialCode": "// 코드를 여기에 작성하세요\n",
          "order": 3
        },
        {
          "id": "6-5-rate-limiting-패턴-30",
          "title": "Rate Limiting 패턴",
          "content": "외부 API 호출 등에 대해 단위 시간당 요청 횟수를 제한(Rate Limiting)하여 시스템을 보호할 수 있습니다. `Semaphore`나 `delay`를 사용하여 간단한 Rate Limiter를 구현할 수 있습니다.",
          "codeExample": "class RateLimiter(private val maxRequests: Int, private val timeWindowMs: Long) {\n    private val semaphore = Semaphore(maxRequests)\n\n    suspend fun <T> execute(block: suspend () -> T): T {\n        semaphore.acquire()\n        try {\n            return block()\n        } finally {\n            // 일정 시간 후 release\n            CoroutineScope(Dispatchers.Default).launch {\n                delay(timeWindowMs)\n                semaphore.release()\n            }\n        }\n    }\n}",
          "initialCode": "// 코드를 여기에 작성하세요\n",
          "order": 4
        }
      ],
      "order": 5
    },
    {
      "id": "coroutine-flow",
      "title": "Flow - 비동기 스트림",
      "description": "여러 값을 비동기로 반환하는 코루틴 기반 스트림, Flow에 대해 학습합니다.",
      "lessons": [
        {
          "id": "6-6-flow-비동기-스트림-31",
          "title": "Flow - 비동기 스트림",
          "content": "`Flow`는 여러 값을 순차적으로 비동기적으로 생성(emit)할 수 있는 코루틴 기반의 스트림입니다. 데이터베이스 결과, 실시간 업데이트 등 여러 데이터를 시간에 걸쳐 받아야 할 때 유용합니다.",
          "codeExample": "fun getNumbers(): Flow<Int> = flow {\n    for (i in 1..5) {\n        delay(100)\n        emit(i)  // 값 방출\n    }\n}\n\nsuspend fun collectNumbers() {\n    getNumbers().collect { value ->\n        println(value)\n    }\n}",
          "initialCode": "// 코드를 여기에 작성하세요\n",
          "order": 0
        },
        {
          "id": "핵심-개념-완전-쉽게-198",
          "title": "Flow와 DB 변경 감지",
          "content": "`Flow`는 데이터베이스의 변경 사항을 실시간으로 감지하고 UI에 반영하는 데 매우 유용합니다. Room, SQLDelight과 같은 라이브러리는 DB 변경 시 자동으로 새로운 데이터를 `emit`하는 `Flow`를 반환하는 기능을 지원합니다.\n`DB 변경 → Flow.emit() → ViewModel 업데이트 → UI 자동 갱신`",
          "order": 1
        },
        {
          "id": "결론-깨달을-버전-219",
          "title": "StateFlow vs SharedFlow",
          "content": "`StateFlow`: 항상 최신 상태 값을 가지고 있는 상태 저장 `Flow`입니다. UI 상태, 로그인 여부 등 '상태'를 표현하는 데 적합합니다. 새로운 구독자는 즉시 최신 값을 받습니다.\n`SharedFlow`: 여러 구독자에게 이벤트를 브로드캐스트하는 `Flow`입니다. Toast, Navigation 이벤트 등 '한 번만 처리해야 하는 이벤트'에 사용됩니다. 새로운 구독자는 구독 이후에 발생하는 이벤트만 받습니다.",
          "order": 2
        },
        {
          "id": "결론부터-239",
          "title": "Flow vs Kafka",
          "content": "`Flow`는 단일 프로세스 내에서 동작하는 비동기 스트림 기술입니다. 반면 `Kafka`는 여러 분산 시스템 간의 데이터 파이프라인 및 영구 저장소 역할을 합니다. `Flow`는 앱 내부의 데이터 흐름을 다루고, `Kafka`는 서버 간의 대규모 이벤트 스트리밍을 다루므로 역할과 규모가 완전히 다릅니다.",
          "order": 3
        }
      ],
      "order": 6
    },
    {
      "id": "coroutine-optimization",
      "title": "성능 최적화 및 디버깅",
      "description": "코루틴의 성능을 최적화하고 디버깅하는 기법을 학습합니다.",
      "lessons": [
        {
          "id": "7-성능-최적화-32",
          "title": "성능 최적화",
          "content": "코루틴 성능을 최적화하기 위해 불필요한 디스패처 전환을 피하고, 코루틴 스코프를 재사용하며, `Flow`를 메모리 효율적으로 사용하는 등의 기법이 있습니다.",
          "codeExample": "// ❌ 나쁜 예: 불필요한 전환\nsuspend fun processData(data: String): String {\n    return withContext(Dispatchers.IO) {\n        withContext(Dispatchers.Default) {  // 불필요한 전환\n            data.uppercase()\n        }\n    }\n}",
          "initialCode": "// 코드를 여기에 작성하세요\n",
          "order": 0
        },
        {
          "id": "8-디버깅-팁-37",
          "title": "디버깅 팁",
          "content": "코루틴 디버깅을 위해 `CoroutineName`을 지정하여 로그를 명확하게 하거나, `-Dkotlinx.coroutines.debug` JVM 옵션을 사용하여 코루틴의 상태를 추적할 수 있습니다. IntelliJ/Android Studio의 코루틴 디버거를 활용하면 현재 실행 중인 코루틴과 그 상태를 시각적으로 확인할 수 있습니다.",
          "codeExample": "val scope = CoroutineScope(\n    Dispatchers.Default +\n    CoroutineName(\"MyCoroutineScope\")\n)\n\nscope.launch(CoroutineName(\"MyTask\")) {\n    // 로그에서 코루틴 이름 확인 가능\n}",
          "initialCode": "// 코드를 여기에 작성하세요\n",
          "order": 1
        }
      ],
      "order": 7
    },
    {
      "id": "coroutine-comparison",
      "title": "주요 개념 비교",
      "description": "코루틴의 주요 개념들을 비교하며 더 깊이 이해합니다.",
      "lessons": [
        {
          "id": "1-launch나-async는-스코프-안에서만-쓸-수-있다-50",
          "title": "runBlocking의 역할",
          "content": "`launch`나 `async`는 `CoroutineScope`의 확장 함수이므로 스코프 안에서만 사용할 수 있습니다. `runBlocking`은 일반 함수(e.g. `main`)에서 코루틴 세계로 들어가는 '문'의 역할을 합니다. `runBlocking`은 내부적으로 코루틴 스코프를 만들고, 모든 자식 코루틴이 끝날 때까지 현재 스레드를 차단합니다.",
          "codeExample": "public fun CoroutineScope.launch(...): Job",
          "initialCode": "// 코드를 여기에 작성하세요\n",
          "order": 0
        },
        {
          "id": "1-공통점-55",
          "title": "runBlocking vs CoroutineScope",
          "content": "`runBlocking`은 현재 스레드를 차단(block)하고 내부 코루틴이 모두 끝날 때까지 대기하는 반면, `CoroutineScope(...)`는 스레드를 차단하지 않고 비동기적인 코루틴 환경을 생성합니다. 따라서 `runBlocking`은 `main` 함수나 테스트 코드의 진입점에서만 사용하고, 실제 애플리케이션 로직(서버, UI 등)에서는 `CoroutineScope`를 사용해야 합니다.",
          "order": 1
        },
        {
          "id": "먼저-결론부터-말하자면-63",
          "title": "코루틴 vs 스레드",
          "content": "코루틴은 '스레드 위에서 동작하는 가벼운 작업 단위'입니다. 스레드 하나를 독점하지 않고, 필요할 때만 잠시 빌려 쓰고 반납합니다. 스레드는 생성 비용이 비싸지만 코루틴은 매우 저렴하여 수만 개를 동시에 실행할 수 있습니다. `delay()`는 스레드를 반납하며 대기(suspend)하지만, `Thread.sleep()`은 스레드를 점유하며 대기(block)합니다.",
          "order": 2
        }
      ],
      "order": 8
    },
    {
      "id": "coroutine-advanced",
      "title": "코루틴 고급 주제",
      "description": "코루틴의 내부 동작 및 고급 주제에 대해 학습합니다.",
      "lessons": [
        {
          "id": "9-자주-하는-실수-41",
          "title": "자주 하는 실수",
          "content": "코루틴 사용 시 흔히 하는 실수로는 `GlobalScope` 남용, `suspend` 함수 내에서 블로킹 호출(`runBlocking` 등) 사용, 예외 무시, 작업 성격에 맞지 않는 디스패처 선택 등이 있습니다. 이러한 실수는 성능 저하나 예측 불가능한 동작을 유발할 수 있습니다.",
          "codeExample": "// ❌ 잘못된 예\nsuspend fun fetchData(): String {\n    return runBlocking {  // suspend 함수 안에서 runBlocking 사용 금지!\n        httpClient.get(\"url\")\n    }\n}",
          "initialCode": "// 코드를 여기에 작성하세요\n",
          "order": 0
        },
        {
          "id": "코루틴의-fsm과-힙-메모리-저장-방식-109",
          "title": "코루틴의 내부 동작 (FSM)",
          "content": "코틀린 컴파일러는 `suspend` 함수를 FSM(Finite State Machine)으로 변환합니다. 함수의 지역 변수들은 `Continuation` 객체의 필드로 저장되어 힙 메모리에 보관됩니다. 이를 통해 코루틴이 중단되었다가 다른 스레드에서 재개되어도 상태가 유지될 수 있습니다.",
          "order": 1
        },
        {
          "id": "호출-그룹-caller-group-코루틴이-어느-job-계층에-속해-있는가-structured-concurrency의-부모-자식-관계-127",
          "title": "호출 그룹 vs 워커 그룹",
          "content": "호출 그룹(Caller Group)은 코루틴의 `Job` 계층 구조(부모-자식 관계)를 의미하며, 생명주기, 예외/취소 전파를 담당합니다. 워커 그룹(Worker Group)은 코루틴이 실제로 실행되는 스레드 풀(`Dispatcher`)을 의미합니다. 이 둘은 서로 독립적입니다.",
          "order": 2
        }
      ],
      "order": 9
    },
    {
      "id": "dsl-288655e8316980949c8cf8a38253771d",
      "title": "코틀린 DSL",
      "description": "",
      "lessons": [
        {
          "id": "코틀린-dsl-0",
          "title": "코틀린 DSL",
          "content": "",
          "order": 0
        },
        {
          "id": "1-dsl이란-무엇인가-1",
          "title": "1. DSL이란 무엇인가?",
          "content": "1.1 DSL의 정의DSL(Domain Specific Language)은 특정 도메인이나 문제 영역에 특화된 언어입니다. 범용 프로그래밍 언어와 달리, DSL은 특정 작업을 더 쉽고 명확하게 표현하기 위해 설계됩니다.범용 언어 vs DSL:범용 언어(GPL): Java, Python, C++ 등 - 모든 종류의 문제를 해결할 수 있도록 설계DSL: SQL, HTML, CSS, Gradle 등 - 특정 도메인의 문제 해결에 최적화1.2 DSL의 종류외부 DSL (External DSL):독립적인 문법과 구문을 가진 언어별도의 파서와 인터프리터가 필요예: SQL, HTML, CSS, Regex내부 DSL (Internal DSL):호스트 언어(일반 프로그래밍 언어) 내부에서 작성호스트 언어의 문법을 활용별도의 파서 불필요예: Kotlin의 HTML DSL, Gradle Kotlin DSL1.3 DSL의 장점가독성 향상:도메인 전문가와의 협업:비개발자도 이해하기 쉬운 코드비즈니스 로직을 명확하게 표현유지보수성 향상생산성 증가:보일러플레이트 코드 감소직관적인 API타입 안정성 보장",
          "codeExample": "// 일반적인 코드\nval table = Table()\ntable.addRow(Row().apply {\n    addCell(Cell(\"Name\"))\n    addCell(Cell(\"Age\"))\n})\n\n// DSL을 사용한 코드\ntable {\n    row {\n        cell(\"Name\")\n        cell(\"Age\")\n    }\n}",
          "initialCode": "// Write your code here\n",
          "order": 1
        }
      ],
      "order": 10
    },
    {
      "id": "ktor-features",
      "title": "Ktor 웹 프레임워크",
      "description": "Ktor 프레임워크의 주요 기능과 코루틴 활용법을 학습합니다.",
      "lessons": [
        {
          "id": "요약하자면-86",
          "title": "Ktor와 코루틴",
          "content": "Ktor의 라우팅 핸들러(`get`, `post` 등)는 이미 코루틴 환경이므로, 내부에서 `suspend` 함수를 바로 호출할 수 있습니다. `launch`나 `async`를 불필요하게 사용할 필요가 없습니다. 요청과 독립적인 백그라운드 작업이 필요할 때만 `application.launch` 등을 사용하여 별도의 스코프에서 코루틴을 실행합니다.",
          "order": 0
        },
        {
          "id": "1-가장-큰-차이-ktor는-코루틴-기반-spring은-스레드-기반-95",
          "title": "Ktor vs Spring MVC",
          "content": "Ktor는 요청마다 코루틴을 사용하여 논블로킹 방식으로 동작하는 반면, Spring MVC는 요청마다 스레드를 할당하여 블로킹 방식으로 동작합니다. 이 차이로 인해 Ktor는 적은 스레드로 많은 동시 요청을 효율적으로 처리할 수 있습니다.",
          "order": 1
        },
        {
          "id": "kotlin의-content-negotiation-140",
          "title": "Content Negotiation (콘텐츠 협상)",
          "content": "Content Negotiation은 클라이언트와 서버가 HTTP 헤더(`Accept`, `Content-Type`)를 통해 데이터 포맷(JSON, XML 등)을 협상하는 메커니즘입니다. Ktor는 `ContentNegotiation` 플러그인을 통해 이 과정을 자동화하여, 객체를 자동으로 직렬화/역직렬화 해줍니다.",
          "order": 2
        },
        {
          "id": "설치-및-기본-사용-155",
          "title": "Call Logging (호출 로깅)",
          "content": "`CallLogging` 플러그인을 설치하면 들어오는 모든 HTTP 요청과 응답을 자동으로 로깅할 수 있습니다. 이를 통해 API 호출을 쉽게 추적하고 디버깅할 수 있습니다.",
          "codeExample": "fun Application.configureLogging() {\n    install(CallLogging) {\n        level = Level.INFO\n    }\n}",
          "initialCode": "// 코드를 여기에 작성하세요\n",
          "order": 3
        },
        {
          "id": "왜-필요한가-161",
          "title": "Caching Headers (캐싱 헤더)",
          "content": "`CachingHeaders` 플러그인은 HTTP 응답에 `Cache-Control`과 같은 캐싱 관련 헤더를 쉽게 추가할 수 있게 해줍니다. 클라이언트나 프록시 서버가 응답을 캐싱하도록 하여 성능을 향상시키고 서버 부하를 줄일 수 있습니다.",
          "order": 4
        },
        {
          "id": "기본-설정-168",
          "title": "Status Pages (상태 페이지)",
          "content": "`StatusPages` 플러그인을 사용하면 예외나 HTTP 상태 코드(404 Not Found, 500 Internal Server Error 등)에 따라 일관된 에러 응답 페이지나 JSON 응답을 중앙에서 처리할 수 있습니다. 이를 통해 에러 처리 코드를 깔끔하게 관리할 수 있습니다.",
          "codeExample": "install(StatusPages) {\n    exception<IllegalArgumentException> { call, cause ->\n        call.respond(HttpStatusCode.BadRequest, cause.message ?: \"Invalid argument\")\n    }\n}",
          "initialCode": "// 코드를 여기에 작성하세요\n",
          "order": 5
        },
        {
          "id": "커넥션-풀링이-없을-때-비효율-176",
          "title": "DB 커넥션 풀링",
          "content": "커넥션 풀링은 데이터베이스 연결을 미리 여러 개 만들어 '풀(pool)'에 보관하고, 필요할 때마다 빌려 쓰고 반납하는 기술입니다. 매 요청마다 DB 연결을 새로 생성하고 닫는 비용을 없애주므로 웹 애플리케이션의 성능을 크게 향상시킵니다. HikariCP는 Ktor에서 널리 사용되는 커넥션 풀 라이브러리입니다.",
          "order": 6
        }
      ],
      "order": 11
    },
    {
      "id": "kotlin-core-features",
      "title": "코틀린 핵심 기능",
      "description": "데이터 클래스, 확장 함수, 예외 처리 등 코틀린의 핵심적인 기능들을 학습합니다.",
      "lessons": [
        {
          "id": "1-데이터-클래스-data-class-15",
          "title": "데이터 클래스 (Data Class)",
          "content": "`data class`는 데이터 보관을 목적으로 하는 클래스를 간결하게 생성하는 키워드입니다. `toString()`, `equals()`, `hashCode()`, `copy()`와 같은 보일러플레이트 메서드를 자동으로 생성해주어 DTO, VO, 모델 클래스 작성 시 매우 유용합니다.",
          "order": 0
        },
        {
          "id": "2-확장-함수-extension-function-22",
          "title": "확장 함수 (Extension Function)",
          "content": "확장 함수는 기존 클래스의 소스 코드를 수정하지 않고 새로운 함수를 추가하는 기능입니다. 표준 라이브러리나 외부 라이브러리의 클래스에 유틸리티 함수를 추가하여 코드의 가독성과 재사용성을 높일 수 있습니다.",
          "codeExample": "fun String.isEmail(): Boolean = this.contains(\"@\") && this.contains(\".\")",
          "initialCode": "// 코드를 여기에 작성하세요\n",
          "order": 1
        },
        {
          "id": "chatgpt-said-240",
          "title": "에러 처리 기법",
          "content": "코틀린에서는 `try/catch` 외에도 `Result<T>`, `sealed class`, `Arrow` 라이브러리의 `Either` 등 다양한 방법으로 오류를 처리할 수 있습니다. 함수형 스타일의 값 기반 에러 처리는 오류를 타입으로 명시하여 코드의 안정성을 높여줍니다.",
          "order": 2
        },
        {
          "id": "kotlin-result-문법-한눈에-정리-261",
          "title": "Result<T> 타입",
          "content": "`Result<T>`는 성공 값(T) 또는 실패(Throwable)를 감싸는 표준 라이브러리 타입입니다. `runCatching`과 함께 사용하면 예외가 발생할 수 있는 코드를 안전하게 실행하고, 그 결과를 값으로 다룰 수 있게 해줍니다.",
          "order": 3
        },
        {
          "id": "1-함수형-프로그래밍이란-267",
          "title": "함수형 프로그래밍",
          "content": "함수형 프로그래밍은 순수 함수(pure function)와 불변 데이터(immutable data)를 사용하여 부수 효과(side effect)를 최소화하는 프로그래밍 패러다임입니다. 코틀린은 `map`, `filter`와 같은 고차 함수를 통해 함수형 스타일을 강력하게 지원하며, 이를 통해 더 간결하고 예측 가능한 코드를 작성할 수 있습니다.",
          "order": 4
        },
        {
          "id": "1-핵심-차이-283",
          "title": "forEach vs also",
          "content": "`forEach`는 컬렉션을 반복 실행만 하고 `Unit`을 반환하여 체이닝이 불가능합니다. 반면 `also`는 자기 자신을 반환하므로, 중간에 로깅과 같은 부가 작업을 수행한 후에도 함수 체이닝을 계속 이어갈 수 있습니다.",
          "order": 5
        },
        {
          "id": "1-sum-vs-sumof-288",
          "title": "sum vs sumOf",
          "content": "`sum()`은 숫자 타입의 컬렉션에서만 사용할 수 있습니다. `sumOf`는 객체 컬렉션에서 특정 숫자 프로퍼티(예: 학생의 점수, 상품의 가격)를 추출하여 합계를 구할 때 사용합니다.",
          "order": 6
        },
        {
          "id": "요약-문장-버전-293",
          "title": "스코프 함수 (let, run, with, apply, also)",
          "content": "스코프 함수는 객체의 컨텍스트 내에서 코드 블록을 실행하는 함수입니다. `let`(null 체크 및 변환), `run`(객체 함수 실행 및 결과 반환), `with`(객체 속성 그룹화), `apply`(객체 설정 및 초기화), `also`(부가 효과 및 로깅) 등 각각의 용도에 맞게 사용하면 코드를 더 간결하고 읽기 쉽게 만들 수 있습니다.",
          "order": 7
        },
        {
          "id": "1-기본-개념-312",
          "title": "lateinit",
          "content": "`lateinit`은 non-null 프로퍼티의 초기화를 나중으로 미룰 때 사용하는 키워드입니다. 주로 의존성 주입(DI)이나 Android의 `onCreate`와 같이 객체 생성 시점에는 초기화할 수 없는 프로퍼티에 사용됩니다. 초기화 전에 접근하면 `UninitializedPropertyAccessException`이 발생합니다.",
          "order": 8
        }
      ],
      "order": 12
    },
    {
      "id": "269655e8316980c8b99ee445a0c925bc",
      "title": "코틀린 미래",
      "description": "",
      "lessons": [
        {
          "id": "코틀린-미래-0",
          "title": "코틀린 미래",
          "content": "",
          "order": 0
        },
        {
          "id": "1-기초를-단단히-1",
          "title": "코틀린 마스터 로드맵",
          "content": "코틀린 전문가가 되기 위한 학습 로드맵입니다. 기초 문법부터 시작하여, 코루틴, DSL, 멀티플랫폼 등 심화 주제를 거쳐, 최종적으로는 컴파일러 내부 동작과 언어 설계 철학까지 이해하는 것을 목표로 합니다.",
          "order": 1
        },
        {
          "id": "코틀린-kotlin-마스터-로드맵-7",
          "title": "1단계: 코틀린 기초 다지기",
          "content": "변수, 제어 흐름, 함수, 클래스 등 기본적인 문법과 개념을 익히고, 자바와의 차이점을 명확하게 이해하는 단계입니다.",
          "order": 2
        },
        {
          "id": "2단계-코틀린-중급-코틀린다운-코드-작성-3-4주-9",
          "title": "2단계: 코틀린다운 코드 작성",
          "content": "데이터 클래스, 확장 함수, 람다, 스코프 함수, 컬렉션 API 등 코틀린의 특성을 활용하여 간결하고 효율적인 코드를 작성하는 능력을 기르는 단계입니다.",
          "order": 3
        },
        {
          "id": "3단계-코틀린-고급-동시성-프로그래밍-5-6주-10",
          "title": "3단계: 동시성 프로그래밍 (코루틴)",
          "content": "코루틴, `suspend` 함수, 디스패처, `Flow` 등을 완벽하게 이해하고 비동기 및 동시성 프로그래밍을 능숙하게 처리하는 단계입니다.",
          "order": 4
        },
        {
          "id": "4단계-멀티플랫폼-프로젝트-7-8주-11",
          "title": "4단계: 멀티플랫폼 프로젝트 (KMP)",
          "content": "Kotlin Multiplatform(KMP)을 활용하여 Android, iOS, 데스크톱 등 여러 플랫폼에서 동작하는 애플리케이션을 개발하며 공통 로직을 공유하는 방법을 학습하는 단계입니다.",
          "order": 5
        },
        {
          "id": "5단계-실전-프로젝트-및-심화-학습-9주-이후-12",
          "title": "5단계: 심화 학습 및 실전",
          "content": "개인 프로젝트, 오픈 소스 기여 등을 통해 실전 문제 해결 능력을 기르고, 코틀린의 새로운 기술 동향을 꾸준히 학습하는 단계입니다.",
          "order": 6
        }
      ],
      "order": 13
    }
  ]
}
